<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://yeoji21.github.io/</id><title>yeoji21</title><subtitle>어서와</subtitle> <updated>2022-07-18T00:51:17+09:00</updated> <author> <name>yeoji21</name> <uri>https://yeoji21.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://yeoji21.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://yeoji21.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 yeoji21 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>[JPA] @OneToOne 연관관계 매핑 시 주의사항</title><link href="https://yeoji21.github.io/posts/jpa-one-to-one/" rel="alternate" type="text/html" title="[JPA] @OneToOne 연관관계 매핑 시 주의사항" /><published>2022-07-17T00:00:00+09:00</published> <updated>2022-07-17T00:00:00+09:00</updated> <id>https://yeoji21.github.io/posts/jpa-one-to-one/</id> <content src="https://yeoji21.github.io/posts/jpa-one-to-one/" /> <author> <name>yeoji21</name> </author> <category term="Backend" /> <category term="ORM" /> <category term="JPA" /> <summary> 이번 포스트에서는 JPA의 @OneToOne 매핑을 사용하면서 마주한 문제에 대해 얘기해보겠습니다. 결론부터 말씀드리자면 JPA에서 OneToOne 관계로 엔티티를 연결할 경우, Lazy Loading이 보장되지 않을 수 있습니다. 어떤 경우에 이런 문제가 발생하고, 어떻게 해결하면 좋을까요? 문제 상황을 간단히 하면 다음과 같습니다. 하나의 가게는 하나의 가게 위치를 갖습니다. 이때 가게의 위치는 가게를 지도에 표시하기 위한 위도, 경도 정보를 비롯한 다양한 정보들이 추가될 수 있기 때문에 가게 위치 테이블로 별도로 분리하고 가게와 1:1 연관 관계를 맺고 있습니다. 여기서 두 엔티티간의 비즈니스적 관계를 보면 가게가 가게 위치를 가지는 주인의 역할을 하기 때문에 가게를 주인 엔티티, 가게... </summary> </entry> <entry><title>객체지향에서의 상속과 다형성</title><link href="https://yeoji21.github.io/posts/polymorphism-inheritance/" rel="alternate" type="text/html" title="객체지향에서의 상속과 다형성" /><published>2022-07-13T00:00:00+09:00</published> <updated>2022-07-15T18:17:51+09:00</updated> <id>https://yeoji21.github.io/posts/polymorphism-inheritance/</id> <content src="https://yeoji21.github.io/posts/polymorphism-inheritance/" /> <author> <name>yeoji21</name> </author> <category term="Backend" /> <category term="OOP" /> <summary> 들어가면서 해당 포스트는 조영호님의 오브젝트를 바탕으로 정리한 글입니다. 객체지향과 상속 객체지향 언어에서 상속은 뗼레야 뗄 수 없는 관계라는 말, 자주 들어보셨을 것 같은데요 저도 학교에서 자바를 처음 배울 때 상속을 강의 초반에 배웠고 굉장히 재밌다고 느꼈던 기억이 있습니다. (처음 배운 자바와 C언어와의 직접적인 차이점이었던 것 같네요 🤔) 그만큼 상속은 객체지향에서 굉장히 중요하고 기본적인 개념이기에 모두가 상속에 대해서 알고는 있지만, 모두가 상속을 올바르게 이해하고 있지는 않을 것 같습니다. 불과 얼마 전까지 누군가 저에게 상속을 한 마디로 정의해보라고 한다면 “자식 클래스가 부모 클래스를 상속받아서 부모 클래스의 코드를 재사용하고 확장하는 기능이요!” 라고 했을 것 같은데요 ... </summary> </entry> <entry><title>[JAVA] Java Refelction 마스터 강의 3장</title><link href="https://yeoji21.github.io/posts/reflection-3/" rel="alternate" type="text/html" title="[JAVA] Java Refelction 마스터 강의 3장" /><published>2022-06-21T00:00:00+09:00</published> <updated>2022-06-21T00:00:00+09:00</updated> <id>https://yeoji21.github.io/posts/reflection-3/</id> <content src="https://yeoji21.github.io/posts/reflection-3/" /> <author> <name>yeoji21</name> </author> <category term="Backend" /> <category term="Java" /> <summary> 들어가면서 유데미의 Java 심화 과정: Java Reflection 마스터 강의 내용을 정리한 글입니다. 자세한 내용은 강의를 통해 확인해주시길 바랍니다. 필드 검사와 배열 검사 필드 개요 자바 클래스에서 필드는 클래스나 인터페이스 안에서 선언된 변수를 의미 클래스 인스턴스에 따라 메모리와 값은 다름 Reflection에서 Field 클래스는 각 필드를 의미하며, 각 필드 객체에는 필드 이름이 있고 필드 타입과 다양한 특성이 있다. Field 클래스를 얻는 방법 Class.getDeclaredFields() 클래스에 선언된 필드 배열을 반환하는 메소드 접근 제어자에 상관없이 모든 필드를 포함 단, 상속된 필드는 제외됨 ... </summary> </entry> <entry><title>[JAVA] Java Refelction 마스터 강의 2장</title><link href="https://yeoji21.github.io/posts/reflection-2/" rel="alternate" type="text/html" title="[JAVA] Java Refelction 마스터 강의 2장" /><published>2022-06-20T00:00:00+09:00</published> <updated>2022-06-20T00:00:00+09:00</updated> <id>https://yeoji21.github.io/posts/reflection-2/</id> <content src="https://yeoji21.github.io/posts/reflection-2/" /> <author> <name>yeoji21</name> </author> <category term="Backend" /> <category term="Java" /> <summary> 들어가면서 유데미에 있는 Java 심화 과정: Java Reflection 마스터 강의 내용을 정리한 글입니다. 자세한 내용은 강의를 통해 확인해주시길 바랍니다. 1. 객체 생성과 생성자 Constructor 클래스 자바 클래스의 생성자는 Constructor 클래스의 인스턴스로 나타냄 이 객체는 클래스 생성자의 모든 정보를 포함 Constructor 클래스를 얻는 방법 첫 번째로 클래스의 생성자를 얻는 가장 유용한 메소드는 Class.getDeclaredConstructors() 생성자의 접근자에 관계없이 클래스에 선언된 모든 생성자를 반환 두 번째는 Class.getConstructors() 메소드 클래스의 public ... </summary> </entry> <entry><title>[JAVA] Java Refelction 마스터 강의 1장</title><link href="https://yeoji21.github.io/posts/reflection-1/" rel="alternate" type="text/html" title="[JAVA] Java Refelction 마스터 강의 1장" /><published>2022-06-19T00:00:00+09:00</published> <updated>2022-06-21T12:15:31+09:00</updated> <id>https://yeoji21.github.io/posts/reflection-1/</id> <content src="https://yeoji21.github.io/posts/reflection-1/" /> <author> <name>yeoji21</name> </author> <category term="Backend" /> <category term="Java" /> <summary> 들어가면서 유데미에 있는 Java 심화 과정: Java Reflection 마스터 강의 내용을 정리한 글입니다. 자세한 내용은 강의를 통해 확인해주시길 바랍니다. 1. Java Reflection 개요 리플렉션이란 실행하는 동안 애플리케이션 클래스와 객체 정보를 추출할 수 있는 JVM 기능이다. JDK의 리플렉션 API로 구현할 수 있다. 리플렉션을 통해 다양한 sw 컴포넌트를 연결하고 소스 코드의 수정 없이 새로운 프로그램 순서를 만들 수 있다. 프로그램을 실행하면서 객체와 클래스를 분석하고 이를 입력값으로 사용할 수 있어 훌륭한 라이브러리와 프레임워크를 만들고 뛰어난 sw 설계를 할 수 있다. 리플렉션 사용 예시 대표적으로 JUnit이 리플렉션을 사용한 프레임워크 ... </summary> </entry> </feed>
