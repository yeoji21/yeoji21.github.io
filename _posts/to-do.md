
- 인프런 스프링 강의 정리

- JPA 강의

- 메이븐이나 그레들 중 하나는 공부할 것  

- 읽고 싶은 책 : 이펙티브 자바, 오브젝트, 디자인 패턴, 리펙토링, 토비의 스프링, 클린코드
  
--------------------------------------------------------------


 영속성 컨텍스트

EntityManager.persist(entity)는 사실 DB에 데이터를 저장하는 것이 아니고 엔티티를 영속성 컨텍스트에 저장하는 메소드임
엔티티 매니저를 통해서 영속성 컨텍스트에 접근하는 것


1차 캐시에서 조회
em.find()하면 바로 DB에서 데이터를 찾는 것이 아니고 1차 캐시에서 먼저 찾음
1차 캐시에 없는 데이터를 읽으려고 하면 DB에서 조회한 후 1차캐시에 저장 후 반환함
하지만 1차 캐시는 한 트랜잭션 안에서만 유효하기 때문에 성능적 이점이 매우 크지는 않음

JPA의 엔티티 클래스는 리플렉션 등에서 사용하기 위해 꼭! 기본 생성자를 가져야 한다. 

flush()를 호출한다고 1차 캐시에 있는 내용이 영향을 받는 것은 아니고, 단지 쓰기 지연 저장소에 있던 SQL이 DB에 반영된다. 
SQPL 실행시에도 flush()가 자동으로 호출된다. 

영속 상태 : 영속성 컨텍스트에 의해 관리되고 있는 상태 
준영속 상태 : 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)된 상태, 영속성 컨텍스트가 제공하는 기능을 사용하지 못함

java8 이후 버전은 LocalDate타입을 쓰면 어노테이션 없어도 DB에 date타입으로 들어가고, LocalDateTime을 쓰면 DB에 timestamp로 들어감

대체키는 UUID 같은 것을 말함

@GeneratedValue(strategy = GenerationType.IDENTITY)를 사용하면 기본값을 자동으로 넣어주기 때문에 코드에서 기본값을 설정하면 안되는데, 영속성 컨텍스트에서는 기본값을 기준으로 1차 캐시에 엔티티들을 저장하고 있었다.
따라서 이 때만 울며 겨자먹기식으로? pesist() 호출 시에 바로 insert 쿼리가 나간다.  

SEQUNECE에서는 해당 시퀑스 테이블에서 PK값만 호출해오기 때문에 다른 방식처럼 쿼리 버퍼링 가능