---
title: "백기선님과 함께 하는 자바 스터디 - 08"
author: "yeoji21"
date: 2021-08-19
categories: [Backend, Java]
tags: [java, java study, 자바, 자바 스터디]
pin: true
---

<img src="https://media.vlpt.us/images/inhalin/post/b48b4cd3-619b-4bf4-939c-d3546dd2ec01/whiteship.png">

## 들어가면서
백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다.  
강의 영상 링크 : [[자바 라이브 스터디] 2020/1/9, 8주차 인터페이스
](https://www.youtube.com/watch?v=v2BXL6SYaBc&list=PLfI752FpVCS96fSsQe2E3HzYTgdmbz6LU&index=16)  
강의 깃허브 링크 : [8주자 과제: 인터페이스](https://github.com/whiteship/live-study/issues/8)

## 목차
- 인터페이스 정의하는 방법
- 인터페이스 구현하는 방법
- 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법
- 인터페이스 상속
- 인터페이스의 기본 메소드 (Default Method), 자바 8
- 인터페이스의 static 메소드, 자바 8
- 인터페이스의 private 메소드, 자바 9

### **인터페이스란?**
인터페이스란, 객체와 객체 사이에서 일어나는 상호작용의 매개로 쓰인다. 추상 메소드의 집합으로 이루어져 있기 때문에 구현된 것이 없는 설계도라고 볼 수 있다.  

추상 메소드를 가지기 때문에 추상 클래스와 유사하지만, 추상 클래스보다 추상화 정도가 높기 때문에 멤버 변수는 오직 상수형만 허용하고 메소드는 모두 추상 메소드로 선언되어야 한다.  
> Java 8 이후부터 인터페이스에서도 default method를 사용할 수 있게 되었다.  

인터페이스의 대표적인 예로 `List`가 있고 `ArrayList`는 그것을 구현한 클래스이다.  

#### 인터페이스의 장점
- **개발 시간 단축**   
    구현 클래스는 메소드 로직을 구현하기만 하면 됨 
- **표준화**   
    같은 인터페이스를 구현하는 구현 클래스들은 일관되고 정형화된 구조로 클래스를 작성할 수 있기 때문에 다형성을 극대화하고 유지보수성을 높일 수 있음
- **서로 관계 없는 클래스들 간의 연결다리 역할**  
    하나의 인터페이스를 구현함으로써 클래스 간의 관계를 맺어줄 수 있음
- **독립적인 프로그래밍이 가능**  
    선언과 구현을 분리함으로써 코드 종속성을 줄이고 유지보수성을 높일 수 있음

### **인터페이스 정의하는 방법**
인터페이스의 선언은 예약어로 `interface`를 사용하며, 접근 제어자로는 `public` 또는 `defualt`를 사용할 수 있다.  

```java
interface Monster{
    int age = 10;       //public static final int age = 10;
    void attack();      //public abstract attack();
}

```
인터페이스는 멤버 변수로 상수만 가질 수 있다고 했기 때문에 인터페이스 내부에 선언하는 멤버 변수는 모두 `public static final`이 생략되어 있다.   

또한, 인터페이스 내부의 모든 메소드는 추상 메소드로 간주되기 때문에 `public abstract`가 붙은 것과 같다. 따라서 이 키워드를 생략할 수 있지만 구현 클래스에서 오버라이딩할 때는 반드시 `public`을 붙여서 재정의해야 한다.
>왜 public을 명시해야하는지 이해가 가지않는다면 [이전 포스트](https://yeoji21.github.io/posts/javastudy06-01/)에서 메소드 오버라이딩 부분을 읽어보길 추천한다. 

하지만 Java8 이후로 큰 변화가 있었다. Java8 이전까지는 인터페이스 내부에 상수와 추상 메소드만 선언 가능했지만, **Java8 이후부터는 인터페이스 내부에 `default method`와 `static method`를 선언할 수 있게 되었다.**

이러한 변화로 인해 이전까지는 강제성이 강했던 인터페이스에 유연함을 추가할 수 있게되었다. 또한 Java9부터는 private method도 추가할 수 있게 되었는데 이 내용은 포스트 뒷 부분에서 자세히 다루겠다.  

```java
interface Monster{
    int age = 10;                      //상수
    void attack();                     //추상 메소드
    default void sayHello(){           //디폴트 메소드
        System.out.println("Hi this is default method");
    }
    static int getInt(){               //스태틱 메소드
        return age;
    }
}
```

`default method`는 인터페이스에서 기본적으로 제공하기 때문에 구현 클래스에서 바로 사용할 수 있고 해당 클래스에 맞게 오버라이딩할 수도 있다. 하지만 `static method`는 알다시피 오버라이딩이 안되기 때문에 인터페이스에서 제공하는 그대로 사용해야 한다.

인터페이스에 기본 메소드도 선언이 가능해진 이 시점에서, Java8 이후의 인터페이스는 추상 클래스와 다를게 없다고 느낄 수도 있다. 하지만 둘 간의 분명한 차이가 존재한다.  

#### 또 나왔다! 인터페이스 vs 추상 클래스
우선 이전 포스트 중 클래스에 대해 다룰 때도 언급했지만, 인터페이스와 추상 클래스는 만들어진 존재 이유 자체가 다르다. 

추상 클래스는 **"is-a : ~는 ~이다"** 의 개념으로 자식 클래스에서 추상 클래스를 상속받아 계층구조를 이어나가면서 기능을 확장하게 하기 위함이고,  

인터페이스는 **"has-a : ~는 ~를 할 수 있다"** 의 개념이기 때문에 인터페이스를 구현한 클래스들에서 같은 동작을 하는 것을 보장하기 위해 사용한다.  

또한 기능적인 차이도 존재하는데, 인터페이스 내의 멤버변수는 무조건 `public static final`로 선언되기 때문에, 인터페이스가 `default method`를 사용하더라도 메소드 로직상에서 상태를 나타낼 멤버변수가 필요한 경우에는 인터페이스가 적합하지 않다.  

### **인터페이스 구현하는 방법**
인터페이스는 구현 클래스에서 `implements` 키워드를 사용하여 구현한다. 인터페이스는 다중상속이 가능하기 때문에 한 클래스에서 두 개이상의 인터페이스를 동시에 구현할 수 있다.  

인터페이스 구현 시, 인터페이스에 선언된 추상 메소드를 모두 구현해야 한다. 추상 메소드 구현 시 앞서 언급했다시피 `public` 접근 제한자를 붙여주는 것을 잊지말자.

```java
class Digimon implements Monster, Digital{

    @Override
    public void attack() {
        System.out.println("Digimon call attack method");
    }
    @Override
    public void powerOn() {
        System.out.println("Power On");
    }
}
```

### **인터페이스 레퍼런스를 통해 구현체를 사용하는 방법**