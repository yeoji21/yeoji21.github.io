---
title: "[JAVA] 스트림 (Stream)"
author: "yeoji21"
date: '2021-09-04 00:00:00 +0900'
categories: [Backend, Java]
tags: [java, 자바]
---

## 목차
- 스트림이란?


### **스트림이란?**
지금까지 우리는 많은 수의 데이터를 다룰 때, 컬렉션이나 배열에 데이터를 담은 뒤 원하는 결과를 얻기 위해 `for문`과 `Iterator`를 이용해서 코드를 작성했다. 그러나 이런 방식으로 작성된 코드는 너무 길고 알아보기 힘들뿐더러 코드의 재사용성도 떨어진다.  

또 다른 문제는 데이터 소스마다 다른 방식으로 다뤄야한다는 것인데, `Collection`이나 `Iterator`와 같은 인터페이스를 이용해서 컬렉션을 다루는 방식을 표준화하기는 했지만

각 컬렉션 클래스에는 같은 기능의 메소드들이 중복해서 정의되어 있다. 예를 들어 `List`를 정렬할 때는 `Collections.sort()`를 사용해야하고, 배열을 정렬할 때는 `Arrays.sort()`를 사용해야 한다. 

이러한 문제점들을 해결하기 위해서 만든 것이 `스트림(stream)`이다. 스트림은 데이터 소스를 추상화하고, 데이터를 다루는데 자주 사용되는 메소드들을 정의해 놓았다. 따라서 데이터 소스가 무엇이던 간에 같은 방식으로 다룰 수 있게 되었고 코드의 재사용성이 향상되었다.

스트림을 사용하면, 배열이나 컬렉션뿐만 아니라 파일에 저장된 데이터도 모두 같은 방식으로 다룰 수 있다. 

예를 들어, 같은 내용을 저장하는 문자열 배열과 `List`가 있을 때,
```java
String[] arr = {"aaa", "ddd", "ccc"};
List<String> list = Arrays.asList(arr);
```

이 두가지 데이터 소스를 기반으로 하는 스트림의 생성 방법은 아래와 같다. 
```java
Stream<String> stream1 = list.stream();
Stream<String> stream2 = Arrays.stream(arr);
```

두 가지 스트림으로 데이터 소스의 데이터를 읽어서 정렬하고 화면에 출력하는 방법은 다음과 같다. 데이터 소스가 정렬되는 것은 아니라는 점에 유의하자
```java
stream1.sorted().forEach(System.out::println);
stream2.sorted().forEach(System.out::println);
```
이 두 스트림의 데이터 소스는 서로 다르지만, 정렬하고 출력하는 방법은 완전히 동일한 것을 알 수 있다. 

#### 스트림은 데이터 소스를 변경하지 않는다.
스트림은 데이터 소스로부터 데이터를 읽기만할 뿐, 데이터 소스를 변경하지 않는다는 차이가 있다. 필요하다면, 변경된 결과를 컬렉션이나 배열에 담아서 반환할 수도 있다. 

```java
List<String> sortedList = stream1.sorted().collect(Collectors.toList());
```

#### 스트림은 일회용이다. 
스트림은 `Iterator`처럼 일회용이다. 따라서 컬렉션의 요소를 모두 읽고 나면 다시 사용할 수 없기때문에 필요하다면 스트림을 다시 생성해야 한다. 
```java
stream1.sorted().forEach(System.out::println);
long count = stream1.count();
System.out.println(count);
```
```console
Exception in thread "main" java.lang.IllegalStateException: stream has already been operated upon or closed
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)
	at java.base/java.util.stream.ReferencePipeline.count(ReferencePipeline.java:605)
	at com.example.javastudy.week15.StreamEx.main(StreamEx.java:17)
```

#### 스트림은 작업을 내부 반복으로 처리한다. 
스트림은 반복문을 메소드의 내부에 숨기는 **내부 반복**을 사용하기 때문에 간결한 작업이 가능한 것이다. `forEach()`는 매개변수에 대입된 람다식을 데이터 소스의 모든 요소에 적용한다. 

즉, `forEach()`는 메소드 안으로 `for문`을 넣은 것이다. 수행할 작업은 매개변수로 받는다. 

```java
void forEach(Consumer<? super T> action){
    Objects.requireNonNull(action); //매개변수 null 체크

    for(T t : src){                 //내부반복
        action.accept(T);
    }
}
```

#### 스트림의 연산
스트림이 제공하는 연산은 `중간 연산`과 `최종 연산`으로 분류할 수 있는데, 중간 연산은 연산 결과를 스트림으로 반환하기 때문에 중간 연산을 연속해서 연결할 수 있다. 반면에 최종 연산은 스트림의 요소를 소모하면서 연산을 수행하므로 단 한번만 연산이 가능하다. 

|중간연산|설명|
|--:|--:|
|Stream\<T\> **distinct()** |중복을 제거|
|Stream\<T\> **filter(Predicate\<T\> predicate)** |조건에 안맞는 요소 제외|
|Stream\<T\> **limit(long maxSize)** |스트림의 일부를 잘라냄|
|Stream\<T\> **skip(long n)** |스트림의 일부를 건너뜀|
|Stream\<T\> **peek(Consumer\<T\> action)** |스트림의 요소에 작업 수행|
|Stream\<T\> **sorted()** <br> Stream\<T\> **sorted(Comparator\<T\> comparator)** | 스트림의 요소를 정렬 |
|Stream\<R\> **map(Function\<T,R\> mapper)** <br> DoubleStream **mapToDouble(ToDoubleFunction\<T\> mapper)** <br> IntStream **mapToInt(ToIntFunction\<T\> mapper)** <br> LongStream **mapToLong(ToLongFunction\<T\> mapper)** <br> <br> Stream\<R\> **flatMap(Function\<T, Stream\<R\>\> mapper)** <br> DoubleStream **flatMapToDouble(Function\<T,DoubleStream\> m)** <br> IntStream **flatMapToInt(Function\<T,IntStream\> m)** <br> LongStream **flatMapToLong(Function\<T,LongStream\> m)** | 스트림의 요소를 반환|

<br>

|최종연산|설명|
|--:|--:|
|void **forEach(Consumer\<? super T\> action)** <br> void **forEachOrdered(Consumer\<? super T\> action)** | 각 요소에 지정된 작업 수행|
|long **count()**|스트림의 요소의 개수 반환|
Optional\<T\> **max(Comparator\<? super T\> c)** <br> Optional\<T\> **min(Comparator\<? super T\> c)** | 스트림의 최대값/최소값 반환|
|Optional\<T\> **findAny()** <br> Optional\<T\> **findFirst()**|스트림의 요소 하나 반환|
|boolean **allMatch(Predicate\<T\> p)** <br> boolean **anyMatch(Predicate\<T\> p)** <br> boolean **noneMatch(Predicate\<T\> p)** | 주어진 조건을 만족하는지 |
|Object[] **toArray()** <br> A[] **toArray(IntFunction<A[]> generator)**|스트림의 모든 요소를 배열로 반환|
|Optional\<T\> **reduce(BunaryOperator\<T\> a)** <br> T **reduce(T identity, BunaryOperator\<T\> a)** <br> U **reduce(I identity, BunaryOperator\<U,T,U\> a, <br>BunaryOperator\<T\> combiner)**| 스트림의 요소를 하나씩 줄여가면서 계산|
|R **collect(Collector\<T,A,R\> collector)** <br> R **collect(Supplier\<R\> s, BiConsumer\<R,T\> a, <br> BiConsumer\<R,R\> c)**|스트림의 요소를 수집|

중간연산은 `map()`과 `flatMap()`, 최종연산은 `reduce()`와 `collect()`가 핵심이다. 나머지 메소드는 이해하기도 쉽고 사용법도 간단하다.

#### 지연된 연산
스트림 연산에서 중간 연산은 최종 연산이 수행되기 전까지 수행되지 않는다. 스트림에 대해 `distinct()`나 `sort()`같은 중간 연산을 호출해도 즉각적인 연산이 수행되지 않고, 최종 연산이 수행되어야 비로소 스트림의 요소들이 중간 연산을 거쳐 최종 연산에서 소모된다. 

#### Stream<Integer>와 IntStream
요소의 타입이 `T`인 스트림은 기본적으로 `Stream<T>`이지만, 오토박싱&언박싱으로 인한 비효율을 줄이기 위해 데이터 소스의 요소를 기본형으로 다루는 스트림인 `IntStream`, `LongStream`, `DoubleStream`이 제공된다. 

일반적으로 `Stream<Integer>` 대신 `IntStream`을 사용하는 것이 더 효율적이고, `int`타입의 값으로 작업하는데 유용한 메소드들이 포함되어 있다.

#### 병렬 스트림
스트림으로 데이터를 다룰 떄의 장점 중 하나로 병렬 처리가 쉽다는 것도 있는데, 그저 스트림에 `parallel()`이라는 메소드를 호출해서 병렬로 연산을 수행하도록 지시하면 끝이다. 

반대로 병렬로 처리되지 않게 하려면 `sequencial()`을 호출하면 되는데, 모든 스트림은 기본적으로 병렬 스트림이 아니므로 `parallel()`을 취소할 때만 사용하면 된다. 

```java
int sum = stream1.parallel()
                .mapToInt(s -> s.length())
                .sum();
```
> 병렬처리가 항상 더 빠른 결과를 얻게 해주는 것은 아니라는 점을 명심하자.

