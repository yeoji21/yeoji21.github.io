---
title: "[JAVA] 스트림 (Stream)"
author: "yeoji21"
date: '2021-09-04 00:00:00 +0900'
categories: [Backend, Java]
tags: [java, 자바]
---

## 목차
- 스트림이란?
- 스트림 만들기
- 스트림의 중간 연산

### **스트림이란?**
지금까지 우리는 많은 수의 데이터를 다룰 때, 컬렉션이나 배열에 데이터를 담은 뒤 원하는 결과를 얻기 위해 `for문`과 `Iterator`를 이용해서 코드를 작성했다. 그러나 이런 방식으로 작성된 코드는 너무 길고 알아보기 힘들뿐더러 코드의 재사용성도 떨어진다.  

또 다른 문제는 데이터 소스마다 다른 방식으로 다뤄야한다는 것인데, `Collection`이나 `Iterator`와 같은 인터페이스를 이용해서 컬렉션을 다루는 방식을 표준화하기는 했지만

각 컬렉션 클래스에는 같은 기능의 메소드들이 중복해서 정의되어 있다. 예를 들어 `List`를 정렬할 때는 `Collections.sort()`를 사용해야하고, 배열을 정렬할 때는 `Arrays.sort()`를 사용해야 한다. 

이러한 문제점들을 해결하기 위해서 만든 것이 `스트림(stream)`이다. 스트림은 데이터 소스를 추상화하고, 데이터를 다루는데 자주 사용되는 메소드들을 정의해 놓았다. 따라서 데이터 소스가 무엇이던 간에 같은 방식으로 다룰 수 있게 되었고 코드의 재사용성이 향상되었다.

스트림을 사용하면, 배열이나 컬렉션뿐만 아니라 파일에 저장된 데이터도 모두 같은 방식으로 다룰 수 있다. 

예를 들어, 같은 내용을 저장하는 문자열 배열과 `List`가 있을 때,
```java
String[] arr = {"aaa", "ddd", "ccc"};
List<String> list = Arrays.asList(arr);
```

이 두가지 데이터 소스를 기반으로 하는 스트림의 생성 방법은 아래와 같다. 
```java
Stream<String> stream1 = list.stream();
Stream<String> stream2 = Arrays.stream(arr);
```

두 가지 스트림으로 데이터 소스의 데이터를 읽어서 정렬하고 화면에 출력하는 방법은 다음과 같다. 데이터 소스가 정렬되는 것은 아니라는 점에 유의하자
```java
stream1.sorted().forEach(System.out::println);
stream2.sorted().forEach(System.out::println);
```
이 두 스트림의 데이터 소스는 서로 다르지만, 정렬하고 출력하는 방법은 완전히 동일한 것을 알 수 있다. 

#### 스트림은 데이터 소스를 변경하지 않는다.
스트림은 데이터 소스로부터 데이터를 읽기만할 뿐, 데이터 소스를 변경하지 않는다는 차이가 있다. 필요하다면, 변경된 결과를 컬렉션이나 배열에 담아서 반환할 수도 있다. 

```java
List<String> sortedList = stream1.sorted().collect(Collectors.toList());
```

#### 스트림은 일회용이다. 
스트림은 `Iterator`처럼 일회용이다. 따라서 컬렉션의 요소를 모두 읽고 나면 다시 사용할 수 없기때문에 필요하다면 스트림을 다시 생성해야 한다. 
```java
stream1.sorted().forEach(System.out::println);
long count = stream1.count();
System.out.println(count);
```
```console
Exception in thread "main" java.lang.IllegalStateException: stream has already been operated upon or closed
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)
	at java.base/java.util.stream.ReferencePipeline.count(ReferencePipeline.java:605)
	at com.example.javastudy.week15.StreamEx.main(StreamEx.java:17)
```

#### 스트림은 작업을 내부 반복으로 처리한다. 
스트림은 반복문을 메소드의 내부에 숨기는 **내부 반복**을 사용하기 때문에 간결한 작업이 가능한 것이다. `forEach()`는 매개변수에 대입된 람다식을 데이터 소스의 모든 요소에 적용한다. 

즉, `forEach()`는 메소드 안으로 `for문`을 넣은 것이다. 수행할 작업은 매개변수로 받는다. 

```java
void forEach(Consumer<? super T> action){
    Objects.requireNonNull(action); //매개변수 null 체크

    for(T t : src){                 //내부반복
        action.accept(T);
    }
}
```

#### 스트림의 연산
스트림이 제공하는 연산은 `중간 연산`과 `최종 연산`으로 분류할 수 있는데, 중간 연산은 연산 결과를 스트림으로 반환하기 때문에 중간 연산을 연속해서 연결할 수 있다. 반면에 최종 연산은 스트림의 요소를 소모하면서 연산을 수행하므로 단 한번만 연산이 가능하다. 

|중간연산|설명|
|--:|--:|
|Stream\<T\> **distinct()** |중복을 제거|
|Stream\<T\> **filter(Predicate\<T\> predicate)** |조건에 안맞는 요소 제외|
|Stream\<T\> **limit(long maxSize)** |스트림의 일부를 잘라냄|
|Stream\<T\> **skip(long n)** |스트림의 일부를 건너뜀|
|Stream\<T\> **peek(Consumer\<T\> action)** |스트림의 요소에 작업 수행|
|Stream\<T\> **sorted()** <br> Stream\<T\> **sorted(Comparator\<T\> comparator)** | 스트림의 요소를 정렬 |
|Stream\<R\> **map(Function\<T,R\> mapper)** <br> DoubleStream **mapToDouble(ToDoubleFunction\<T\> mapper)** <br> IntStream **mapToInt(ToIntFunction\<T\> mapper)** <br> LongStream **mapToLong(ToLongFunction\<T\> mapper)** <br> <br> Stream\<R\> **flatMap(Function\<T, Stream\<R\>\> mapper)** <br> DoubleStream **flatMapToDouble(Function\<T,DoubleStream\> m)** <br> IntStream **flatMapToInt(Function\<T,IntStream\> m)** <br> LongStream **flatMapToLong(Function\<T,LongStream\> m)** | 스트림의 요소를 반환|

<br>

|최종연산|설명|
|--:|--:|
|void **forEach(Consumer\<? super T\> action)** <br> void **forEachOrdered(Consumer\<? super T\> action)** | 각 요소에 지정된 작업 수행|
|long **count()**|스트림의 요소의 개수 반환|
Optional\<T\> **max(Comparator\<? super T\> c)** <br> Optional\<T\> **min(Comparator\<? super T\> c)** | 스트림의 최대값/최소값 반환|
|Optional\<T\> **findAny()** <br> Optional\<T\> **findFirst()**|스트림의 요소 하나 반환|
|boolean **allMatch(Predicate\<T\> p)** <br> boolean **anyMatch(Predicate\<T\> p)** <br> boolean **noneMatch(Predicate\<T\> p)** | 주어진 조건을 만족하는지 |
|Object[] **toArray()** <br> A[] **toArray(IntFunction<A[]> generator)**|스트림의 모든 요소를 배열로 반환|
|Optional\<T\> **reduce(BunaryOperator\<T\> a)** <br> T **reduce(T identity, BunaryOperator\<T\> a)** <br> U **reduce(I identity, BunaryOperator\<U,T,U\> a, <br>BunaryOperator\<T\> combiner)**| 스트림의 요소를 하나씩 줄여가면서 계산|
|R **collect(Collector\<T,A,R\> collector)** <br> R **collect(Supplier\<R\> s, BiConsumer\<R,T\> a, <br> BiConsumer\<R,R\> c)**|스트림의 요소를 수집|

앞으로 이 메소드들을 하나씩 설명할텐데, 중간연산은 `map()`과 `flatMap()`, 최종연산은 `reduce()`와 `collect()`가 핵심이다. 나머지 메소드는 이해하기도 쉽고 사용법도 간단하다.

#### 지연된 연산
스트림 연산에서 중간 연산은 최종 연산이 수행되기 전까지 수행되지 않는다. 스트림에 대해 `distinct()`나 `sort()`같은 중간 연산을 호출해도 즉각적인 연산이 수행되지 않고, 최종 연산이 수행되어야 비로소 스트림의 요소들이 중간 연산을 거쳐 최종 연산에서 소모된다. 

#### Stream<Integer>와 IntStream
요소의 타입이 `T`인 스트림은 기본적으로 `Stream<T>`이지만, 오토박싱&언박싱으로 인한 비효율을 줄이기 위해 데이터 소스의 요소를 기본형으로 다루는 스트림인 `IntStream`, `LongStream`, `DoubleStream`이 제공된다. 

일반적으로 `Stream<Integer>` 대신 `IntStream`을 사용하는 것이 더 효율적이고, `int`타입의 값으로 작업하는데 유용한 메소드들이 포함되어 있다.

#### 병렬 스트림
스트림으로 데이터를 다룰 떄의 장점 중 하나로 병렬 처리가 쉽다는 것도 있는데, 그저 스트림에 `parallel()`이라는 메소드를 호출해서 병렬로 연산을 수행하도록 지시하면 끝이다. 

반대로 병렬로 처리되지 않게 하려면 `sequencial()`을 호출하면 되는데, 모든 스트림은 기본적으로 병렬 스트림이 아니므로 `parallel()`을 취소할 때만 사용하면 된다. 

```java
int sum = stream1.parallel()
                .mapToInt(s -> s.length())
                .sum();
```
> 병렬처리가 항상 더 빠른 결과를 얻게 해주는 것은 아니라는 점을 명심하자.

### **스트림 만들기**
스트림의 소스가 될 수 있는 대상은 배열, 컬렉션, 임의의 수 등으로 다양하며, 다양한 소스들로부터 스트림을 생성하는 방법을 하나씩 알아보자. 

#### 컬렉션
컬렉션의 최고 조상인 `Collection`에 `stream()`이 정의되어 있다. 그래서 `Collection`을 구현한 자식 클래스인 `List`와 `Set`을 구현한 클래스들은 모두 이 메소드를 통해 스트림을 생성할 수 있다. `stream()`은 해당 컬렉션을 소스(source)로 하는 스트림을 반환한다. 

```java
Stream<T> Collection.stream()
```

#### 배열
배열을 소스로하는 스트림을 생성하는 메소드는 Stream과 Arrays에 static 메소드로 정의되어 있다. 

```java
Stream<T> Stream.of(T...values)
Stream<T> Stream.of(T[])

Stream<T> Arrays.stream(T[])
Stream<T> Arrays.stream(T[] array, int startInclusive, int endExclusive)
```

예를 들어 문자열 스트림은 다음과 같이 생성한다. 

```java
Stream<String> stream1 = Stream.of("a", "b", "c");
Stream<String> stream2 = Stream.of(new String[]{"a", "b", "c"});
Stream<String> stream3 = Arrays.stream(new String[]{"a", "b", "c"});
Stream<String> stream4 = Arrays.stream(new String[]{"a", "b", "c"}, 0, 3);
```
그리고 `int`, `long`, `double`과 같은 기본형 배열을 소스로 하는 스트림을 생성하는 메소드도 있다.

```java
IntStream IntStream.of(int... values)
IntStream IntStream.of(int[])
IntStream Arrays.stream(int[])
IntStream Arrays.stream(int[] array, int startInclusive, int endExclusive)
```
이 외에도 `long`과 `double`타입의 배열로부터 `LongStream`과 `DoubleStream`을 생성하는 메소드도 있으나 쉽게 유추할 수 있으므로 생략한다. 

#### 특정 범위의 정수
`IntStream`과 `LongStream`은 지정된 범위의 연속된 정수를 스트림으로 생성해서 반환하는 `range()`와 `rangeClosed()`를 가지고 있다. 

```java
IntStream IntStream.range(int begin, int end)
IntStream IntStream.rangeClosed(int begin, int end)
```

`range()`의 경우, 경계의 끝인 `end`가 포함되지 않고 `rangeClosed()`의 경우에는 포함된다. 

```java
IntStream stream1 = IntStream.range(1, 5);
IntStream stream2 = IntStream.rangeClosed(1, 5);
stream1.forEach((s)-> System.out.print(s+" "));
System.out.println();
stream2.forEach((s)-> System.out.print(s+" "));
```
```console
1 2 3 4 
1 2 3 4 5 
```

#### 임의의 수
난수를 생성하는데 사용하는 `Random`클래스에는 아래와 같은 인스턴스 메소드들이 포함되어 있다. 이 메소드들은 해당 타입의 난수들로 이루어진 스트림을 반환한다. 
```java
IntStream ints()
LongStream longs()
DoubleStream doubles()
```
이 메소드들이 반환하는 스트림은 크기가 정해지지 않은 `무한 스트림(infinite stream)`이기 때문에 `limit()`도 같이 사용해서 스트림의 크기를 제한해주어야 한다. 
```java
IntStream intStream = new Random().ints();
intStream.limit(5).forEach(System.out::println);
```
혹은 매개변수로 스트림의 크기를 전당해서 유한 스트림을 반환받을 수도 있다.
```java
IntStream ints(long streamSize)
LongStream longs(long streamSize)
DoubleStream doubles(long streamSize)
...
IntStream intStream = new Random().ints(5);
```
단, 위의 메소드들로 생성된 스트림의 난수는 아래의 범위를 갖는다. 
```java
                Integer.MIN_VALUE <= ints() <= Integer.MAX_VALUE
                   Long.MIN_VALUE <= longs() <= Long.MAX_VALUE
                              0.0 <= doubles() < 1.0
```

지정된 범위의 난수를 발생시키는 스트림을 얻는 메소드는 아래와 같다. 단, end는 범위에 포함되지 않는다. 
```java
IntStream ints(int begin, int end)
LongStream longs(long begin, long end)
DoubleStream doubles(double begin, double end)

IntStream ints(long streamSize, int begin, int end)
LongStream longs(long streamSize, long begin, long end)
DoubleStream doubles(long streamSize, double begin, double end)
```

#### 람다식 - iterate(), generate()
`Stream`클래스의 `iterate()`와 `generate()`는 람다식을 매개변수로 받아서 이 람다식에 의해 계산되는 값들을 요소로 하는 무한 스트림을 생성한다. 
```java
static <T> Stream<T> iterate(T seed, UnaryOperator<T> f)
static <T> Stream<T> generate(Supplier<T> s)
```

`iterate()`는 seed값으로 지정된 값부터 시작해서 람다식 f에 의해 계산된 결과를 다시 seed값으로 해서 계산을 반복한다. 아래의 스트림은 0부터 시작해서 값이 2씩 계속 증가하는 무한 스트림이다.

```java
Stream<Integer> evenStream = Stream.iterate(0, n -> n+2);
```
<br>

`generate()`도 람다식에 의해 계산되는 값을 요소로 하는 무한 스트림을 생성해서 반환하지만, `iterate()`와 달리 이전 결과를 이용해서 다음 요소를 계산하지는 않고, `generate()`에 정의된 매개변수의 타입은 `Supplier<T>`이므로 매개변수가 없는 람다식만 허용된다.

```java
Stream<Double> stream = Stream.generate(Math::random);
Stream<Integer> generate = Stream.generate(() -> 1);
```
그리고 `generate()`에 정의된 매개변수의 타입은 `Supplier<T>`이므로 매개변수가 없는 람다식만 허용된다. 또한, `iterate()`와 `generate()`로 생성된 스트림을 `IntStream` 같은 기본향 스트림 타입의 참조변수로 다룰 수 없으므로 주의해야 한다. 
> 굳이 필요하다면 mapToInt()와 같은 메소드로 변환해야 한다.

#### 파일
`java.nio.file.Files`는 파일을 다루는데 필요한 메소드들을 제공하는데, `list()`는 지정된 디렉토리에 있는 파일의 목록을 소스로 하는 스트림을 생성해서 반환한다. 
```java
Stream<Path> Files.list(Path dir)
```
이 외에도 `Files`클래스에 `Path`를 요소로 하는 스트림을 생성하는 메소드가 더 있으니 관심있다면 추가로 찾아보길 바란다. 

파일의 `line`을 요소로 하는 스트림을 생성하는 메소드도 있는데, `BufferedReader` 클래스에 속한 `lines()`를 사용하면 된다. 이 메소드는 파일 뿐만 아니라 다른 입력대상으로부터도 데이터를 행 단위로 읽어올 수 있다.

#### 빈 스트림
요소가 하나도 없는 빈 스트림을 생성할 수도 있다 스트림에 연산을 수행한 결과가 하나도 없을 때, null을 반환하는 것보다 빈 스트림을 반환하는 것이 낫다. 
```java
Stream emptyStream = Stream.empty();
```

#### 두 스트림의 연결
`Stream`의 `static`메소드인 `concat()`을 사용하면 두 스트림을 하나로 연결할 수 있다. 단, 이 때 두 스트림의 요소는 같은 타입이어야 한다.

### **스트림의 중간 연산**

#### 스트림 자르기 - skip(), limit()
`skip(n)`은 처음 n개의 요소를 건너뛰고, `limit(n)`은 스트림의 요소를 n개로 제한한다.

#### 스트림의 요소 걸러내기 - filter(), distinct()
`distinct()`는 스트림에서 중복된 요소들을 제거하고, `filter()`는 주어진 조건(Predicate)에 맞지 않는 요소를 걸러낸다. 
```java
stream1.distinct().forEach(System.out::println);
```

`filter()`는 매개변수로 `Predicate`를 필요호 하는데, 아래와 같이 연산 결과가 `boolean`인 람다식을 사용해도 된다.

```java
IntStream intStream = IntStream.rangeClosed(1, 10);
intStream.filter(i -> i%2 == 0).forEach(System.out::println);
```

#### 정렬 - sorted()
`sorted()`는 지정된 `Comparator`로 스트림을 정렬하는데, `Comparator`대신 int값을 반환하는 람다식을 사용하는 것도 가능하다. `Comparator`를 지정하지 않으면 스트림 요소의 기본 정렬 기준인 `Comparable`으로 정렬한다. 
> 이 때 스트림의 요소가 Comparable을 구현한 클래스가 아니면 예외가 발생한다.

```java
Stream<T> sorted()
Stream<T> sorted(Comparator<T> comparator)
```

`JDK 1.8`부터 `Comparator`인터페이스에 `static`메소드와 `default`메소드가 많이 추가되었는데, 이 메소드들을 이용하면 정렬이 쉬워진다. 이 메소드들은 모두 `Comparator<T>`를 반환하며, 아래의 메소드 목록은 제네릭에서 와일드 카드부분을 제거하여 간략화한 것이므로, 정확한 메소드 선언이 궁금하면 Java API 문서를 참조하자.

**Comparator의 default methods**

```java
reversed()
thenComparing(Comparator<? super T> other)
thenComparing(Function<? super T, ? extends U> keyExtractor)
thenComparing(Function<? super T, ? extends U> keyExtractor,
                                    Comparator<? super U> keyComparator)
thenComparingInt(ToIntFunction<? super T> keyExtractor)
thenComparingLong(ToLongFunction<? super T> keyExtractor)
thenComparingDouble(ToDoubleFunction<? super T> keyExtractor)
```

**Comparator의 static methods**

```java
reverseOrder()
naturalOrder()
comparing(Function<? super T, ? extends U> keyExtractor)
comparing(Function<? super T, ? extends U> keyExtractor,
                                Comparator<? super U> keyComparator)
comparingInt(ToIntFunction<? super T> keyExtractor)
comparingLong(ToLongFunction<? super T> keyExtractor)
comparingDouble(ToDoubleFunction<? super T> keyExtractor)
nullsFirst(Comparator<? super T> comparator)
nullsLast(Comparator<? super T> comparator)
```

정렬에 사용되는 메소드의 개수가 많지만, 가장 기본적인 메소드는 `comparing()`이다. 스트림의 요소가 `Comparable`을 구현한 경우, 매개변수 하나짜리를 사용하면 되고, 그렇지 않은 경우, 추가적인 매개변수로 정렬기준(Comparator)를 지정해주어야 한다.

만약 비교대상이 기본형인 경우, `comparing()`대신 `comparingInt()`등을 사용하면 오토박싱과 언박싱과정이 없어서 더 효율적이다. 

그리고 정렬 조건을 추가할 때는 `thenComparing()`을 사용한다.

예를 들어, 학생 스트림을 반별, 성적순, 이름순으로 정렬하여 출력하려면 다음과 같이 한다. 

```java
studentStream.sorted(Comparator.comparing(Strudent::getBan)
                                .thenComparing(Student::getTotalScore)
                                .thenComparing(Student::getName))
                                .forEach(System.out::println);
```

이해를 돕기 위해 학생의 성적을 반별 오름차순, 총점별 내림차순으로 정렬하여 출력하는 예제를 살펴보자.

```java
public class StreamEx {
    public static void main(String[] args) {
        Stream<Student> studentStream = Stream.of(
                new Student("여자바", 3, 300),
                new Student("김자바", 1, 200),
                new Student("안자바", 2, 100),
                new Student("박자바", 2, 150),
                new Student("소자바", 1, 200),
                new Student("이자바", 3, 290),
                new Student("김자바", 3, 180)
        );

        studentStream.sorted(Comparator.comparing(Student::getBan)
                                        .thenComparing(Comparator.naturalOrder()))
                .forEach(System.out::println);

    }
}

@Getter
class Student implements Comparable{
    String name;
    int ban;
    int totalScore;

    public Student(String name, int ban, int totalScore) {
        this.name = name;
        this.ban = ban;
        this.totalScore = totalScore;
    }

    @Override
    public String toString() {
        return String.format("[%s %d, %d]",name, ban, totalScore);
    }

    @Override
    public int compareTo(Object o) {
        return ((Student)o).totalScore - this.totalScore;
    }
}
```

```console
[김자바 1, 200]
[소자바 1, 200]
[박자바 2, 150]
[안자바 2, 100]
[여자바 3, 300]
[이자바 3, 290]
[김자바 3, 180]
```