---
title: "백기선님과 함께 하는 자바 스터디 - 12"
author: "yeoji21"
date: 2021-08-25
categories: [Backend, Java]
tags: [java, java study, 자바, 자바 스터디]
pin: true
---

<img src="https://media.vlpt.us/images/inhalin/post/b48b4cd3-619b-4bf4-939c-d3546dd2ec01/whiteship.png">

## 들어가면서
백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다.  
강의 영상 링크 : [[자바 라이브 스터디] 2021/2/6, 12주차 Annotation
](https://www.youtube.com/watch?v=A_zgihtbG3M)  
강의 깃허브 링크 : [12주차 과제: 애노테이션](https://github.com/whiteship/live-study/issues/12)

## 목차
- 애너테이션 정의하는 방법
- @Retention
- @Target
- @Documented
- 애너테이션 프로세서


### 애너테이션이란?
프로그램 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것이 바로 애너테이션이다. 

애너테이션은 **주석**처럼 프로그래밍 언어에 영향을 미치지 않으면서도 다른 프로그램에게 유용한 정보를 제공할 수 있다는 장점이 있다.
> annotation의 뜻은 주석, 주해, 메모이다.

예를 들어, 테스트 코드를 작성할 때 `@Test` 애너테이션을 메소드 앞에 붙이는데 @Test는 이 메소드를 테스트해야한다는 것을 JUnit에게 알리는 역할을 할 뿐, 
메소드가 포함된 프로그램 자체에는 아무런 영향을 미치지 않는다. 

따라서 애너테이션은 코드에 넣는 주석과 비슷한 류의 장치이므로 실행되는 코드라고 생각해서는 안된다. 마치 애너테이션 자체적으로 기능을 가지고 있는 것처럼 보일 수 있으나, 애너테이션은 그저 표시, 마킹을 위한 주석이다.  

따라서 애너테이션의 인자로 런타임 중에 알아낼 수 있는 동적인 값은 사용할 수 없고 컴파일러 수준에서 해석이 되는 값이거나 완전히 정적인 값이어야 한다. 

#### 애너테이션이 나온 이유
기존의 자바 웹애플리케이션은 구성과 설정값을 XML 파일을 통해 명시하고 관리했다. 이 방식은 변경될 수 있는 데이터들을 외부 파일로 분리함으로써 컴파일 없이 변경사항을 적용하기 위함이었다.  

그러나 이런 방법은 프로그램 작성 시 마다 많은 설정을 작성해야 하는 불편함을 낳게 되었다. 웹 애플리케이션이 커질 수록 이 문제는 더욱 극대화되었고, 이를 해결하기 위해 나온 것이 애너테이션이다.  

애너테이션을 사용할 경우, 데이터에 대한 유효성 검사 조건을 보다 쉽게 파악할 수 있고, 코드가 깔끔해진다. 또한 어노테이션을 통한 리플렉션을 사용해 원하는 클래스를 주입하는 것도 가능해진다는 장점을 가진다. 

#### 애너테이션의 종류
애너테이션은 **JDK에서 기본적으로 제공하는 것**과 **다른 프로그램에서 제공하는 것**들이 있는데, 어느 것이든 그저 약속된 형식으로 정보를 제공하기만 하면 된다. 

JDK에서 제공하는 `표준 애너테이션`은 주로 컴파일러를 위한 것으로 컴파일러에게 유용한 정보를 제공한다. 그리고 새로운 애너테이션을 정의할 때 사용하는 `메타 애너테이션`을 제공한다.
> JDK에서 제공하는 애너테이션은 java.lang.annotation 패키지에 포함되어 있다. 

### 표준 애너테이션   
자바에서 기본적으로 제공하는 애너테이션은 몇 개 없다. 그나마도 애너테이션을 정의하는데 사용하는 메타 애너테이션(meta annotation)이다. 

|애너테이션|설명|
|--:|--:|
|@Override|컴파일러에게 오버라이딩 메소드임을 알린다|
|@Deprecated|앞으로 사용하지 않을 것을 권장하는 대상에 붙인다|
|@SuppressWarnings|컴파일러의 특정 경고메시지가 나타나지 않게 해준다|
|@SafeVarargs|지네릭스 타입의 가변인자에 사용한다 (JDK 1.7)|
|@FunctionalInterface|함수형 인터페이스임을 알린다(JDK 1.8)|
|@Native|native메소드에 참조되는 상수 앞에 붙인다(JDK 1.8)|
|@Target *|애너테이션이 적용가능한 대상을 지정하는데 사용한다|
|@Documented *|애너테이션 정보가 javadoc으로 작성된 문서에 포함되게 한다|
|@Inherited *|애너테이션이 자손 클래스에 상속되도록 한다|
|@Retention *|애너테이션이 유지되는 범위를 지정하는데 사용한다|
|@Repreatable *|애너테이션을 반복해서 적용할 수 있게 한다(JDK 1.8)|

> *가 붙은 것은 메타 애너테이션

#### 메타 에너테이션
앞서 설명한 것과 같이 메타 애너테이션은 '애너테이션을 위한 애너테이션' 즉, 애너테이션을 정의할 때 애너테이션의 **적용대상(target)** 이나 **유지기간(retention)** 등을 지정하는데 사용된다.  

메타 애너테이션에 대해 조금 더 자세히 알아보자.  

### @Target  
애너테이션이 적용가능한 대상을 지정하는데 사용된다. 아래는 `@SuppressWarnings`를 정의한 것인데, 이 애너테이션에 적용할 수 있는 대상을 `@Target`으로 지정하고 있다.  

애너테이션의 인자로 여러 개의 값을 지정할 때는 배열에서처럼 괄호{}를 사용한다.
```java
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
```

Target으로 지정할 수 있는 애너테이션 적용대상의 종류는 아래와 같다.

|대상 타입|의미|
|--:|--:|
|ANNOTATION_TYPE|애너테이션|
|CONSTRUCTOR|생성자|
|FIELD|필드(멤버변수, enum 상수)|
|LOCAL_VARIABLE|지역변수|
|METHOD|메소드|
|PACKAGE|패키지|
|PARAMETER|매개변수|
|TYPE|타입(클래스, 인터페이스, enum)|
|TYPE_PARAMETER|타입 매개변수 (JDK 1.8)|
|TYPE_USE|타입이 사용되는 모든 곳(JDK 1.8)|

`TYPE`은 타입을 선언할 때 애너테이션을 붙일 수 있다는 뜻이고, `TYPE_USE`는 해당 타입의 변수를 선언할 때 붙일 수 있다는 뜻이다. 또한 `FILED`는 기본형에, `TYPE_USE`는 참조형에 사용된다는 점에 주의하자

```java
@Target({FIELD, TYPE, TYPE_USE})
@interface MyAnnotation{ }

@MyAnnotation       //TYPE
public class AnnotationTest {
    @MyAnnotation   //FIELD
    int a;
    
    @MyAnnotation   //TYPE_USE
    AnnotationTest at;
}
```

표의 값들은 `java.lang.annotation.ElementType`이라는 열거형에 정의되어 있으며, static import하면 ElementType.TYPE을 TYPE과 같이 간단히 할 수 있다. 

### @Retention
애너테이션이 유지되는 기간을 지정하는데 사용된다. 애너테이션의 유지 정책(retention policy)의 종류는 다음과 같다.

|유지정책|의미|
|--:|--:|
|SOURCE|소스파일에만 존재. 클래스파일에는 존재하지 않음|
|CLASS|클래스 파일에 존재. 실행시에 사용불가. 기본값|
|RUNTIME|클래스 파일에 존재. 실행시에 사용가능|

`SOURCE`는 말 그대로 소스에만 남아 있고 컴파일한 바이트코드에는 남지 않는다. 따라서 정말 주석과 같은 용도로 사용하거나 컴파일 타임에만 쓰이는 에너테이션이다.

예를 들어, `@Override`나 `@SuppressWarnings`처럼 컴파일러가 사용하는 애너테이션은 유지 정책이 SOURCE이다.

`CLASS`는 컴파일러가 애너테이션의 정보를 클래스 파일에는 저장할 수 있게 하지만, 런타임시에 JVM의 클래스 로더가 클래스의 정보를 읽어서 메모리에 로드하는 과정에서 CLASS 에너테이션의 정보는 누락시킨다.

유지정책을 `RUNTIME`으로 하면, 실행 시에 `리플렉션(reflection)`을 통해 클래스 파일에 저장된 애너테이션의 정보를 읽어서 처리할 수 있다.

### @Documented
애너테이션에 대한 정보가 javadoc으로 작성한 문서에 포함되도록 한다. 

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface FunctionalInterface{}
```

#### JavaDoc
JavaDoc은 Java 코드에서 API 문서를 HTML 형식으로 생성해주는 도구이다. 코드를 작성하다 보면 유지보수, 배포 등 다양한 상황으로 인해 코드의 문서 작성이 필요한 경우가 있다. 

하지만 작성한 코드의 클래스, 필드, 메서드에 대해 개발이 완료된 후 일일이 작성하는 것은 번거로울 뿐더러, 코드의 규모가 크다면 더 복잡한 일이 되는데, 이를 지원하기 위해서 자바에서는 Javadoc을 사용할 수 있다.

문서화할 클래스, 필드, 메서드, 어노테이터, 인터페이스 등에 주석 및 애너테이션으로 문서를 작성하고, HTML등 다양한 포맷으로 export 하는 기능을 제공한다.

```java
/**
 * 원격 서버와 HTTP 통신 기능을 제공하는 구현체입니다.
 *
 * @author live2skull
 * @since 1.1
 */
public class JavaDocTest {
    // 코드 구현 ...
}
```
javadoc은  `/** */` 로 작성하면 된다.
IntelliJ의 경우, 이미 작성 완료되어 있는 클래스나 메소드 위에 `/**` 를 입력하고 Enter를 누르면 알아서 필요한 param, return 등의 태그를 생성해준다.

자주 쓰이는 태그들은 아래와 같다. 

|태그|설명|
|--:|--:|
|@version|패키지 등 구현제 버전|
|@author|코드 작성자|
|@deprecated|해당 구현체의 삭제, 지원 중단을 예고함|
|@since|해당 구현체가 추가된 버전|
|@see|문서가 참조할 다른 클래스 / 메서드 / 외부 링크|
|@link|@see 와 동일|
|@exception| throw 할 수 있는 예외 |
|@throws|@exception 과 동일|
|@param|메서드, 생성자 인자값 설명|
|@return|반환값 설명|

**HTML문서 생성하기**  
> [이 블로그](https://creampuffy.tistory.com/81)를 참조하였습니다. 

IntelliJ 기준으로
Double Shift -> generate JavaDoc -> 옵션 선택 -> Ok 로 간단히 생성할 수 있다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FVz8tN%2FbtqR9l7let3%2FmaFaPuv3G6zNDXgLXJPnr1%2Fimg.png">

세부 옵션을 보자면 어떤 클래스들을 JavaDoc에 포함시킬지가 첫 번째이다.
Custom scope를 생성해서 포함할 파일을 Include하고 제외할 것을 Exclude한다.

파일이 저장될 경로를 설정하고, 접근제한자를 어디까지 포함시킬지 선택한다. 그 다음은 취향대로 하되, 중요한건 다음 내용을 Other command line arguments 에 추가해야 한다.

```console
-encoding UTF-8 -charset UTF-8 -docencoding UTF-8
```
그러지 않으면 인코딩 에러가 발생한다. OK 누르면 생성이 되면서 생성한 파일을 연다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fn9DoH%2FbtqSsR4jEkj%2FN9pHzI9CkH3K4oA5e4hkq0%2Fimg.png">

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FFcqZh%2FbtqSxCTkIFV%2FJ4rzVrJkulgTDjtiIU1jsk%2Fimg.png">