---
title: "백기선님과 함께 하는 자바 스터디  - 03 - 1부"
author: "yeoji21"
date: 2021-08-11
categories: [Backend, Java]
tags: [java, java study, 자바, 자바 스터디]
# pin: true
---

<img src="https://media.vlpt.us/images/inhalin/post/b48b4cd3-619b-4bf4-939c-d3546dd2ec01/whiteship.png">

## 들어가면서
백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다.  
강의 영상 링크 : [[자바 라이브 스터디] 2020/11/28, 자바 스터디 3주차 연산자를 알아보자.](https://www.youtube.com/watch?v=OFf-PX81-Lc&list=PLfI752FpVCS96fSsQe2E3HzYTgdmbz6LU&index=5)  
강의 깃허브 링크 : [3주차 과제: 연산자 ](https://github.com/whiteship/live-study/issues/3)

## 목차
- 산술 연산자
- 비트 연산자
- 관계 연산자
- 논리 연산자   
- instanceof
- assignment(=) operator
- 화살표(->) 연산자
- 3항 연산자
- 연산자 우선 순위
- (optional) Java 13. switch 연산자

>이번 챕터가 내용이 많아서 이 포스트는 논리 연산자까지 

### **연산자란?**

연산자(Operator)는 연산을 수행하는 기호를 말한다. 연산자가 연산을 수행하기 위해서는 반드시 연산의 대상이 있어야 하는데, 이 것을 피연산자(Operand)라고 한다.  

대부분의 연산자는 두 개의 피연산자를 필요로 하며, 하나 또는 세 개의 피연산자를 필요로 하는 연산자도 있다. **연산자는 연산을 수행하고 나면 반드시 결과값을 반환한다.** 

#### 연산자의 종류

|종류|연산자|설명|
|--:|--:|--:|
산술 연산자| + - * / % << >> | 사칙 연산과 나머지 연산(%)|
비교 연산자| > < >= <= == != | 크고 작음과 같고 다름을 비교
논리 연산자| && \|\| ! & \| ^ ~| AND 또는 OR으로 조건을 연결
대입 연산자| = | 우변의 값을 좌변에 저장
기타 | (type) ?: instanceof | 형변환 연산자, 3항 연산자, instanceof 연산자| 


### **산술 연산자**
- 사칙 연산을 하는 연산자
- boolean 타입을 제외한 모든 기본타입에 사용 가능
- **피연산자들간의 타입이 일치하지 않을 경우, 피연산자들의 타입을 일치시킨 후 연산을 수행**
    1. 피연산자들이 모두 정수 타입이고, int 타입보다 크기가 작은 경우  
        -> 모두 int 타입으로 변환 후 연산 수행, 결과는 int 타입
    2. 피연산자들이 모두 정수 타입이고, long 타입이 있을 경우  
        -> 결과는 long 타입
    3. 피연산자 중 실수 타입이 있을 경우  
        -> 실수 타입으로 변환 후 연산 수행, 결과는 실수 타입

    예제 코드
    ```java
    byte a = 1;
    byte b = 1;
    byte c = a + b;         //컴파일 에러 발생
    ```
    ```console
    error: incompatible types: possible lossy conversion from int to byte 
        byte c = a + b;
                   ^
    ```
    위의 코드에서 에러가 발생하는 이유는 무엇일까?  
    1번 규칙을 보면 알 수 있는데, 변수 a 와 b는 int형 보다 작은 byte형이기 때문에 연산자 +는 두 개의 피연산자들의 자료형을 int형으로 변환한 다음 더하기 연산을 수행한다.  

    그 결과 `a+b`의 연산 결과는 4byte의 int형이 되고, 4byte의 값을 1byte의 byte형에 타입 캐스팅 없이 저장하려고 했기 때문에 에러가 발생한 것이다. 

    따라서 이 연산을 에러 없이 수행하기 위해서는 아래 두 가지 방식 중 하나로 수정해야 한다.
    ```java
    byte c = (byte)(a+b);       //명시적인 타입 캐스팅으로 해결
    int c = a + b;              //또는 int형 변수로 결과를 받음
    ```

    오케이, 그렇다면 자바에서는 long 타입을 제외한 정수형을 연산할 시 int형으로 변환한 뒤 연산을 수행한다는 것은 알게되었다.  

    그렇다면 굳이 왜 int로 변환한 뒤 계산하는 것일까? 바로 **JVM이 기본적으로 32bit 단위로 계산**을 하기 때문이다.  
    ```java
    int a = 10;
    int b = 4;
    int c = a / b;          //2
    double d = a / b;       //2.5가 아닌 2 
    //실수형 결과를 얻고 싶다면 피연산자 중 최소한 하나는 실수형이어야 한다. 
    ```

    <br>
    char 타입도 정수 타입이므로 산술 연산이 가능하다.(결과는 int형) 왜냐하면 문자는 실제로 해당 문자의 유니코드(부호없는 정수)로 바뀌어 저장되므로 문자간의 사칙 연산은 정수간의 연산과 동일하기 때문이다.  

    문자 '2'를 정수 2로 변환하려면 문자 '0'을 빼주면 되는데 그 이유는 문자 '2'의 유니코드가 50이고, 문자 '0'의 유니코드는 48이므로 뺄셈의 결과로 2를 얻을 수 있기 때문이다.  

    또한 대문자와 소문자 간의 코드 값의 차이는 32만큼 나기 때문에 이 것을 이용하면 소문자를 대문자로 변경하거나 반대의 경우에도 활용할 수 있다.  

    문자 타입의 연산 과정을 코드로 알아보자.  
    ```java
    char a = 'A';
    char b = a + 1; 
    System.out.println(b);
    ```
    ```console
    error: incompatible types: possible lossy conversion from int to char
        char b = a + 1; 
                   ^
    ```
    위 코드를 실행하면 컴파일 에러가 발생한다. char 타입은 정수 타입으로 취급되어 연산되기 때문에 연산의 결과 또한 int(4byte)인데, 결과를 char(2byte)에 담으려 해서 발생하는 오류이다.  

    따라서 int 타입의 결과로 char 타입을 반환받고 싶으면 타입 캐스팅을 해주어야 한다.

    그렇다면 위의 코드와 아주 비슷하게 생긴 아래 코드의 실행 결과를 살펴보자.
    ```java
    char a = 'A';
    char b = 'A'+1;
    System.out.println(a);
    System.out.println(b);
    ```
    ```console
    A
    B 
    ```
    이 코드에서는 타입 캐스팅을 해주지 않았는데 왜 컴파일 에러가 발생하지 않는 것일까?  
    그것은 바로 **`'A'+1 `이 리터럴 간의 연산이기 때문**이다.  

    상수 또는 리터럴 간의 연산은 실행과정동안 변하는 값이 아니기 때문에, 컴파일 시에 컴파일러가 결과값을 계산해서 그 결과로 대체함으로써 코드의 효율을 높이는 방식을 사용한다.  

    따라서 컴파일 후의 위 코드는 `char b = 'B';` 의 문장으로 변환되기 때문에 에러가 발생하지 않는 것이다.  

- 산술 연산에는 단항 연산자로써 **증감 연산자**가 있는데, ++ 또는 -\- 기호를 사용한다.  
    증감 연산자가 피연산자의 뒤에 붙는 후위 연산일 경우, 해당 라인을 수행하고 나서 증감 연산이 수행되고,  
    반대로 증감 연산자가 피연산자의 앞에 붙는 전위 연산의 경우, 해당 라인을 수행할 때 바로 증감 연산이 수행된다.  


- 산술 연산에서의 주의점
  1. 오버플로우 탐지
  2. 정확한 계산은 정수형을 사용
  3. NaN과 Infinity 연산
  4. 입력값의 NaN 검사
   
1. 오버플로우 탐지  
    연산 후의 산출값이 산출 타입으로 충분히 표현 가능한지 생각해 봐야 한다.
    
    만약 산출 타입으로 표현할 수 없는 범위의 값이 산출되었을 경우, 오버플로우가 발생하고 쓰레기값을 얻을 수 있기 때문에 주의가 필요하다. 

    ```java
    int a = 1_000_000;
    int b = 2_000_000;
    long c = a * b;
    System.out.println(c);
    ```
    ```console
    -1454759936
    ```
    앞에서 배운대로 오버플로우 발생을 방지하기 위해 연산의 결과를 long 타입으로 받는 코드를 작성했다! 
    
    예상대로라면 위의 코드를 실행했을 때, 변수 c의 타입이 long으로, 저장공간이 충분히 크기 때문에 결과값으로 2000000000000이 출력될 것 같았지만, 전혀 다른 쓰레기값이 나왔다.  

    이 경우에 int 타입 간의 연산이기때문에 연산 결과가 int값으로 반환되었고, 그 값을 그대로 long타입으로 자동 형변환을 한 것뿐이기 때문에 결과값이 long 타입으로 변하지는 않는다.  

    또한 같은 의미의 식이라도 연산의 순서에 따라서 다른 결과를 얻을 수도 있다.  

    ```java
    int a = 1_000_000;
    int b = a * a / a;
    int c = a / a * b;
    System.out.println(b);
    System.out.println(c);
    ```
    ```console
    -727        //곱셈 먼저하면 오버플로우가 발생해서 쓰레기값이 담김
    1000000     //나눗셈 먼저한 결과
    ```

    <br>

    기선님이 수업 중에 언급하신 비슷한 예제도 살펴보자. start와 end 사이의 중간값을 구하는 코드이다. 
    ```java
    int start = 2000000000;
    int end = 2100000000;

    int mid = (start + end)/2;
    //이렇게 중간값을 구한다면 숫자가 큰 경우 오버플로우가 발생해서 이상한 결과가 나올 수 있다. 
    ```

    ```java
    //해결법 1
    int mid = start + (end - start)/2;
    ```

    ```java
    //해결법 2
    int mid = (start + end) >>> 1;
    //음수는 계산 불가능하다는 단점
    //이건 기교에 가깝고 웬만하면 1번 해결법을 쓰는 것을 추천
    ```

2. 정확한 계산은 정수 사용  
   정확하게 계산해야 할 때는 부동 소수점을 사용하는 실수 타입의 사용을 지양하자.  
   ~~저번 챕터에서 돈 계산할 때 실수 타입을 사용하지 말자고 한게 바로 떠올랐길..~~

3. NaN과 Infinity 연산  
   / 나 % 연산자는 좌측 피연산자가 정수 타입인 경우에, 우측 피연산자로 0을 사용할 수 없다.  

    ```java
    System.out.println(5/0);
    System.out.println(5%0);  
    ```
    ```console
    Exception in thread "main" java.lang.ArithmeticException: / by zero
    ```
    0으로 나누면 컴파일은 되지만, 실행 시 ArithmeticException이 발생한다. 따라서 프로그램 종료를 방지하기 위해서는 예외처리가 필요할 수 있다.   

    만약 실수 타입인 0.0 또는 0.0f로 나누면 ArithmeticException이 발생하지 않는다.  

    하지만 / 연산의 결과는 `Infinity`(무한대) 값을 가지고, % 연산의 결과는 `NaN`(Not a Number)를 가진다.  

    연산의 결과로 Infinity나 NaN이 나오면 그 다음부터는 어떤 연산을 수행해도 결과는 Infinity 또는 NaN에서 변하지 않기 때문에 결과값을 검사할 필요가 있을 때는 아래 두 메소드를 이용하면 된다.  

    ```java
    Double.insInfinite()
    Double.isNaN()
    ```
4. 입력값의 NaN 검사  
    부동 소수점(실수형)을 입력받을 때는 반드시 NaN 검사를 해야 하는데,
    NaN 검사는 == 연산자를 통해 조사하면 안되고, `Double.isNaN()` 메소드를 사용해야 한다.

<br>

### **비트 연산자**
비트 연산자는 피연산자를 비트단위로 논리 연산한다. 피연산자를 이진수로 표현했을 때의 각 자리를 규칙에 따라 연산을 수행하며, 피연산자로는 실수는 허용하지 않고 오직 정수(문자 포함)만 허용한다.  

비트 연산자의 진리표는 아래와 같다. 

|x|y|x\\|y|x&y|x^y|
|--:|--:|--:|--:|--:|
|1|1|1|1|0|
|1|0|1|0|1|
|0|1|1|0|1|
|0|0|0|0|0|

<br>

- 비트 보수 (Bitwise complement : ~)  

    이 연산자는 피연산자를 2진수로 표혔했을 때, 0을 1로 1을 0으로 바꾼다.  
    
    비트 보수 연산자에 의해 비트 전환이 일어나게 되면, 부호있는 타입의 피연산자는 부호가 반대로 변경된다. 따라서 피연산자의 **1의 보수**를 얻을 수 있기때문에 1의 보수 연산자라고도 한다.  

    비트 보수 연산자는 피연산자의 타입이 int보다 작으면 int로 자동 형변환 후에 연산하기 때문에 연산의 결과는 32비트 2진수이다.  

    > 자바에서 제공하는 Integer.toBinaryString() 메소드를 통해 정수값을 32비트 이진 문자열로 리턴받을 수 있다.  

- 쉬프트 연산자 \<\< \>\>
    
    쉬프트 연산자는 2진수를 오른쪽(\>\>) 또는 왼쪽(\<\<)으로 이동한다고 해서 쉬프트 연산자(shift operator)라고 한다. 왼쪽으로 비트를 한 비트씩 이동할 때마다 2가 곱해지는 것과 같고, 오른쪽으로 한 비트씩 이동할 때마다 2를 나누는 것과 같다.
    
    ```java
    int a = 8;
    System.out.println(a);          //8
    System.out.println(a >> 2);     //2
    System.out.println(a << 2);     //32
    ```

    예를 들어 8 \<\< 2는 왼쪽 피연산자인 10진수 8의 2진수(00001000)을 왼쪽으로 2자리 이동시킨다. 이 때, 자리 이동으로 저장범위를 넘어선 값들은 버려지고 오른쪽에 생긴 빈칸은 0으로 채워진다.  

    그런데 \>\> 연산자는 오른쪽으로 비트를 이동시키기 때문에 부호있는 정수는 부호를 유지하기 위해 왼쪽 피연산자가 양수인 경우에는 빈자리를 0으로 채우고, 음수인 경우에는 빈자리를 1로 채운다.  

    부호 없는 오른쪽 쉬프트 연산 (\>\>\>)을 사용하게 되면 피연산자의 부호와 상관없이 왼쪽 비트는 무조건 0으로 채우게 된다. 따라서 음수에 \>\>\> 연산을 하면 결과는 양수가 나온다  

    또한 쉬프트 연산자의 좌측 피연산자에는 산술 변환이 적용되어 int보다 작은 타입은 int로 자동 변환되고, 연산결과 역시 int 타입이 된다. 그러나 피연산자의 타입을 일치시킬 필요는 없기 때문에 오른쪽 피연산자에는 산술변환이 적용되지 않는다.  


- 기선님의 문제 : numbers라는 int형 배열이 있다. 이 배열에 요소들은 한 숫자를 제외하고는 모두 두 번씩 들어있다. 단 한 번만 등장하는 숫자를 찾는 코드를 작성하라.

    ```java
    // XOR을 활용하는 방식
    // XOR은 같으면 0 다르면 1
    private int solution(int[] numbers){
        int result = 0;
        for(int number : numbers){
            result ^= number;
        }
        return result;
    }
    // 결합 순서가 바뀌어도 결과는 같기 때문에 중복되는 숫자들은 xor 연산을 통해 0이 됨
    ```

<br>

### **관계 연산자**
관계 연산자는 두 피연산자를 비교하는데 사용되는 연산자로, 주로 조건문과 반복문의 조건식에 사용되며 연산 결과는 `true`와 `false` 둘 중에 하나이다.  

- 대소비교 연산자 (< > <= >=)  
    두 피연산자의 값의 크기를 비교하는 연산자이다. boolean을 제외한 기본형에서 모두 사용 가능하지만, 참조형은 사용할 수 없다.  
    > 피연산자가 char 타입이면 유니코드 값으로 비교 연산을 수행한다.  

- 등가비교 연산자 (== !=)  
    두 피연산자 사이의 값이 같은지 또는 다른지를 비교하는 연산자이다. 참조형을 포함한 모든 자료형에서 사용할 수 있다.  

    기본형의 경우, 변수에 저장되어 있는 값이 같은지를 알 수 있고, 참조형의 경우 객체의 주소값을 비교해 두 개의 피연산자가 같은 객체를 가리키고 있는지를 알 수 있다.  
    > 만약 두 문자열의 내용을 비교할 때는 == 대신 equals() 메소드를 사용해야 한다.  
    
    피연산자를 비교하기 전에 먼저 두 피연산자의 타입을 일치시킨다.  
    ```java
    'A' == 65       //true, 'A'가 int로 변환된 후 비교
    3 == 3.0        //true, int타입인 3을 double 타입으로 변환 후 비교
    ```

    그러나 아래와 같은 예외사항을 주의해야 한다.
    ```java
    0.1 == 0.1f             //false
    (float)0.1 == 0.1f      //true
    ```
    부동 소수점을 사용하는 타입은 0.1을 정확하게 표현할 수 없기때문에 0.1f는 0.1의 근사값으로 표현되어 내부적으로 0.1000000149011612과 같은 값을 가진다. 따라서 피연산자를 모두 float으로 타입 캐스팅을 해준 뒤 비교 연산을 해야 한다.  

    또한, 기본형과 참조형은 서로 형변환이 불가능하기 때문에 등가비교 연산자로 비교할 수 없다.  


### **논리 연산자**
논리 연산자는 피연산자로 boolean만을 사용하여 둘 이상의 조건을 AND(&&)나 OR(\|\|)으로 연결하여 하나의 식으로 표현할 수 있게 한다. 또한 부정 연산자(!)는 단항 연산자로써 해당 값의 결과를 반대로 반환한다. 

**단락 회로 평가 (Short Circuit Evaluation)**  
논리 연산자가 효율적인 연산을 하기 위한 방식으로, &&와 \|\| 연산을 사용할 때 첫 번째 피연산자의 결과에 따라 결과값이 정해졌을 경우, 두 번째 피연산자를 평가하지 않는 것을 말한다.  

이런 점이 비트 연산자(&나 \|)와 논리 연산자(&&나 \|\|)를 사용할 때의 차이점이라고 볼 수 있으며 아래 예시를 참고하면 쉽게 이해할 수 있을 것이다.  

```java
int i = 0;
int j = 0;

if(i++ == 0 || j++ == 0){
    System.out.println("Hello");
}
System.out.println(i);
System.out.println(j);

```

```console
Hello
1
0
//한 쪽을 검사해 조건이 만족되면 다른 쪽은 검사하지 않음
```

```java
int i = 0;
int j = 0;

if(i++ == 0 | j++ == 0){
    System.out.println("Hello");
}
System.out.println(i);
System.out.println(j);

```
```console
Hello
1
1
//양 쪽 조건을 모두 검사함
```


## 참조
<https://yadon079.github.io/2020/java%20study%20halle/week-03>  
<https://github.com/yeGenieee/java-live-study/blob/main/%5B3%5DJava%20Live%20Study.md>  
<https://velog.io/@uhan2/Java-Operator>  
<https://blog.baesangwoo.dev/posts/java-livestudy-3week/>