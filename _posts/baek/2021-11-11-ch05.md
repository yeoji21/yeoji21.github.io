---
title: "클린 코더스 강의 정리 - 5장"
author: "yeoji21"
date: 2021-11-11
categories: [Backend, oop]
tags: [java, oop, programming]
---

## 들어가면서

- 해당 포스트는 [최범균님의 클린 코더스 강의](https://www.youtube.com/watch?v=60lLSe1phks)를 정리한 내용입니다. 
- 강의 자료는 [깃 허브](https://github.com/msbaek/clean-coders-2013)에서 보실 수 있습니다.

## 클린 코더스 강의 5. Function Structure

### 1. Arguments
- **인자가 많아지면 복잡도가 증가한다.**  
- **3개의 인자가 최대**  
    그 이상 넘어가면 외우기 어렵다. 따라서 Intellij의 Introduce Parameter Object 기능을 사용해서 파라미터들을 하나의 클래스로 만드는 것을 추천한다.
- **생성자에 많은 수의 인자를 넘겨야 한다면, `setter`를 사용하거나 `Builder`패턴을 적용하는 것이 좋다.**
- **Boolean 인자 사용 금지**  
    두 가지 이상의 일을 하는 것이 되어버린다. 이런 경우에는 `true` 경우를 위한 일, `false` 경우를 위한  일로 2개의 함수로 분리할 것
- **Innies not Outies**  
    파라미터는 Input으로 작용해야지 Output으로 작용해서는 안된다.
    ```java
    private String toSimpleText(Parse table, StringBuffer returnText) {
        if (table.parts == null) {
            simpleTextOfLeave(table, returnText);
            simpleTextOfMore(table, returnText);
            return returnText.toString();
        }
        simpleTextOfParts(table, returnText);
        simpleTextOfMore(table, returnText);
        return returnText.toString();
    }
    ```
    메소드의 Output은 메소드 내에서 만들어진 결과값으로 리턴해주거나, 리턴값을 `void`로 하고 값을 변경하거나 해야 하는데

    위 코드에서는 `table`과 `returnText`를 파라미터로 받아서 다시 다른 메소드의 파라미터로 넘겨주는 일을 한 뒤, 변경되었을 것으로 예상되는 `returnText`를 다시 리턴한다. 따라서 `returnText`는 파라미터(input)으로 들어와서 메소드 내에서 변경된 뒤에 리턴(output)되는 것이다.

    이런 상황이라면 `returnText`를 파라미터로 받은 후 메소드의 로컬변수를 변경한 뒤 로컬변수를 리턴해주어야 한다. 따라서 output으로 argument 대신 return value를 만들어서 처리해야 한다.

- **the null defense (null check)**  
    파라미터로 null을 전달받길 기대하는 메소드는 없다. 이것은 Boolean을 전달하는 것만큼 잘못된 것이며 null인 경우의 메소드와 null이 아닌 경우의 메소드로 분리하는 것이 맞다.  
    
    null을 마치 boolean인 것처럼 사용하지 말 것.

    defensive programming을 지양하라. 코드를 null과 에러 체크로 더럽히지 말아야 한다. null 여부를 지속적으로 조사하지 않고 단위 테스트에서 검증해야 한다. 만약 null이 발생할 확률이 높다면 차라리 예외를 던지는 편이 낫다.

    단, public api를 사용하는 경우에는 defensive하게 null check를 하는 것이 맞다. 


### 2. The Stepdown Rule
- 모든 `public`은 위에, 모든 `private`는 아래에 위치하도록
- public part만 사용자들에게 전달하면 된다. backward reference없이 top에서 bottom으로 읽을 수 있게

### 3. switches and cases
객체지향에 관한 어떤 책에서는 switch문은 객체지향스럽지 못하므로 사용하지 말라고 한다. 그런데 이 대답은 그리 만족스러운 대답이 아니다.

객체지향의 가장 큰 이점 중 하나는 의존성 관리 능력이다.

만약 모듈 A가 모듈 B의 메소드를 사용한다고 가정하면, 절차지향 방식에서는 2가지 의존성이 발생한다. 

<img src="assets/../../../assets/img/baek/3.jpeg" width=300>

이 경우, B의 메소드를 호출하는 A가 상위 로직이다. 따라서 A가 더 중요도가 높은 로직인데 반해 B에서 어떤 변경이 일어나면 A가 영향을 받는다. 이런 형태에서는 독립적인 배포/컴파일/개발이 불가능하다.

하지만 객체지향에서는 다음과 같은 형태가 가능하다.

<img src="assets/../../../assets/img/baek/4.jpeg" width=300>

본래 의존성을 제거하고 polymorphic interface를 삽입하면, 모듈 A는 인터페이스에 의존하고, 모듈 B는 인터페이스로부터 derive한다.

이렇게 되면 runtime 의존성은 그대로 둔 채, source code 의존성을 역전시킨다 => `Dependency Inversion Principle`
> 이런 구조는 유닛 테스팅시에도 매우 유리하다. 테스트 코드를 작성하기 힘든 이유는 구조가 잘못되었기 때문이다. 

따라서 Independent Deployability는 객체지향의 강점 중 하나이다.

그런데 **switch 문장은 독립적 배포에 방해가 된다.**

switch의 각 case 문장은 외부 모듈에 의존성을 갖고, 다수의 다른 모듈에 의존성을 가질 수 있다. 이런 것을 fan-out problem이라고 한다. 

따라서 switch문에서 source code 의존성은 flow of control과 방향이 같아지게 된다. 외부 모듈 중 하나라도 변경이 일어나면 switch 문장이 영향을 받고, switch에 의존하는 다른 모든 것들도 영향을 받게 된다.

switch문을 제거하기 위해서는 먼저 switch문을 polymorphic interface 호출로 변환한 뒤, case에 있는 문장들을 별도의 클래스로 추출하여 변경 영향이 발생하지 않도록 한다.

### VideoStore 예제
```java
public class Movie {
    public static final int CHILDRENS = 2;
    public static final int NEW_RELEASE = 1;
    public static final int REGULAR = 0;
    
    private String title;
    private int pricecode;

    public Movie(String title, int pricecode) {
        this.title = title;
        this.pricecode = pricecode;
    }

    public void setPricecode(int pricecode) {
        this.pricecode = pricecode;
    }

    public String getTitle() {
        return title;
    }

    public int getPricecode() {
        return pricecode;
    }

    double determineAmount(int daysRented) {
        double rentalAmount = 0;
        switch(pricecode){
            case REGULAR:
                rentalAmount += 2;
                if (daysRented > 2)
                    rentalAmount += (daysRented - 2) * 1.5;
                break;
            case NEW_RELEASE:
                rentalAmount += daysRented * 3;
                break;
            case CHILDRENS:
                rentalAmount += 1.5;
                if(daysRented > 3)
                    rentalAmount += (daysRented - 3) * 1.5;
                break;
        }
        return rentalAmount;
    }

    int determineFrequentRentalPoint(int daysRented) {
        boolean bonusIsEarned = pricecode == NEW_RELEASE && daysRented > 1;
        if(bonusIsEarned)
            return 2;
        return 1;
    }
}
```

```java
public class Rental {

    private Movie movie;
    private int daysRented;

    public Rental(Movie movie, int daysRented) {
        this.movie = movie;
        this.daysRented = daysRented;
    }

    public Movie getMovie() {
        return movie;
    }

    public String getTitle() {
        return movie.getTitle();
    }

    public double determineAmount() {
        return movie.determineAmount(daysRented);
    }

    public int determineFrequentRentalPoint() {
        return movie.determineFrequentRentalPoint(daysRented);
    }
}
```

```java
public class Statement {
    private String customerName;
    private List<Rental> rentals = new ArrayList<>();
    private double total;
    private int frequentRenterPoints;
    private double totalAmount;

    public Statement(String customerName) {
        this.customerName = customerName;
    }

    public void addRental(Rental arg) {
        rentals.add(arg);
    }

    public String getCustomerName() {
        return customerName;
    }

    public String generate() {
        clearTotals();
        String statementText = header();
        statementText += rentalLines();
        statementText += footer();
        return statementText;
    }

    private void clearTotals() {
        totalAmount = 0;
        frequentRenterPoints = 0;
    }

    private String header() {
        return String.format("Rental Record for %s\n", customerName);
    }

    private String rentalLines() {
        String rentalLines = "";
        for (Rental rental : rentals) {
            rentalLines += rentalLine(rental);
        }
        return rentalLines;
    }

    private String rentalLine(Rental rental) {
        double rentalAmount = rental.determineAmount();
        frequentRenterPoints += rental.determineFrequentRentalPoint();
        totalAmount += rentalAmount;

        return formatRentalLine(rental, rentalAmount);
    }

    private String formatRentalLine(Rental rental, double rentalAmount) {
        return String.format("\t%s\t%.1f\n", rental.getTitle(), rentalAmount);
    }

    private String footer() {
        return String.format(
                "Amount owed is %.1f\n" +
                        "You earned %d frequent renter points",
                totalAmount, frequentRenterPoints);
    }

    public double getTotal() {
        return totalAmount;
    }

    public int getFrequentRenterPoints() {
        return frequentRenterPoints;
    }
}
```

```java
@TestInstance(TestInstance.Lifecycle.PER_METHOD)
public class VideoStoreTest {
    private Statement statement;
    private final double DELTA = .001;
    private Movie newReleaseMovie1;
    private Movie newReleaseMovie2;
    private Movie childrensMovie;
    private Movie regular1;
    private Movie regular2;
    private Movie regular3;

    @BeforeEach
    public void setUp() {
        statement = new Statement("Customer");
        newReleaseMovie1 = new Movie("New Release 1", Movie.NEW_RELEASE);
        newReleaseMovie2 = new Movie("New Release 2", Movie.NEW_RELEASE);
        childrensMovie = new Movie("Childrens", Movie.CHILDRENS);
        regular1 = new Movie("Regular 1", Movie.REGULAR);
        regular2 = new Movie("Regular 2", Movie.REGULAR);
        regular3 = new Movie("Regular 3", Movie.REGULAR);
    }

    @Test
    public void testSingleNewReleaseStatementTotals() {
        statement.addRental(new Rental(newReleaseMovie1, 3));
        statement.generate();
        assertEquals(9.0d, statement.getTotal(), DELTA);
        assertEquals(2, statement.getFrequentRenterPoints());
    }

    @Test
    public void testDualNewReleaseStatementTotals() {
        statement.addRental(new Rental(newReleaseMovie1, 3));
        statement.addRental(new Rental(newReleaseMovie2, 3));
        statement.generate();
        assertEquals(18.0, statement.getTotal(), DELTA);
        assertEquals(4, statement.getFrequentRenterPoints());
    }

    @Test
    public void testSingleChildrenStatementTotals() {
        statement.addRental(new Rental(childrensMovie, 3));
        statement.generate();
        assertEquals(1.5, statement.getTotal(), DELTA);
        assertEquals(1, statement.getFrequentRenterPoints());
    }

    @Test
    public void testMultipleRegularStatementTotals() {
        statement.addRental(new Rental(regular1, 1));
        statement.addRental(new Rental(regular2, 2));
        statement.addRental(new Rental(regular3, 3));
        statement.generate();
        assertEquals(7.5, statement.getTotal(), DELTA);
        assertEquals(3, statement.getFrequentRenterPoints());
    }

    @Test
    public void testMultipleRegularStatementFormat() {
        statement.addRental(new Rental(regular1, 1));
        statement.addRental(new Rental(regular2, 2));
        statement.addRental(new Rental(regular3, 3));
        assertEquals(
                "Rental Record for Customer\n" +
                        "\tRegular 1\t2.0\n" +
                        "\tRegular 2\t2.0\n" +
                        "\tRegular 3\t3.5\n" +
                        "Amount owed is 7.5\n" +
                        "You earned 3 frequent renter points",
                statement.generate());
    }
}
```

<br>

먼저 `Movie` 클래스의 switch문을 지우기 위해서 test code부터 수정하는 것으로 시작한다.
```java
@BeforeEach
public void setUp() {
    statement = new Statement("Customer");
    newReleaseMovie1 = new NewReleaseMovie("New Release 1", Movie.NEW_RELEASE);
    newReleaseMovie2 = new NewReleaseMovie("New Release 2", Movie.NEW_RELEASE);
    childrensMovie = new ChildrensMovie("Childrens", Movie.CHILDRENS);
    regular1 = new RegularMovie("Regular 1", Movie.REGULAR);
    regular2 = new RegularMovie("Regular 2", Movie.REGULAR);
    regular3 = new RegularMovie("Regular 3", Movie.REGULAR);
}
```

이런 방식으로 `ChildrensMovie` 클래스와 `RegularMovie`도 만들어준다.
```java
public class NewReleaseMovie extends Movie {
    public NewReleaseMovie(String title, int pricecode) {
        super(title, pricecode);
    }
}
```

이렇게 하면 테스트는 성공적으로 통과하지만 생성자에서 중복을 발견할 수 있다. 이 중복을 모두 제거해주자.
```java
@BeforeEach
public void setUp() {
    statement = new Statement("Customer");
    newReleaseMovie1 = new NewReleaseMovie("New Release 1");
    newReleaseMovie2 = new NewReleaseMovie("New Release 2");
    childrensMovie = new ChildrensMovie("Childrens");
    regular1 = new RegularMovie("Regular 1");
    regular2 = new RegularMovie("Regular 2");
    regular3 = new RegularMovie("Regular 3");
}
```

그 후 pricecode는 클래스마다 부모의 생성자로 직접 전달한다. 
```java
public class NewReleaseMovie extends Movie {
    public NewReleaseMovie(String title) {
        super(title, NEW_RELEASE);
    }
}
```

이제 다시 `Movie` 클래스의 `determineAmount()`를 살펴보면, 각각의 case 문은 방금 구현한 각각의 클래스에 구현되어야 하는 로직임을 알 수 있다.
```java
double determineAmount(int daysRented) {
    double rentalAmount = 0;
    switch(pricecode){
        case REGULAR:
            rentalAmount += 2;
            if (daysRented > 2)
                rentalAmount += (daysRented - 2) * 1.5;
            break;
        case NEW_RELEASE:
            rentalAmount += daysRented * 3;
            break;
        case CHILDRENS:
            rentalAmount += 1.5;
            if(daysRented > 3)
                rentalAmount += (daysRented - 3) * 1.5;
            break;
    }
    return rentalAmount;
    }
```

따라서 `Movie` 클래스를 추상 메소드로 변경하고  `determineAmount()`와 `determineFrequentRentalPoint()`를 추상 메소드로 변경한다. 

이때 Intellij의 Push Members Down 기능을 사용하면 간편하게 리펙토링 가능하다.

```java
public abstract class Movie {
    public static final int CHILDRENS = 2;
    public static final int NEW_RELEASE = 1;
    public static final int REGULAR = 0;

    private String title;
    private int pricecode;

    abstract double determineAmount(int daysRented);
    abstract int determineFrequentRentalPoint(int daysRented);
    ...
}
```
구현했던 코드들은 각각의 자식 클래스들로 이동해있는데, 여기서 `pricecode`를 사용하는 부분만 `getPricecode()`로 변경하면 문제없이 테스트를 성공한다. 

하지만 각 클래스마다 불필요한 switch문이 중복되어 있다. 테스트 실행 시 실제로 동작하는 코드를 알아보기 위해 Intellij의 Run with Coverage 기능을 사용하면 다음과 같이 실행되는 라인에만 초록불이 들어온다.

<img src="assets/../../../assets/img/baek/5.png" width=500>

붉은색으로 표시된 다른 클래스의 케이스들을 모두 지워주자.

`ChildrensMovie` 클래스의 `determineAmount()`는 아래와 같이 간략화된다. 같은 방식으로 다른 클래스에도 적용하자.
```java
@Override
double determineAmount(int daysRented) {
    double rentalAmount = 0;
    rentalAmount += 1.5;
    if(daysRented > 3)
        rentalAmount += (daysRented - 3) * 1.5;
    return rentalAmount;
}
```

`determineFrequentRentalPoint()`도 마찬가지로 `NEW_RELEASE`에만 적용되는 구문은 다른 클래스에서 삭제해준다.

`NewReleaseMovie` 클래스에서는 아래와 같고, 다른 클래스에서는 그저 `return 1`만 수행한다.
```java
@Override
int determineFrequentRentalPoint(int daysRented) {
    if(daysRented > 1)
        return 2;
    return 1;
}
```
<br>

이렇게 다형성을 사용한 리펙토링이 완료되었다. 진행한 과정을 정리해보면,

- 먼저 Test부터 Polymorphic하게 수정
- make it pass
- 중복제거
- Push Members Down
- run with coverage
- remove unused code
- remove type code

이 과정을 통해 Runtime 의존성은 그대로 두고 Source code 의존성을 역전했다. 이제 신경 쓸 일은 언제/어떻게 인스턴스를 생성하는가이다. 

대개 팩토리에서 이러한 작업을 수행하며 이것을 통해 `main`이라는 주요한 토픽을 가져온다. 

**application/main partition**

<img src="assets/../../../assets/img/baek/6.png" width=400>

- Application Partition : 대개의 애플리케이션 코드가 존재하는 곳
- Main Partition : 하위 레벨 (factory, configuration data, main program...)
- 항상 모듈 다이어그램에서 App 파티션과 Main 파티션 사이에 선을 그을 수 있어야 한다.
- Main에서 App으로 향하는 한방향 의존성
- Main Partition은 App Partition의 plugin
- 이러한 기법을 `Dependency Injection`이라 하고, Spring을 사용하면 Main Partition 부분은 모두 스프링이 생성하고 관리한다. 

