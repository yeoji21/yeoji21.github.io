---
title: "백기선님과 함께 하는 자바 스터디 - 10"
author: "yeoji21"
date: 2021-08-22
categories: [Backend, Java]
tags: [java, java study, 자바, 자바 스터디]
pin: true
---

<img src="https://media.vlpt.us/images/inhalin/post/b48b4cd3-619b-4bf4-939c-d3546dd2ec01/whiteship.png">

## 들어가면서
백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다.  
강의 영상 링크 : [[자바 라이브 스터디] 2020/1/16, 10주차 멀티스레드 프로그래밍
](https://www.youtube.com/watch?v=kZ85x1VbZBs&list=PLfI752FpVCS96fSsQe2E3HzYTgdmbz6LU&index=19)  
강의 깃허브 링크 : [10주차 과제: 멀티쓰레드 프로그래밍](https://github.com/whiteship/live-study/issues/10)

## 목차
- Thread 클래스와 Runnable 인터페이스
- 쓰레드의 상태
- 쓰레드의 우선순위
- Main 쓰레드
- 동기화
- 데드락

### **Process와 Thread**
**프로세스**란, 간단히 말해서 실행 중인 프로그램을 말한다. 우리가 프로그램을 실행하면 OS로부터 실행에 필요한 자원(메모리)를 할당받아 프로세스가 된다.  

프로세스는 프로그램을 수행하는 데 필요한 데이터와 메모리 등의 자원과 쓰레드로 구성되어 있으며, 프로세스의 자원을 이용해서 실제로 작업을 수행하는 것이 바로 **쓰레드**이다.  

우리가 사용하고 있는 대부분의 OS는 멀티태스킹(multi-tasking)을 지원하기 때문에 여러 개의 프로세스가 동시에 실행될 수 있다.  

이와 마찬가지로, 멀티 쓰레딩은 하나의 프로세스 내의 여러 개의 쓰레드가 동시에 작업을 수행한다. CPU의 코어는 한 번에 단 하나의 작업만 수행할 수 있으므로, 실제로 처리해야하는 작업의 개수는 코어의 개수와 일치한다.  

그러나 대부분의 상황에서 쓰레드의 수가 코어의 개수보다 훨씬 많기 때문에 각 코어가 아주 짧은 시간 동안 여러 작업을 번갈아가며 수행함으로써 여러 작업들이 모두 동시에 수행되는 것처럼 보이게 한다.  

#### 동시성(concurrency)과 병렬성(parallelism)
멀티 쓰레드가 실행될 때 CPU의 코어의 개수와 연관된 동작 방식이다.  

하나의 코어에서 여러 쓰레드가 매우 빠르게 번갈아가며 실행되는 것을 **동시성**, 멀티 코어에서 코어별로 개별 쓰레드가 동시에 실행되는 것을 **병렬성**이라고 한다.


### **Thread 클래스와 Runnable 인터페이스**
자바에서 쓰레드를 구현하는 방법은 `Thread 클래스`를 상속받는 방법과 `Runnable 인터페이스`를 구현하는 방법, 두 가지가 있다.  

만약 Thread 클래스의 메소드를 오버라이딩할 필요가 있다면 Thread 클래스를 상속하는 방법을 사용해야 하지만, Thread 클래스를 상속받으면 다른 클래스를 상속할 수 없기때문에 Runnable 인터페이스를 구현하는 것이 일반적이다. 

쓰레드를 구현하기 위해서는 두 방법 중 하나를 선택한 뒤 `run()` 메소드를 오버라이딩하여 쓰레드가 실행할 코드를 구현해야 한다.  

아래 코드는 두 가지 방법을 이용해 쓰레드를 구현하고 실행시키는 예제이다.  

```java
class ThreadEx1 extends Thread {
    public ThreadEx1(String name) {
        super(name);
    }

    public ThreadEx1(){
        super();
    }

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(getName());
        }
    }
}

class ThreadEx2 implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName());
        }
    }
}

public class ThreadTest {
    public static void main(String[] args) {
        ThreadEx1 t1 = new ThreadEx1("Thread By Thread class");
        ThreadEx2 r = new ThreadEx2();
        Thread t2 = new Thread(r, "Thread By Runnable interface");

        t1.start();
        t2.start();
    }
}
```
```console
Thread By Runnable interface
Thread By Runnable interface
Thread By Runnable interface
Thread By Runnable interface
Thread By Runnable interface
Thread By Thread class
Thread By Thread class
Thread By Thread class
Thread By Thread class
Thread By Thread class
```

먼저 main 메소드를 보면 Thread 클래스를 상속한 방법과 Runnable 인터페이스를 구현한 방법의 인스턴스 생성 방식이 다른 것을 알 수 있다.  

Runnable 인터페이스를 구현한 경우, Runnable 인터페이스를 구현한 클래스의 인스턴스를 생성한 다음, 이 인스턴스를 Thread 클래스의 생성자의 매개변수로 제공해야 한다.  

따라서 Thread 클래스를 상속받으면, 자식 클래스 내부에서 Thead 클래스의 메소드를 직접 호출할 수 있지만, Runnable 인터페이스를 구현한 클래스의 내부에서는 Thread 클래스의 `static` 메소드인 `currentThread()`를 호출하여 쓰레드에 대한 참조를 얻어 와야만 호출이 가능하다.  

```java
System.out.println(Thread.currentThread().getName());
```

Thread 클래스를 열어보면 Runnable 인터페이스의 인스턴스를 매개변수로 받는 생성자가 있는 것을 확인할 수 있다. 

```java
public Thread(Runnable target) {
    this(null, target, "Thread-" + nextThreadNum(), 0);
}
```

그런데 main 메소드에서 각각의 쓰레드를 실행시키는 것을 자세히 보면, 우리가 오버라이딩한 `run()`이 아닌 `start()`를 호출하고 있다. 그 이유가 무엇일끼?  

우리가 알다시피 main메소드에서 run()을 호출하는 것은 스레드를 생성하는 것이 아니라 단순히 클래스에 선언된 메소드를 호출하는 것일뿐이다.  

반면에 start()는 새로운 쓰레드가 작업을 실행하는데 필요한 **호출스택(call stack)**을 생성한 다음에 run()을 호출해서 생성된 호출 스택에 run()이 첫번째로 올라가게 한다. 

이렇게 생성된 쓰레드는 run() 메소드를 수행하고, 메소드 실행이 종료되어 호출스택이 비워지면 호출스택이 소멸하면서 쓰레드도 종료된다.  

종료된 스레드는 다시 실행할 수 없기때문에 하나의 쓰레드에 대해 start()가 한 번만 호출될 수 있다.  

그래서 만일 쓰레드의 작업을 한 번 더 수행해야 한다면 새로운 쓰레드를 생성해야 한다.  그렇지않고 한 스레드에 대해 start()를 두 번 이상 실행하면 `IllegalThreadStateException`이 발생한다.  

### **쓰레드의 상태**  

멀티쓰레드 프로그래밍을 잘하기 위해서는 정교한 스케줄링을 통해 여러 쓰레드가 자원과 시간을 낭비 없이 사용하도록 해야 하는데 이를 위해서는 쓰레드의 상태와 관련 메소드를 잘 알아햐 한다.

`NEW` - 쓰레드가 생성되고 아직 start()가 호출되지 않은 상태  
`RUNNABLE` - 실행 중 또는 실행 가능한 상태   
`BLOCKED` - 동기화 블럭에 의해서 일시정지된 상태(lock이 풀릴 때까지 기다리는 상태)  
`WAITING`, `TIMED_WAITING` - 쓰레드의 작업이 종료되지는 않았지만 실행가능하지 않은(unrunnable) 일시정지 상태, TIMED_WATING은 일시정지 시간이 지정된 경우를 의미한다.   
`TERMINATED` - 쓰레드의 작업이 종료된 상태  
> 참고로 Java 5부터 getState() 메소드를 통해 Thread의 상태를 확인할 수 있게 되었다. 

<img src="/assets/img/week10/1.jpeg" >  

#### 쓰레드 상태제어 메소드

|Method|Description|
|--:|--:|
static void sleep(long millis)|지정된 시간동안 쓰레드를 일시정지시킨다.<br>지정된 시간이 지나고 나면 자동으로 다시 실행대기 상태가 된다.|
void join() <br> void join(long millis)|지정된 시간동안 잠시 작업을 멈추고 다른 쓰레드가 실행되도록 한다. <br> 지정된 시간이 지나거나 작업이 종료되면 join()을 호출한 메소드로 돌아와 실행을 계속한다.|
void interrupt() | sleep()이나 join()에 의해 일시정지상태인 쓰레드를 깨워 실행대기상태로 만든다. <br>해당 쓰레드는 InterruptedException이 발생함으로써 일시정지상태를 벗어나게 된다. |
@Deprecated void stop()|쓰레드를 즉시 종료시킨다.|
@Deprecated void suspend()|쓰레드를 일시정지시킨다.|
@Deprecated void resume()|suspend()에 의해 일시정지된 쓰레드를 실행대기상태로 만든다.|
static void yield()|실행 중에 자신에게 주어진 시간을 다른 쓰레드에게 양보하고 자신은 실행대기상태가 된다.

#### sleep() - 일정시간동안 쓰레드를 멈추게한다.
```java
static void sleep(long millis)
static void sleep(long millis, int nanos)
```
> Thread.sleep()의 인자는 Long 타입이기때문에 Long 타입 리터럴은 되도록이면 끝에 L을 붙여주는 것이 좋다.

`sleep()`에 의해 일시정지상태가 된 쓰레드는 지정된 시간이 다 되거나, interrupt()가 호출되면 `InterruptedException`이 발생하여 실행대기상태가 된다.

sleep()은 항상 현재 실행중인 쓰레드에 대해 동작하기 때문에 th1.sleep(2000)과 같이 호출했어도 실제로 영향을 받는 것은 main 메소드를 실행하는 main 쓰레드이다.  

그래서 sleep()은 static으로 선언되어 있으며 참조변수를 이용해서 호출하기 보다는 `Thread.sleep(2000)`과 같이 해야 한다.

또한 sleep() 사용 시 checked exception이 발생하는데, catch문에서 기껏해야 RuntimeException으로 던지기정도밖에 할 수 있는 것이 없다. 이럴때 `lombok`의 `@SneakyThrows` 어노테이션을 사용하면 편리하다.  

#### interrupt(), interrupted() - 쓰레드의 작업을 취소한다.
`interrupt()`는 쓰레드에게 작업을 멈추라고 요청한다. 단지 멈추라고 요청하는 것일 뿐 쓰레드를 강제로 종료시키지는 못한다. interrupt()는 그저 쓰레드의 인스턴스 변수인 interrupted의 상태를 바꿀 뿐이다.  

```java
void interrupt() - 쓰레드의 interrupted 상태를 false에서 true로 변환 
boolean isInterrupted() - 쓰레드의 interrupted상태를 반환 
static boolean interrupted() - 현재 쓰레드의 interrupted 상태를 반환 후 false로 변경 
```

쓰레드가 sleep(), wait(), join()에 의해 '일시정지 상태(WAITING)'에 있을 때, 해당 쓰레드에 대해 interrupt()를 호출하면 `InterruptedException`이 발생하고 쓰레드는 '실행대기 상테(RUNNABLE)'로 바뀐다. 즉, 멈춰있던 쓰레드를 깨워서 실행가능한 상태로 만드는 것이다. 

#### suspend(), resume(), stop()
`resume()`, `stop()`, `suspend()`는 쓰레드를 교착상태(dead-lock)로 만들기 쉽기 때문에 `deprecated` 되었다.  

따라서 사용하는 것이 권장되지 않는다. 특히 stop() 같은 경우 그냥 없다고 생각하고 쓰지말아야 한다. 
자바에서 쓰레드를 시스템적으로 종료시키는 것은 많은 문제가 발생시킬 수 있기때문에 없다고 생각해야 한다. 쓰레드의 종료는 개발자가 직접 코드로 해결해야할 문제다.  

#### yield() - 다른 쓰레드에게 양보한다. 
`yield()` 쓰레드는 자신에게 주어진 실행시간을 다음 차례의 쓰레드에게 양보(yield)한다.

스케쥴러에 의해 1초의 실행시간을 할당받은 쓰레드가 0.5초의 시간동안 작업한 상태에서 yield()가 호출되면, 나머지 0.5초는 포기하고 다시 실행대기 상태가 된다.

`yield()`와 `interrupt()`를 적절히 사용하면 프로그램의 응답성을 높이고 효율적인 실행이 가능하게 할 수 있다.

```java
while (!stopped) {
    if (!suspend) {
        ...
        try{
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            System.out.println(name + " - interrupted");
        }
    }
}
```
만약 위 코드에서 suspend 변수의 값이 true라면, 쓰레드는 주어진 시간을 그저 while문을 의미없이 돌면서 낭비하게 될 것이다. 이런 상황을 바쁜 `대기상태(busy-waiting)`이라고 한다.  

이러한 경우, yield()를 사용해 코드를 개선할 수 있다. 
```java
while (!stopped) {
    if (!suspend) {
        ...
        try{
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            System.out.println(name + " - interrupted");
        }
    }
    else{
        Thread.yield();
    }
}
```
같은 상황에서 yield()를 호출해서 남은 실행시간을 낭비하지 않고 다른 쓰레드에게 양보하게 되므로 더 효율적이다.

#### join() - 다른 쓰레드의 작업을 기다린다. 
쓰레드 자신이 하던 작업을 잠시 멈추고 다른 쓰레드가 지정된 시간동안 작업을 수행하도록 할 때 `join()`을 사용한다.  

시간을 지정하지 않으면 해당 쓰레드가 작업을 모두 마칠 때까지 기다린다. 작업 중에 다른 쓰레드의 작업이 먼저 수행되어야 할 필요가 있을 떄 join()을 사용한다. 

```java
try{
    th1.join();     //현재 실행중인 쓰레드가 쓰레드 th1의 작업이 끝날 때까지 기다린다.
}catch(InterruptedException e){}
```

join()도 sleep()처럼 interrupt()에 의해 대기상태에서 벗어날 수 있기때문에 join()이 호출되는 부분을 try-catch문으로 감싸야 한다.  

sleep()과 다른 점은 join()은 현재 쓰레드가 아닌 특정 쓰레드에 대해 동작하므로 static 메소드가 아니라는 점이다.