---
title: "백기선님과 함께 하는 자바 스터디 - 05"
author: "yeoji21"
date: 2021-08-15
categories: [Backend, Java]
tags: [java, java study, 자바, 자바 스터디]
pin: true
---

<img src="https://media.vlpt.us/images/inhalin/post/b48b4cd3-619b-4bf4-939c-d3546dd2ec01/whiteship.png">

## 들어가면서
백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다.  
강의 영상 링크 : [[자바 라이브 스터디] 2020/12/19, 5주차 클래스
](https://www.youtube.com/watch?v=5u_YnIeyYAU&list=PLfI752FpVCS96fSsQe2E3HzYTgdmbz6LU&index=10)  
강의 깃허브 링크 : [5주차 과제: 클래스](https://github.com/whiteship/live-study/issues/5)

## 목차
- 클래스 정의하는 방법
- 객체 만드는 방법 (new 키워드 이해하기)
- 메소드 정의하는 방법
- 생성자 정의하는 방법
- this 키워드 이해하기

### **클래스 정의하는 방법**

#### **클래스란**  

클래스는 객체지향 프로그래밍(Object-Oriented Programming)에서 객체를 생성하기 위해 상태(state)와 행동(behavior)을 정의하는 일종의 설계도라고 할 수 있다.  

여기서 말하는 객체란, 어플리케이션의 기능을 구현하기 위해 서로 협력하는 개별적인 실체로써 물리적일 수도 있고 개념적인 것일 수도 있다.  

객체지향의 4대 특성(추상화, 캡슐화, 상속, 다형성)을 충분히 활용하면 프로그램 개발 및 유지보수를 쉽고 효율적으로 할 수 있다.  

이에 관한 더 자세한 내용은 `객체지향의 사실과 오해` 책을 다 읽고 따로 정리하도록 하겠다!

#### **클래스의 구조**  

- 필드 (field)  
    필드는 해당 클래스 객체의 상태 속성을 나타내며, 멤버변수라고도 불린다. 
    - 인스턴스 변수 : 멤버 변수 중 `static이 붙지 않은`, 인스턴스가 갖는 변수이다. 각 인스턴스마다 독립된 값을 갖기 때문에 heap영역에 할당되고 gc에 의해 관리된다.  
    - 클래스 변수 : 멤버 변수 중 `static이 붙은` 변수를 클래스 변수라고 한다. 해당 클래스의 모든 인스턴스는 클래스 변수 값을 공유한다. 따라서 static 영역에 할당되어 gc의 관리를 받지 않는다.

- 메소드 (method)  
    메소드는 해당 객체의 행동을 나타내며, 보통 필드의 값을 조정하는 역할을 하는 경우가 많다. 메소드 또한 인스턴스 메소드와 클래스 메소드로 구분된다. 

- 생성자 (constructor)  
    생성자는 클래스의 객체를 초기화하는 데 사용되는 코드 블록이다. 메소드와 달리 리턴 타입이 없으며 클래스는 최소한 하나의 생성자를 가진다.  
    생성자를 하나도 만들지 않은 경우 컴파일 시에 자동으로 기본 생성자가 추가된다.  

- 초기화 블록 (initializer)  
    초기화 블록을 사용하면 조건문, 반복문 등을 사용할 수 있기때문에 멤버 변수에 대해 명시적 초기화에서는 불가능했던 초기화 작업을 할 수 있다.  
    클래스 초기화 블록과 인스턴스 초기화 블록으로 나뉜다. 

#### **제어자** 

접근 제어자 - `public`, `protected`, `defualt`, `private`  

접근 제어자는 해당 클래스 또는 멤버를 정해진 범위에서만 접근할 수 있도록 통제하는 역할을 한다. default는 아무것도 붙이지 않은 것을 의미하며, 클래스에는 public과 default만 사용 가능하다. 

|접근 제어자|동일 클래스|동일 패키지|자손 클래스|그 외 영역|
|---:|---:|---:|---:|---:|
public|O|O|O|O|
protected|O|O|O||
(default)|O|O|||
private|O|||  

<br>

그 외 제어자

`static`  
변수, 메소드는 인스턴스가 아닌 해당 클래스에 속하게 된다.  
  - static 멤버 변수 : 클래스가 메모리에 로드될 때 사용되며 인스턴스 생성 없이 사용 가능하며, 해당 클래스의 모든 인스턴스가 값을 공유
  - static 메소드 : 인스턴스 생성 없이 호출 가능하기 때문에 내부에 인스턴스 멤버 변수를 사용할 수 없음

`final`  
- final 클래스 : 다른 클래스에서 해당 클래스를 상속받을 수 없음  
- final 메소드 : 오버라이딩 불가능
- final 변수 (멤버변수, 지역변수) : 변경이 불가능한 상수로 선언

>생성자를 이용한 final 멤버 변수 초기화   
>: 인스턴스 변수의 경우, 생성자 초기화를 할 수 있는데 final로 선언되어 값의 변경이 불가능한 인스턴스 변수 또한 생성자를 이용해 초기화할 수 있다. 이렇게 하면 각 인스턴스마다 final 맴버 변수의 값을 다르게 설정 가능하다. 

`abstract`  
'미완성'의 의미를 가진다. 클래스와 메소드에 붙여서 선언부만 작성된 추상 메소드와 추상 클래스를 선언할 수 있다. 

추상 클래스는 미완성 클래스이므로 인스턴스를 생성할 수는 없지만, 상속을 받은 후 원하는 메소드만 오버라이딩할 수 있다는 장점이 있다.  

하지만 interface에 default method 기능이 추가되면서 추상 클래스의 활용도는 많이 줄어드는 추세이다. 추후에 interface 관련 포스트에서 더 자세히 다루겠다. 

`transient`   
변수 또는 메소드가 포함된 객체를 직렬화할 때 해당 내용은 무시된다.  

`synchronized`  
해당 메소드는 한 번에 하나의 스레드만 접근 가능하다.  

`volatile`  
해당 변수의 조작에 CPU 캐시가 사용되지 않고 항상 메인 메모리로부터 읽힌다.

#### **클래스 정의**
```java
접근제어자 class 클래스이름 {
    접근제어자 필드1의타입 필드1의이름;
    접근제어자 필드2의타입 필드2의이름;
    ...
    접근제어자 메소드1의 원형
    접근제어자 메소드2의 원형
    ...
}
```
클래스는 위와 같은 구조로 정의한다. `class` 키워드를 이용해 정의하고, 클래스명은 대문자로 시작하는 카멜케이스를 사용한다.  

하나의 파일 안에 여러 개의 클래스를 정의할 수 있지만 public 접근제어자는 단 하나만 허용한다.  

<br>

### **객체 만드는 방법 (new 키워드 이해하기)**

new 키워드는 객체를 생성해주는 역할을 한다. 자바의 대표적인 객체는 배열과 클래스의 인스턴스이다.   

Heap 영역에 객체를 위한 메모리 공간을 할당받고, 그 공간의 참조값(reference value/해시코드)을 객체에게 반환하여 주고 이어서 생성자를 호출한다.  

인스턴스를 핸들하기 위해서는 new 키워드를 통해 참조값을 저장한 객체로만 접근이 가능하다. 

이렇게 만들어진 인스턴스는 똑같은 값을 가진 또 다른 인스턴스가 있어도 서로 다른 메모리 주소를 참조하기 때문에 서로 다른 객체로 분류된다.  

```java
System.out.println(System.identityHashCode(new String("hello")));
System.out.println(System.identityHashCode(new String("hello")));
```
```console
1829164700
2018699554
```

그에 반해 리터럴은 값이 같으면 같은 메모리 주소를 반환한다. 이러한 점이 리터럴과 new 키워드의 차이점이라고 볼 수 있다.
```java
System.out.println(System.identityHashCode("hello"));
System.out.println(System.identityHashCode("hello"));
```
```console
1829164700
1829164700
```

<br>

### **메소드 정의하는 방법**

메소드는 클래스의 동작(행동)을 나타내기 위한 일종의 함수이다. 메소드를 사용함으로써 코드의 가독성을 높이고 재사용성을 높일 수 있다. 
> public static void main(String[] args) { }  
> main 메소드는 특별한 메소드로, 프로그램이 시작되면 JVM에 의해 자동으로 호출된다.  

```java
접근 제어자  반환타입  메소드 이름(매개변수 목록){
    ...
}
```

메소드의 요소 중 메소드 이름과 매개변수 목록을 합쳐서 `메소드 시그니처`라고 한다. 

**메소드 오버로딩**  
자바에서는 메소드를 메소드 시그니처를 통해 구별할 수 있기 때문에 method overloading 기능을 지원한다.  

따라서 같은 이름의 메소드라도 파라미터 타입이 다르거나, 파라미터의 개수가 다르면 오버로딩할 수 있다.  

단, 메소드의 반환타입은 메소드 시그니처가 아니기 때문에 반환타입만 다른 경우 오버로딩이 아니므로 주의해야 한다.  

> 참고로 표준 출력을 위해 사용하는 System.out.println() 또한 객체의 메소드이다.  
> System : 표준 입출력, 에러 출력 기능을 가진 final 클래스이다. new 키워드를 통해 객체를 생성할 수 없으므로 public 생성자가 없다고 추측할 수 있다.  
> System.out : PrintStream의 인스턴스   
> System.out.println : PrintStream의 메소드로, 넘겨받은 인자를 출력한다.  

<br>

### **생성자 정의하는 방법**




<!-- inner class 쓰면 결과로 class 파일이 두 개 생김  

Reflection -->