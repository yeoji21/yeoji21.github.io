---
title: "[도서] 객체지향의 사실과 오해 "
author: "yeoji21"
date: '2021-09-02 03:35:00 +0900'
categories: [Book, Review]
# tags: [java, java study, 자바, 자바 스터디]
---

<img src="http://image.yes24.com/momo/TopCate511/MidCate005/51040273.jpg">

## 후기

이 책은 내가 존경하는 개발자 선배님들이 많이 추천해주셨기도 하고, 자바를 기초부터 다시 공부하고 있었던 나로서는 꼭 읽고싶었던 책이기에 망설임 없이 구매했다.

책을 직접 읽어보니 왜 많은 분들이 추천했는지 알 수 있었다. 책장을 넘길 때마다 내가 가지고있던 객체지향에 대한 개념들이 잘못되었다는 것을 알게되어 지루할 틈이 없었고, 조영호님이 내 머릿속을 꿰뚫고 있는 것 같아 신기했다.

내 생각이지만 이 책은 개발을 처음 시작하는 왕초보 보다는, 객체지향 언어를 어느정도 사용하면서 삽질?을 해본 사람이 읽으면 더 느낀 점이 많을 것 같다. 아무생각 없이 사용하던 클래스와 객체들 간의 역할, 책임, 협력 등에 대해 알게되니, 내가 지금까지 객체지향을 객체지향답게 사용하지 못하고 있었다는 걸 느꼈다. 

소설책을 읽듯이 부담없이 1회독을 했고, 이제 2회독을 하면서 책의 중요한 개념들을 정리해보려고 한다. 핵심적인 부분들만 간략하게 기록해두는 용도일뿐, 이 책의 설명을 대체할 수는 없기때문에 관심이 있는 독자는 꼭 읽어볼 것을 추천한다.

## 정리

### **01. 협력하는 객체들의 공동체**

"객체지향이란 실세계를 직접적이고 직관적으로 모델링할 수 있는 패러다임" 이란 문구는 객체지향의 철학적인 개념을 설명하는 데는 적합하지만, 객체지향의 분석과 설계를 설명하기에는 적합하지 않다.

객체지향의 목표는 실세계를 모방하는 것이 아닌, 새로운 세계를 창조하는 것이다. 

#### 역할, 책임, 협력
객체들은 특정한 목표를 이루기 위해 서로 협력한다.  

협력의 핵심은 특정한 책임을 수행하는 역할들 간의 연쇄적인 요청과 응답을 통해 목표를 달성한다는 것이다. 

목표는 더 작은 책임으로 분할되고 책임을 수행할 수 있는 적절한 역할을 가진 객체에 의해 수행된다. 객체지향의 설계는 적절한 객체에게 적절한 책임을 할당하는 것에서 시작한다.

##### 협력 속에 사는 객체
협력 공동체의 일원으로서 객체는 두 가지 덕목을 갖춰야 한다. 

1. 객체는 충분히 협력적이어야 한다.  
    다른 객체의 요청을 듣고, 다른 객체에게 도움을 요청할 수 있어야 한다. 
2. 객체는 충분히 자율적이어야 한다.  
    객체는 서로 협력하지만, 스스로의 결정과 판단에 따라 행동하는 자율적인 존재이다. 

##### 상태와 행동을 함께 지닌 자율적인 객체
객체가 협력에 참여하는 과정 속에서 스스로 판단하고 결정하기 위해서는 필요한 `행동(behavior)`과 `상태(state)`를 가져야 한다.

객체의 자율성은 내부와 외부를 명확하게 구분하는 것에서 출발한다.  

객체의 외부에서는 접근이 허락된 수단을 통해서만 의사소통 해야한다. 따라서 객체는 다른 객체가 무엇(what)을 하는지는 알 수 있지만, 어떻게(how) 하는지는 알 수 없다.  

#### 객체지향의 본질
- 객체지향이란 시스템을 상호작용하는 **자율적인 객체들의 공동체**로 바라보고 객체를 이용해 시스템을 분할하는 방법이다. 
- 자율적인 객체란 **상태**와 **행위**를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미한다.
- 객체는 시스템의 행위를 구현하기 위해 다른 객체와 **협력**한다. 각 객체는 협력 내에서 정해진 **역할**을 수행하며, 역할은 관련된 **책임**의 집합이다.
- 객체는 다른 객체와 협력하기 위해 **메시지**를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는데 적합한 **메소드**를 자율적으로 선택한다. 

##### 객체를 지향하라. 
클래스가 객체지향 언어에서 중요한 구성요소인 것은 맞지만, 그 중요도가 부풀려진 감이 있다. 지나치게 클래스 중심적인 관점은 객체의 캡슐화를 저해하고 클래스를 서로 강하게 결합시킨다. 

중요한 것은 '어떤 클래스가 필요한가'가 아니라 '어떤 객체들이 어떤 메시지를 주고받으며 협력하는가'이다. 클래스의 구조와 메소드가 아니라, 객체의 역할, 책임, 협력에 집중하라. 객체지향은 객체를 지향하는 것이지 클래스를 지향하는 것이 아니다. 

### **02. 이상한 나라의 객체**

#### 객체, 그리고 소프트웨어 나라

객체란, 식별 가능한 개체 또는 사물이다. 객체는 자동차처럼 만질 수 있는 구체적인 사물일 수도 있고, 시간처럼 추상적인 개념일 수도 있다. 객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가진다. 소프트웨어 안에서 객체는 저장된 상태와 실행가능한 코드를 통해 구현된다.  

##### 상태
왜 상태가 필요한가?

객체가 주변 환경과의 상호작용에 어떻게 반응하는가는 그 시점까지 객체에 어떤 일이 발생했느냐에 좌우된다. 상태를 이용하면 과거의 모든 행동 이력을 설명하지 않고도 행동의 결과를 쉽게 예측하고 설명할 수 있다.  

```
상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로, 객체의 구조적 특징을 표현한다. 
객체의 상태를 구성하는 모든 특징을 통틀어 객체의 프로퍼티(property)라고 하는데, 
프로퍼티에서 객체를 구성하는 단순한 값을 속성(attribute), 다른 객체를 참조하는 연결을 링크(link)라고 한다.
```

##### 행동
객체의 상태는 저절로 변경되지 않는다. 객체의 상태를 변경하는 것은 객체의 자발적인 **행동**뿐이다.  

따라서, 객체의 행동은 객체의 상태를 변경시키지만 행동의 결과는 객체의 상태에 의존적이다. 

```
행동이란, 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다. 
행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 메시지를 전달할 수 있다.  
객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야 한다.
```

**상태 캡슐화**  
객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다. 객체가 외부에 노출하는 것은 행동뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동뿐이다.

객체의 행동을 유발하는 것은 외부로부터의 메시지이지만, 객체의 상태를 변경할지 말지는 객체 스스로가 결정한다. 

따라서 상태를 외부에 노출시키지 않고 행동을 경계로 캡슐화하는 것은 결과적으로 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다.  

##### 식별자
```
식별자란, 어떤 객체를 다른 객체와 구분하는데 사용하는 객체의 프로퍼티다.
값(value)은 식별자를 가지지 않기 때문에 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교하고 
객체(object)는 상태가 변경될 수 있으므로 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교한다.
```

#### 행동이 상태를 결정한다
객체지향에서 가장 쉽게 빠지는 함정은 상태를 중심으로 객체를 바라보는 것이다. 상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 끼친다.  

객체는 다른 객체와 협력하기 위해 존재하고, 객체의 행동은 객체가 협력에 참여하는 유일한 방법이다. 따라서 객체가 적합한지를 결정하는 것은 그 객체의 상태가 아니라 행동이다.  

객체지향 설계는 애플리케이션에 필요한 협력을 생각하고, 협력에 필요한 행동을 생각한 후, 행동을 수행할 객체를 선택하는 방식으로 수행된다.  행동을 결정한 후에야 행동에 필요한 상태가 결정된다. 따라서 먼저 객체의 행동을 결정하고 그 후에 행동에 적절한 상태를 선택해야 한다.

#### 은유와 객체
소프트웨어 안에 구축되는 객체지향 세계는 현실의 모습을 조금 참조할 뿐, 현실을 모방한 것이 아니다. 또한 객체지향의 세계는 현실의 추상화가 아니다. 오히려 현실 속의 객체보다 더 많은 특징과 능력을 보유하는 경우가 많다.

그렇다면 객체지향의 세계와 현실 세계 사이에는 전혀 상관이 없는가? 그렇지는 않다. 현실 세계와 객체지향 세계 사이의 관계를 좀 더 정확하게 설명할 수 있는 단어는 `은유(metaphor)`이다.  

현실 속의 객체의 의미 일부가 소프트웨어 객체로 전달되기 때문에 프로그램 내의 객체는 현실 속의 객체에 대한 은유다. 은유 관계에 있는 실제 객체의 이름을 소프트웨어 객체의 이름으로 사용하면 표현적 차이를 줄여 소프트웨어의 구조를 쉽게 예측할 수 있다. 

### **03. 타입과 추상화**

#### 추상화를 통한 복잡성 극복
```
추상화란, 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 
생략하거나 감춤으로써 복잡도를 극복하는 방법이다. 복잡성을 다루기 위해 추상화는 두 차원에서 이루어진다.

1. 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화
2. 중요한 부분을 강조하기 위해 불필요한 세부사항을 제거함으로써 단순화 

모든 경우에 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화하는 것이라는 점을 기억하라
```

#### 타입
```
타입이란, 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의미한다.
어떤 객체에 타입을 적용할 수 있을 때, 그 객체를 타입의 인스턴스라고 한다.
```

##### 객체와 타입
어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다. 어떤 객체들이 동일한 행동을 수행할 수 있다면, 그 객체들은 동일한 타입으로 분류될 수 있다. 이 때, 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다.

따라서 객체의 내부 표현 방식이 다르더라도 동일하게 행동한다면 그 객체들은 동일한 타입에 속한다. 결과적으로 동일한 책임을 수행하는 일련의 객체는 동일한 타입에 속한다고 말할 수 있다.  

동일한 책임이란, 동일한 메시지 수신을 의미한다. 따라서 동일한 타입에 속한 객체는 내부의 데이터 표현 방식이 다르더라도 동일한 메시지를 수신하고 이를 처리할 수 있다. 이것은 `다형성`에 의미를 부여한다. 

데이터의 내부 표현 방식과 무관하게 행동만이 고려 대상이라는 사실은 외부에 데이터를 감춰야 한다는 것을 의미한다. 따라서 훌륭한 객체지향 설계는 외부에 행동만을 제공하고 데이터는 행동 뒤로 감춰야 한다. 이 원칙을 `캡슐화`라고 한다. 

공용 인터페이스 뒤로 데이터를 캡슐화하라는 오래된 격언은 객체를 행동에 따라 분류하기 위해 지켜야하는 기본적인 원칙이다.

그래서 결국 타입은 추상화다. 타입을 이용하면 객체의 동적인 특성을 추상화할 수 있다. 결국 타입은 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수 있는 효과적인 방법이다. 

### **04. 역할, 책임, 협력**
객체의 모양을 빚는 것은 객체가 참여하는 협력이다. 어떤 협력에 참여하는지가 객체에 필요한 행동을 결정하고, 필요한 행동이 상태를 결정한다. 개별적인 객체의 행동이나 상태가 아니라 객체들 간의 협력에 집중하라. 

역할은 협력 내에서 다른 객체로 대체할 수 있음을 나타내는 일종의 표식이다. 역할을 이용해 협력을 추상화하면, 역할을 수행할 수 있는 어떤 객체라도 협력에 참여할 수 있는 것이다. 이 때 역할을 수행할 수 있는 객체는 동일한 메시지를 이해할 수 있는 객체로 한정된다.  

역할의 개념을 사용하면 유사한 협력을 추상화해서 인지 과부하를 줄일 수 있다. 또한 다양한 객체들이 협력에 참여할 수 있기 때문에 협력이 좀 더 유연해지며 재사용성이 높아진다. 

#### 객체의 모양을 결정하는 협력
많은 사람들은 시스템에 필요한 데이터를 저장하기 위해 객체가 존재한다는 선입견을 가지고있다. 데이터는 단지 객체가 행위를 수행하는 데 필요한 재료일 뿐이고, 객체가 존재하는 이유는 행위를 수행하며 협력에 참여하기 위해서다.

객체의 행위에 초점을 맞추기 위해서는 협력이라는 실행 문맥 안에서 책임을 분배해야 한다. 각 객체가 가져야 하는 상태와 행위에 대해 고민하기 전에 그 객체가 참여할 문맥인 협력을 정의하라. 

### **05. 책임과 메시지**

#### 자율적인 책임
객체지향 공동체를 구성하는 기본적인 단위는 `자율적인` 객체다. 자율적인 객체란 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체다. 

객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문이다. 이때 요청을 처리하기 위해 객체가 수행하는 행동을 책임이라고 한다. 따라서 자율적인 객체란 스스로의 의지와 판단에 따라 각자 맡은 책임을 수행하는 객체를 의미한다. 

##### 다형성
다형성이란, 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미한다. 좀 더 구체적으로 말하면, 서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메소드를 이용해서 메시지를 처리할 수 있는 메커니즘을 가리킨다.  

다형성은 역할, 책임, 협력과 깊은 관련이 있다. 서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미한다. 

기본적으로 다형성은 동일한 역할을 수행할 수 있는 객체들 사이의 대체 가능성을 의미한다. 메시지 송신자의 관점에서 동일한 역할을 수행하는 다양한 타입의 객체와 협력할 수 있게하기 때문이다.

다형성은 객체들의 대체 가능성을 이용하여 송신자와 수신자 간의 객체 타입에 대한 결합도를 메시지에 대한 결합도로 낮춤으로써, 설계를 유연하고 재사용 가능하게 만든다. 

#### 메시지를 따라라
클래스 기반의 객체지향 언어를 사용하는 대부분의 사람들은 객체지향 애플리케이션을 클래스의 집합으로 생각한다. 많은 객체지향 책에서는 클래스를 선언하고 속성과 메소드를 정의하는 방법에 초점을 맞추고, 대부분의 입문자들은 클래스 간의 상속 관계가 객체지향 설계를 가치있게 만드는 핵심 매커니즘이라고 배운다.  

클래스는 단지 동적인 객체들의 특성과 행위를 정적인 텍스트로 표현하기 위해 사용할 수 있는 추상화 도구일 뿐, 중요한 것은 클래스가 아니라 객체다. 

클래스를 중심에 두는 설계는 유연하지 못하고 확장하기 어렵다. 객체지향 패러다임으로의 전환은 시스템을 정적인 클래스들의 집합이 아니라 메시지를 주고받는 동적인 객체들의 집합으로 바라보는 것에서 시작된다.  

객체 자체에 초점을 맞출 경우, 가장 흔하게 범하는 실수는 협력이라는 문맥을 배제한 채 객체 내부의 데이터 구조를 먼저 생각한 후 데이터 조작에 필요한 오퍼레이션을 나중에 고려하는 것이다. 

데이터에 대한 결정을 뒤로 미루고, 객체의 행위를 먼저 고려하기 위해서는 객체를 독립된 단위가 아니라 협력이라는 문맥 안에서 생각해야 한다. 결국 객체가 존재하는 중요한 이유는 객체가 다른 객체가 필요로 하는 행위를 제공하기 때문이다. 

훌륭한 객체지향 설계는 어떤 객체가 어떤 메시지를 전송할 수 있는가와, 어떤 객체가 어떤 메시지를 이해할 수 있는가를 중심으로 객체 사이의 협력 관계를 구성하는 것이다. 

#### 객체 인터페이스

객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지 전송이다. 따라서 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성되며 객체가 어떤 메시지를 수신할 수 있는 지가 객체가 제공하는 인터페이스의 모양을 빚는다. 


### **06. 객체 지도**
객체지향 세계를 구축하기 위해서는 사용자에게 제공할 기능과 기능을 담을 안정적인 구조라는 재료가 준비되어야 한다. 일반적으로 기능을 수집하고 표현하기 위한 기법은 `유스케이스 모델링`이라고 하고, 구조를 수집하고 표현하기 위한 기법은 `도메인 모델링`이라고 한다.  

#### 안정적인 재료 : 구조

도메인 모델에서 사용자가 프로그램을 사용하는 대상 분야를 도메인이라고 하고, 모델이란 대상을 단순화해서 표현한 것이다. 따라서 도메인과 모델의 정의를 연결하면 도메인 모델을 쉽게 정의할 수 있다.  

`도메인 모델`이란, 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다. 따라서 도메인 모델은 소프트웨어가 목적하는 영역 내의 개념과 개념간의 관계, 다양한 규칙이나 제약 등을 주의 깊게 추상화한 것으로, 소프트웨어 개발과 관련된 이해관계자들이 도메인에 대해 생각하는 관점이다.

#### 불안정한 재료 : 기능

사용자는 자신의 목표를 달성하기 위해 시스템과의 상호작용을 시작한다. 사용자가 시스템에게 작업을 요청하면 시스템은 요청을 처리한 후 사용자에게 원하는 결과를 제공한다. 이러한 작업을 반복하는 상호작용을 통해서 서비스는 사용자의 목표를 만족시키기 위해 노력한다.  

이처럼 사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상호작용의 흐름을 텍스트로 정리한 것을 `유스케이스`라고 한다. 

유스케이스를 통해 사용자들의 목표를 중심으로 시스템의 기능적인 요구사항들을 이야기 형식으로 묶을 수 있다. 산발적으로 흩어져 있는 기능에 사용자 목표라는 문맥을 제공함으로써 각 기능이 유기적인 관계를 지닌 체계를 이룰 수 있게 한다.

이러한 유스케이스는 설계 기법도, 객체지향 기법도 아니다. 단지 기능적 요구사항을 사용자의 목표라는 문맥을 중심으로 묶기 위한 정리 기법일 뿐이다. 따라서 유스 케이스 텍스트 안에서 도메인 모델을 위한 힌트 정도는 얻을 수 있어도, 도메인 모델을 구축할 수 있는 모든 정보가 포함되어 있는 것은 아니다. 

#### 재료 합치기 : 기능과 구조의 통합

불안정한 기능을 안정적인 구조 안에 담음으로써 변경에 대한 파급효과를 최소화하는 것은 훌륭한 객체지향 설계자가 갖춰야 할 기본적인 설계 능력이다.  

도메인 모델은 안정적인 구조를 개념화하기 위해, 유스케이스는 불안정한 기능을 서술하기 위해 가장 일반적으로 사용되는 도구다. 변경에 유연한 소프트웨어를 만들기 위해서는 유스케이스에 정리된 시스템의 기능을 도메인 모델을 기반으로 한 객체들의 책임으로 분베해야 한다.

##### 기능 변경을 흡수하는 안정적인 구조
도메인 모델을 기반으로 객체 구조를 설계하는 이유는 도메인 모델이 안정적이기 때문이다. 도메인 모델을 구성하는 개념은 비즈니스가 없어지거나 완전히 개편되지 않는 한 안정적으로 유지된다. 또한 도메인 모델을 구성하는 개념 간의 관계는 비즈니스 규칙을 기반으로 하기 때문에 비즈니스 정책이 크게 변경되지 않는 한 안정적으로 유지된다.  

도메인 모델의 이같은 특징은 도메인 모델을 중심으로 객체 구조를 설계하고 유스케이스의 기능을 객체의 책임으로 분배하는 기본적인 객체지향 설계 방식의 유연함을 잘 보여준다. 

안정적인 도메인 모델을 기반으로 시스템의 기능을 구현할 경우, 시스템의 기능이 변경되더라도 비즈니스의 핵심 정책이나 규칙이 변경되지 않는 한 전체적인 구조가 한 번에 흔들리지는 않는다. 이것이 일반적으로 객체지향이 기능 변경에 좀 더 유연하게 대응할 수 있는 이유다.


### **07. 함께 모으기**
마틴 파울러는 객체지향 설계 안에 존재하는 세 가지 상호 연관된 관점에 관해 설명한다. 파울러는 세 가지 관점을 각각 개념 관점, 명세 관점, 구현 관점이라고 부른다.

**개념 관점(Conceptual Perspective)** 에서 설계는 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다. 도메인이란, 사용자들이 관심을 가지고 있는 특정 분야나 주제를 말하며 소프트웨어는 도메인에 존재하는 문제를 해결하기 위해 개발된다. 

**명세 관점(Specification Perspective)** 에 이르면 사용자의 영역인 도메인을 벗어나 개발자의 영역인 소프트웨어로 초점이 옮겨진다. 명세 관점은 도메인의 개념이 아니라 실제로 소프트웨어 내에 객체들의 책임에 초점을 맞춘다. 

명세 관점에서 프로그래머는 객체가 협력을 위해 '무엇'을 할 수 있는가에 초점을 맞춘다. 인터페이스와 구현을 분리하는 것은 훌륭한 객체지향 설계를 낳는 가장 기본적인 원칙이라는 점을 기억하라. 

**구현 관점(Implementation Perspective)** 은 실제 작업을 수행하는 코드와 연관되어 있다. 구현 관점의 초점은 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것이다. 

이 세 가지 관점이 소프트웨어를 개발하는 순서를 의미하는 것은 아니고, 개념 관점, 명세 관점, 구현 관점은 동일한 클래스를 세 가지 다른 방향에서 바라보는 것을 의미한다. 

마틴 파울러는 개념적인 관점과 명세 관점 사이는 그렇게 중요하지 않은 경우가 많지만, 명세 관점과 구현 관점을 분리하는 것은 매우 중요하다고 주장한다. 실제로 훌륭한 설계를 결정하는 측면은 명세 관점인 객체의 인터페이스다. 명세 관점이 설계를 주도하게 하면 설계의 품질이 향상될 수 있다는 사실을 기억하라. 

중요한 것은 클래스를 명세 관점과 구현 관점으로 나누어서 파악할 수 있어야 한다는 것이다. 구현을 인터페이스 밖으로 노출해서도 안되고, 인터페이스와 구현을 흐릿하게 섞어놓아서도 안된다. 결국 세 가지 관점 모두에서 클래스를 바라볼 수 있으려면 훌륭한 설계가 뒷받침 되어야 한다.

## 2회독 후기

이 책은 대부분의 내용이 실제 코드보다는 객체지향에 대한 개념을 설명하기때문에 1회독을 할 때는 소설책을 읽듯이 슥슥 넘기면서 봤다.  책의 전체 내용을 파악하기 위해서 일단은 완벽히 이해가 가지 않는 부분이 있어도 그냥 넘어가면서 스트레스 받지 않고 완독을 하는 것에 목표를 두었다. 

그림이나 예제 등을 활용해 쉽게 풀어 설명하는 책이라서 1회독을 할 때도 크게 어려운 부분은 없었으나, 6장에서 도메인 모델과 유스케이스에 대한 부분은 이해를 못하고 넘어갔었는데, 이번에 2회독을 할때는 핵심 내용을 정리하면서 읽으니 책의 전체 흐름이 보이고 내용을 완전히 이해할 수 있게 된 것 같다.

2회독을 할 때는 1회독에서는 안보이던 몇몇 포인트가 느껴졌고, 개인 프로젝트를 하면서 삽질하던 경험 ~~PTSD~~ 이 떠올랐다. 내가 가지고있던 객체지향에 대한 선입견과 잘못된 이해를 완전히 깨부셔준 조영호님께 감사하고, 객체지향 언어를 사용하는 개발자라면 꼭 읽어볼 것을 추천한다!!

개인적으로, 지금 읽고있는 TDD책을 완독하면 조영호님이 이 책의 후속작으로 쓰신 오브젝트라는 책도 구입할 예정인데, 이 책도 많이 기대된다.
