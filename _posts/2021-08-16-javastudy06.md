---
title: "백기선님과 함께 하는 자바 스터디 - 06"
author: "yeoji21"
date: 2021-08-16
categories: [Backend, Java]
tags: [java, java study, 자바, 자바 스터디]
pin: true
---

<img src="https://media.vlpt.us/images/inhalin/post/b48b4cd3-619b-4bf4-939c-d3546dd2ec01/whiteship.png">

## 들어가면서
백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다.  
강의 영상 링크 : [[자바 라이브 스터디] 2020/12/26, 6주차 상속
](https://www.youtube.com/watch?v=Gh7V06ero3c&list=PLfI752FpVCS96fSsQe2E3HzYTgdmbz6LU&index=12)  
강의 깃허브 링크 : [6주차 과제: 상속](https://github.com/whiteship/live-study/issues/6)

## 목차
- 자바 상속의 특징
- super 키워드
- 메소드 오버라이딩
- 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
- 추상 클래스
- final 키워드
- Object 클래스


### **자바 상속의 특징**

#### 상속이란?
상속(Inheritance)란, 부모 클래스의 변수와 메소드를 물려받는 것을 말한다. 자식 클래스가 부모 클래스의 속성을 물려받아 같이 공유하며 나아가 확장하는 개념이다.  

> 이 때 부모 클래스를 super class 또는 base class라고 부르고 자식 클래스를 sub class, derived class라고 부른다. 

부모 클래스에서 가지고 있는 속성을 상속받아 자식 클래스를 확장하기 때문에 자바에서는 상속의 키워드로 `extends`를 사용한다.  

상속을 사용함으로써 코드의 중복을 막고 공통적인 코드의 수정 시간을 줄일 수 있기 때문에 유지 보수성이 높고, 클래스 간의 계층구조가 생겨 클래스의 분류 및 관리가 쉽고 클래스의 특성이 명확해진다.  

#### 상속의 특징  
1. 자바의 모든 클래스는 `Object` 클래스의 자식 클래스다.
2. 생성자와 초기화 블록은 클래스의 멤버가 아니기 때문에 자식 클래스에게 상속되지 않음
3. 다중 상속을 지원하지 않는다. `extends` 키워드 뒤에는 하나의 부모 클래스만 올 수 있다.
    ```java
    class Digimon extends Digital, Monster{
        // ERROR
    }
    ```
4. 부모 클래스의 메소드를 자식 클래스에서 재정의 즉, **오버라이딩** 가능  
    부모 클래스의 모든 메소드가 자식 클래스에 맞게 설계되어있지 않기 때문에 자식 클래스에서 메소드를 수정해서 사용할 수 있는 오버라이딩(Overriding) 기능을 제공함

    ~~5. 부모 클래스에서 `private` 접근 제한자를 가진 멤버는 상속 불가능~~

5. 부모 클래스의 private 메소드는 상속되지 않는 것이 맞으나, private 멤버 변수는 상속은 되지만 접근이 불가능한 것이다.  
    이런 경우 부모 클래스에 Getter를 생성하면 Getter는 상속되기 때문에 자식 클래스에서 부모 클래스의 private 멤버 변수에 접근할 수 있다.  

6. `final` 클래스는 상속이 불가능하고, final 메소드는 오버라이딩 불가능

7. `static` 메소드 또는 변수도 상속된다. 다만, static 메소드는 오버라이딩이 허용되지 않는다.  
    이 부분은 밑에 메소드 오버라이딩 파트에서 다시 다루겠다.

8. 부모 클래스와 자식 클래스에 동일한 이름의 멤버변수가 존재할 경우, 부모 클래스의 멤버변수가 가려진다.  


### **super 키워드**
`super` 키워드는 부모 클래스로부터 상속받은 멤버변수나 메소드를 자식 클래스에서 참조하는데 사용하는 참조변수이다.  

인스턴스 변수와 지역변수의 이름이 같을 때, `this` 키워드를 통해 구분할 수 있는 것처럼 부모 클래스와 자식 클래스의 관계에서는 `super` 키워드를 사용할 수 있다.  

`super.멤버변수`, `super.멤버메소드(매개변수)`를 통해 부모 클래스의 멤버에 접근할 수 있고, `super()`를 통해 부모 클래스의 생성자를 호출 가능하다. 

이 중 가장 중요한 것은 생성자를 호출하는 기능이라고 생각되는데, 그 이유를 살펴보자.  

#### super() 부모 클래스의 생성자 호출

자식 클래스의 인스턴스를 생성하면, 해당 인스턴스에는 자식 클래스의 고유 멤버뿐 아니라 부모 클래스의 멤버까지 포함되어 있다.  

따라서 부모 클래스의 멤버를 초기화하기 위해서는 자식 클래스의 생성자를 호출할 때, 부모 클래스의 생성자까지 함께 호출해야 한다.  
> 이러한 작업은 Object 클래스의 생성자까지 거슬러 올라가며 수행된다.  

하지만, 생성자는 클래스의 멤버가 아니기 때문에 자식 클래스에 상속되지 않는다. 그렇기 때문에 자식 클래스의 생성자에서 `super` 키워드를 사용하여 부모 클래스의 생성자를 호출해야만 한다.  

하지만 생성자를 만들 때마다 매번 똑같은 super 키워드를 추가하는 것은 귀찮을 뿐더러 빼먹는 실수를 할 수도 있다.  

그래서 자바에서는 생성자에 내부적으로 맨 첫줄에 `super();`를 추가해준다. 이로 인해서 자식 클래스의 생성자를 호출하면 항상 부모 클래스의 기본 생성자가 먼저 호출된다.  

그런데 이 때 만약, 부모 클래스의 생성자 중에 기본 생성자가 없고 매개변수를 갖는 생성자만 있다면 오류가 발생한다.  

```java
Class Monster{
    int hp;
    public Monster(int hp){
        this.hp = hp;
    }
}

Class Digimon extends Monster{}

...

Digimon a = new Digimon();
```

```console
java: constructor Person in class com.example.javastudy.week6.Person cannot be applied to given types;
  required: int
  found: no arguments
  reason: actual and formal argument lists differ in length
```

Digimon 클래스의 기본 생성자가 호출되면서 `super();`가 실행되었는데, Monster 클래스에는 기본 생성자가 없으므로 에러가 발생하는 것을 알 수 있다.  

따라서 이런 경우, 자식 생성자에서 **명시적으로** 부모 생성자를 호출해야 한다. 이 때 사용되는 키워드가 `super()`이고, 부모 생성자의 파라미터를 함께 넘기면 된다.  

```java
Class Digimon extends Monster{
    public Digimon(){
        super(100);     //Digimon 클래스 인스턴스의 hp의 값으로 100이 저장됨
    }
}
```

부모 클래스의 생성자를 호출하는 용도로 `super` 키워드를 사용할 때 주의해야할 점은 반드시 자식 클래스의 생성자 내부에 사용해야 한다는 것과, 항상 생성자의 맨 첫줄에 사용해야 한다는 점이다.  

### **메소드 오버라이딩**