---
title: "백기선님 자바 스터디 - 02 - 작성중"
author: "yeoji21"
date: 2021-08-09
categories: [Backend, Java]
tags: [java, java study, 자바, 자바 스터디]
pin: true
---
<img src="https://media.vlpt.us/images/inhalin/post/b48b4cd3-619b-4bf4-939c-d3546dd2ec01/whiteship.png">

## 들어가면서
백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다.  
강의 링크 : [[자바 뉴스 라이브] 2020/11/21, 자바 스터디 2주차](https://www.youtube.com/watch?v=xoHDRclHojM&list=PLfI752FpVCS96fSsQe2E3HzYTgdmbz6LU&index=3)  
깃허브 링크 : [2주차 과제: 자바 데이터 타입, 변수 그리고 배열](https://github.com/whiteship/live-study/issues/2)

## 목차
- 프리미티브 타입 종류와 값의 범위 그리고 기본 값
- 프리미티브 타입과 레퍼런스 타입
- 리터럴
- 변수 선언 및 초기화하는 방법
- 변수의 스코프와 라이프타임
- 타입 변환, 캐스팅 그리고 타입 프로모션
- 1차 및 2차 배열 선언하기
- 타입 추론, var


### **프리미티브 타입 종류와 값의 범위 그리고 기본 값**  
Primitive Type이란 기본 자료형 또는 원시 자료형이라고도 불리며, 값을 할당할 때 변수의 주소값에 값이 그 자체로 저장되는 데이터 타입이다.  

Primitive Type은 기본값이 존재하기 때문에 null이 존재하지 않고 값이 할당되면 앞 장에서 살펴본 JVM Runtime Data Area 영역 중 Stack 영역에 값이 저장된다. 만약 담을 수 있는 크기보다 큰 값을 넣으려고 하면 컴파일 에러가 발생한다.  

#### 정수형

부호를 표현한다면 첫 번째 비트는 부호를 나타나게 되어 n-1 비트로 수를 표현하게 되고, 양수에 0을 포함하기 때문에 정수형의 표현 범위는 아래와 같다.  

||타입|메모리 크기|기본값|표현범위|
|---|---|:----|--:|:--------------|
|정수형|byte| 1byte |0|-2<sup>7</sup> ~ 2 <sup>7</sup> -1|
|정수형|short| 1byte|0|-2<sup>15</sup> ~ 2 <sup>15</sup> -1|
|정수형|int (기본) | 4byte|0|-2<sup>31</sup> ~ 2 <sup>31</sup> -1|
|정수형|long| 8byte|0L|-2<sup>63</sup> ~ 2 <sup>63</sup> -1|  

<br>

#### 실수형  
실수형에서는 값을 부호, 지수, 가수로 나누어 저장한다. 따라서 같은 크기임에도 정수형보다 훨씬 큰 범위를 표현 가능하지만, 실수형은 원래 저장하려던 값과 실제 저장된 값이 오차가 발생할 수 있다.  

따라서 오차없는 자리수인 정밀도가 중요한데, 정밀도를 계산하는 방법은 가수 부분의 데이터 크기와 연관된다. 

예를 들어, float의 가수부분은 23비트인데 여기서 정규화를 통해 24까지 표현 가능하다.  
2<sup>24</sup>는 10<sup>7</sup> 보다는 크고 10<sup>8</sup> 보다는 작기 때문에 float형의 정밀도는 7이 된다.  

double의 경우, 가수부분이 52비트이기 때문에 정밀도는 15자리가 된다.

||타입|메모리 크기|기본값|표현 범위|정밀도|
|---|----|--------:|---:|---------------------|---:|
|실수형|float|4byte|0.0F|-3.4E38 ~ -1.4E-45, 1.4E-45 ~ 3.4E38|7자리|
|실수형|double (기본)|8byte|0.0|(1.7 * 10 <sup>-308</sup> ) ~ (1.7 * 10<sup>308</sup> )의 근사값|7자리|  

<br>

예를 들어, 정밀도에 매우 민감한 돈과 관련된 계산을 할 때는 long이나 float, double을 쓰면 안되고 **BigDecimal** 사용해야 한다.  

float를 사용한 코드 
```java
float number = 0f;
for(int i=0; i<10; i++){
    number += 0.1f
}
System.out.println(number);
```  

실행하면 1.0f가 나와야 하지만 결과로 1.0000001이 찍힘  

BigDecimal로 변경한 코드  
```java
BigDecimal number = BigDecimal.ZERO;
for(int i=0; i<10; i++){
    number = number.add(BigDecimal.valueOf(0.1));
}
System.out.println(number);
```