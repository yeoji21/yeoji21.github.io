<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="자바 스터디 03 - 연산자" /><meta name="author" content="yeoji21" /><meta property="og:locale" content="en" /><meta name="description" content="어서와" /><meta property="og:description" content="어서와" /><link rel="canonical" href="https://yeoji21.github.io/posts/javastudy03/" /><meta property="og:url" content="https://yeoji21.github.io/posts/javastudy03/" /><meta property="og:site_name" content="yeoji21" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-08-11T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="자바 스터디 03 - 연산자" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@yeoji21" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"yeoji21"},"dateModified":"2021-08-11T00:00:00+09:00","datePublished":"2021-08-11T00:00:00+09:00","description":"어서와","headline":"자바 스터디 03 - 연산자","mainEntityOfPage":{"@type":"WebPage","@id":"https://yeoji21.github.io/posts/javastudy03/"},"url":"https://yeoji21.github.io/posts/javastudy03/"}</script><title>자바 스터디 03 - 연산자 | yeoji21</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="yeoji21"><meta name="application-name" content="yeoji21"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR:wght@500&display=swap" rel="stylesheet"><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile/img1.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">yeoji21</a></div><div class="site-subtitle font-italic">Don't look back in anger</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/yeoji21" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['yeozone0508','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>자바 스터디 03 - 연산자</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>자바 스터디 03 - 연산자</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> yeoji21 </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Aug 11, 2021, 12:00 AM +0900" >Aug 11, 2021<i class="unloaded">2021-08-11T00:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6795 words">37 min read</span></div></div><div class="post-content"><p><img data-proofer-ignore data-src="https://media.vlpt.us/images/inhalin/post/b48b4cd3-619b-4bf4-939c-d3546dd2ec01/whiteship.png" /></p><h2 id="들어가면서">들어가면서</h2><p>백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다.<br /> 강의 영상 링크 : <a href="https://www.youtube.com/watch?v=OFf-PX81-Lc&amp;list=PLfI752FpVCS96fSsQe2E3HzYTgdmbz6LU&amp;index=5">[자바 라이브 스터디] 2020/11/28, 자바 스터디 3주차 연산자를 알아보자.</a><br /> 강의 깃허브 링크 : <a href="https://github.com/whiteship/live-study/issues/3">3주차 과제: 연산자 </a></p><h2 id="목차">목차</h2><ul><li>산술 연산자<li>비트 연산자<li>관계 연산자<li>논리 연산자<li>instanceof<li>assignment(=) operator<li>화살표(-&gt;) 연산자<li>3항 연산자<li>연산자 우선 순위<li>(optional) Java 13. switch 연산자</ul><h3 id="연산자란"><strong>연산자란?</strong></h3><p>연산자(Operator)는 연산을 수행하는 기호를 말한다. 연산자가 연산을 수행하기 위해서는 반드시 연산의 대상이 있어야 하는데, 이 것을 피연산자(Operand)라고 한다.</p><p>대부분의 연산자는 두 개의 피연산자를 필요로 하며, 하나 또는 세 개의 피연산자를 필요로 하는 연산자도 있다. <strong>연산자는 연산을 수행하고 나면 반드시 결과값을 반환한다.</strong></p><h4 id="연산자의-종류">연산자의 종류</h4><div class="table-wrapper"><table><thead><tr><th style="text-align: right">종류<th style="text-align: right">연산자<th style="text-align: right">설명<tbody><tr><td style="text-align: right">산술 연산자<td style="text-align: right">+ - * / % « »<td style="text-align: right">사칙 연산과 나머지 연산(%)<tr><td style="text-align: right">비교 연산자<td style="text-align: right">&gt; &lt; &gt;= &lt;= == !=<td style="text-align: right">크고 작음과 같고 다름을 비교<tr><td style="text-align: right">논리 연산자<td style="text-align: right">&amp;&amp; || ! &amp; | ^ ~<td style="text-align: right">AND 또는 OR으로 조건을 연결<tr><td style="text-align: right">대입 연산자<td style="text-align: right">=<td style="text-align: right">우변의 값을 좌변에 저장<tr><td style="text-align: right">기타<td style="text-align: right">(type) ?: instanceof<td style="text-align: right">형변환 연산자, 3항 연산자, instanceof 연산자</table></div><h3 id="산술-연산자"><strong>산술 연산자</strong></h3><ul><li>사칙 연산을 하는 연산자<li>boolean 타입을 제외한 모든 기본타입에 사용 가능<li><strong>피연산자들간의 타입이 일치하지 않을 경우, 피연산자들의 타입을 일치시킨 후 연산을 수행</strong><ol><li>피연산자들이 모두 정수 타입이고, int 타입보다 크기가 작은 경우<br /> -&gt; 모두 int 타입으로 변환 후 연산 수행, 결과는 int 타입<li>피연산자들이 모두 정수 타입이고, long 타입이 있을 경우<br /> -&gt; 결과는 long 타입<li>피연산자 중 실수 타입이 있을 경우<br /> -&gt; 실수 타입으로 변환 후 연산 수행, 결과는 실수 타입</ol><p>예제 코드</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>  <span class="kt">byte</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
  <span class="kt">byte</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
  <span class="kt">byte</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>         <span class="c1">//컴파일 에러 발생</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="go">  error: incompatible types: possible lossy conversion from int to byte 
</span><span class="gp">      byte c = a + b;</span><span class="w">
</span><span class="go">                 ^
</span></pre></table></code></div></div><p>위의 코드에서 에러가 발생하는 이유는 무엇일까?<br /> 1번 규칙을 보면 알 수 있는데, 변수 a 와 b는 int형 보다 작은 byte형이기 때문에 연산자 +는 두 개의 피연산자들의 자료형을 int형으로 변환한 다음 더하기 연산을 수행한다.</p><p>그 결과 <code class="language-plaintext highlighter-rouge">a+b</code>의 연산 결과는 4byte의 int형이 되고, 4byte의 값을 1byte의 byte형에 타입 캐스팅 없이 저장하려고 했기 때문에 에러가 발생한 것이다.</p><p>따라서 이 연산을 에러 없이 수행하기 위해서는 아래 두 가지 방식 중 하나로 수정해야 한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>  <span class="kt">byte</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">);</span>       <span class="c1">//명시적인 타입 캐스팅으로 해결</span>
  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>              <span class="c1">//또는 int형 변수로 결과를 받음</span>
</pre></table></code></div></div><p>오케이, 그렇다면 자바에서는 long 타입을 제외한 정수형을 연산할 시 int형으로 변환한 뒤 연산을 수행한다는 것은 알게되었다.</p><p>그렇다면 굳이 왜 int로 변환한 뒤 계산하는 것일까? 바로 <strong>JVM이 기본적으로 32bit 단위로 계산</strong>을 하기 때문이다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="o">;</span>          <span class="c1">//2</span>
  <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="o">;</span>       <span class="c1">//2.5가 아닌 2 </span>
  <span class="c1">//실수형 결과를 얻고 싶다면 피연산자 중 최소한 하나는 실수형이어야 한다. </span>
</pre></table></code></div></div><p><br /> char 타입도 정수 타입이므로 산술 연산이 가능하다.(결과는 int형) 왜냐하면 문자는 실제로 해당 문자의 유니코드(부호없는 정수)로 바뀌어 저장되므로 문자간의 사칙 연산은 정수간의 연산과 동일하기 때문이다.</p><p>문자 ‘2’를 정수 2로 변환하려면 문자 ‘0’을 빼주면 되는데 그 이유는 문자 ‘2’의 유니코드가 50이고, 문자 ‘0’의 유니코드는 48이므로 뺄셈의 결과로 2를 얻을 수 있기 때문이다.</p><p>또한 대문자와 소문자 간의 코드 값의 차이는 32만큼 나기 때문에 이 것을 이용하면 소문자를 대문자로 변경하거나 반대의 경우에도 활용할 수 있다.</p><p>문자 타입의 연산 과정을 코드로 알아보자.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>  <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="sc">'A'</span><span class="o">;</span>
  <span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> 
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="go">  error: incompatible types: possible lossy conversion from int to char
</span><span class="gp">      char b = a + 1;</span><span class="w"> 
</span><span class="go">                 ^
</span></pre></table></code></div></div><p>위 코드를 실행하면 컴파일 에러가 발생한다. char 타입은 정수 타입으로 취급되어 연산되기 때문에 연산의 결과 또한 int(4byte)인데, 결과를 char(2byte)에 담으려 해서 발생하는 오류이다.</p><p>따라서 int 타입의 결과로 char 타입을 반환받고 싶으면 타입 캐스팅을 해주어야 한다.</p><p>그렇다면 위의 코드와 아주 비슷하게 생긴 아래 코드의 실행 결과를 살펴보자.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>  <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="sc">'A'</span><span class="o">;</span>
  <span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="sc">'A'</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="go">  A
  B 
</span></pre></table></code></div></div><p>이 코드에서는 타입 캐스팅을 해주지 않았는데 왜 컴파일 에러가 발생하지 않는 것일까?<br /> 그것은 바로 <strong><code class="language-plaintext highlighter-rouge">'A'+1 </code>이 리터럴 간의 연산이기 때문</strong>이다.</p><p>상수 또는 리터럴 간의 연산은 실행과정동안 변하는 값이 아니기 때문에, 컴파일 시에 컴파일러가 결과값을 계산해서 그 결과로 대체함으로써 코드의 효율을 높이는 방식을 사용한다.</p><p>따라서 컴파일 후의 위 코드는 <code class="language-plaintext highlighter-rouge">char b = 'B';</code> 의 문장으로 변환되기 때문에 에러가 발생하지 않는 것이다.</p><li><p>산술 연산에는 단항 연산자로써 <strong>증감 연산자</strong>가 있는데, ++ 또는 -- 기호를 사용한다.<br /> 증감 연산자가 피연산자의 뒤에 붙는 후위 연산일 경우, 해당 라인을 수행하고 나서 증감 연산이 수행되고,<br /> 반대로 증감 연산자가 피연산자의 앞에 붙는 전위 연산의 경우, 해당 라인을 수행할 때 바로 증감 연산이 수행된다.</p><li>산술 연산에서의 주의점<ol><li>오버플로우 탐지<li>정확한 계산은 정수형을 사용<li>NaN과 Infinity 연산<li>입력값의 NaN 검사</ol></ul><ol><li><p>오버플로우 탐지<br /> 연산 후의 산출값이 산출 타입으로 충분히 표현 가능한지 생각해 봐야 한다.</p><p>만약 산출 타입으로 표현할 수 없는 범위의 값이 산출되었을 경우, 오버플로우가 발생하고 쓰레기값을 얻을 수 있기 때문에 주의가 필요하다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1_000_000</span><span class="o">;</span>
 <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2_000_000</span><span class="o">;</span>
 <span class="kt">long</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="o">;</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="go"> -1454759936
</span></pre></table></code></div></div><p>앞에서 배운대로 오버플로우 발생을 방지하기 위해 연산의 결과를 long 타입으로 받는 코드를 작성했다!</p><p>예상대로라면 위의 코드를 실행했을 때, 변수 c의 타입이 long으로, 저장공간이 충분히 크기 때문에 결과값으로 2000000000000이 출력될 것 같았지만, 전혀 다른 쓰레기값이 나왔다.</p><p>이 경우에 int 타입 간의 연산이기때문에 연산 결과가 int값으로 반환되었고, 그 값을 그대로 long타입으로 자동 형변환을 한 것뿐이기 때문에 결과값이 long 타입으로 변하지는 않는다.</p><p>또한 같은 의미의 식이라도 연산의 순서에 따라서 다른 결과를 얻을 수도 있다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1_000_000</span><span class="o">;</span>
 <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">/</span> <span class="n">a</span><span class="o">;</span>
 <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="o">;</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="go"> -727        //곱셈 먼저하면 오버플로우가 발생해서 쓰레기값이 담김
 1000000     //나눗셈 먼저한 결과
</span></pre></table></code></div></div><p><br /></p><p>기선님이 수업 중에 언급하신 비슷한 예제도 살펴보자. start와 end 사이의 중간값을 구하는 코드이다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre> <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">2000000000</span><span class="o">;</span>
 <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">2100000000</span><span class="o">;</span>

 <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
 <span class="c1">//이렇게 중간값을 구한다면 숫자가 큰 경우 오버플로우가 발생해서 이상한 결과가 나올 수 있다. </span>
</pre></table></code></div></div><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre> <span class="c1">//해결법 1</span>
 <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
</pre></table></code></div></div><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre> <span class="c1">//해결법 2</span>
 <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="o">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
 <span class="c1">//음수는 계산 불가능하다는 단점</span>
 <span class="c1">//이건 기교에 가깝고 웬만하면 1번 해결법을 쓰는 것을 추천</span>
</pre></table></code></div></div><li><p>정확한 계산은 정수 사용<br /> 정확하게 계산해야 할 때는 부동 소수점을 사용하는 실수 타입의 사용을 지양하자.<br /> <del>저번 챕터에서 돈 계산할 때 실수 타입을 사용하지 말자고 한게 바로 떠올랐길..</del></p><li><p>NaN과 Infinity 연산<br /> / 나 % 연산자는 좌측 피연산자가 정수 타입인 경우에, 우측 피연산자로 0을 사용할 수 없다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="mi">5</span><span class="o">/</span><span class="mi">0</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="mi">5</span><span class="o">%</span><span class="mi">0</span><span class="o">);</span>  
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="go"> Exception in thread "main" java.lang.ArithmeticException: / by zero
</span></pre></table></code></div></div><p>0으로 나누면 컴파일은 되지만, 실행 시 ArithmeticException이 발생한다. 따라서 프로그램 종료를 방지하기 위해서는 예외처리가 필요할 수 있다.</p><p>만약 실수 타입인 0.0 또는 0.0f로 나누면 ArithmeticException이 발생하지 않는다.</p><p>하지만 / 연산의 결과는 <code class="language-plaintext highlighter-rouge">Infinity</code>(무한대) 값을 가지고, % 연산의 결과는 <code class="language-plaintext highlighter-rouge">NaN</code>(Not a Number)를 가진다.</p><p>연산의 결과로 Infinity나 NaN이 나오면 그 다음부터는 어떤 연산을 수행해도 결과는 Infinity 또는 NaN에서 변하지 않기 때문에 결과값을 검사할 필요가 있을 때는 아래 두 메소드를 이용하면 된다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre> <span class="nc">Double</span><span class="o">.</span><span class="na">insInfinite</span><span class="o">()</span>
 <span class="nc">Double</span><span class="o">.</span><span class="na">isNaN</span><span class="o">()</span>
</pre></table></code></div></div><li><p>입력값의 NaN 검사<br /> 부동 소수점(실수형)을 입력받을 때는 반드시 NaN 검사를 해야 하는데, NaN 검사는 == 연산자를 통해 조사하면 안되고, <code class="language-plaintext highlighter-rouge">Double.isNaN()</code> 메소드를 사용해야 한다.</p></ol><p><br /></p><h3 id="비트-연산자"><strong>비트 연산자</strong></h3><p>비트 연산자는 피연산자를 비트단위로 논리 연산한다. 피연산자를 이진수로 표현했을 때의 각 자리를 규칙에 따라 연산을 수행하며, 피연산자로는 실수는 허용하지 않고 오직 정수(문자 포함)만 허용한다.</p><p>비트 연산자의 진리표는 아래와 같다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">x<th style="text-align: right">y<th style="text-align: right">x|y<th style="text-align: right">x&amp;y<th style="text-align: right">x^y<tbody><tr><td style="text-align: right">1<td style="text-align: right">1<td style="text-align: right">1<td style="text-align: right">1<td style="text-align: right">0<tr><td style="text-align: right">1<td style="text-align: right">0<td style="text-align: right">1<td style="text-align: right">0<td style="text-align: right">1<tr><td style="text-align: right">0<td style="text-align: right">1<td style="text-align: right">1<td style="text-align: right">0<td style="text-align: right">1<tr><td style="text-align: right">0<td style="text-align: right">0<td style="text-align: right">0<td style="text-align: right">0<td style="text-align: right">0</table></div><p><br /></p><ul><li><p>비트 보수 (Bitwise complement : ~)</p><p>이 연산자는 피연산자를 2진수로 표혔했을 때, 0을 1로 1을 0으로 바꾼다.</p><p>비트 보수 연산자에 의해 비트 전환이 일어나게 되면, 부호있는 타입의 피연산자는 부호가 반대로 변경된다. 따라서 피연산자의 <strong>1의 보수</strong>를 얻을 수 있기때문에 1의 보수 연산자라고도 한다.</p><p>비트 보수 연산자는 피연산자의 타입이 int보다 작으면 int로 자동 형변환 후에 연산하기 때문에 연산의 결과는 32비트 2진수이다.</p><blockquote><p>자바에서 제공하는 Integer.toBinaryString() 메소드를 통해 정수값을 32비트 이진 문자열로 리턴받을 수 있다.</p></blockquote><li><p>쉬프트 연산자 &lt;&lt; &gt;&gt;</p><p>쉬프트 연산자는 2진수를 오른쪽(&gt;&gt;) 또는 왼쪽(&lt;&lt;)으로 이동한다고 해서 쉬프트 연산자(shift operator)라고 한다. 왼쪽으로 비트를 한 비트씩 이동할 때마다 2가 곱해지는 것과 같고, 오른쪽으로 한 비트씩 이동할 때마다 2를 나누는 것과 같다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>          <span class="c1">//8</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="o">);</span>     <span class="c1">//2</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="o">);</span>     <span class="c1">//32</span>
</pre></table></code></div></div><p>예를 들어 8 &lt;&lt; 2는 왼쪽 피연산자인 10진수 8의 2진수(00001000)을 왼쪽으로 2자리 이동시킨다. 이 때, 자리 이동으로 저장범위를 넘어선 값들은 버려지고 오른쪽에 생긴 빈칸은 0으로 채워진다.</p><p>그런데 &gt;&gt; 연산자는 오른쪽으로 비트를 이동시키기 때문에 부호있는 정수는 부호를 유지하기 위해 왼쪽 피연산자가 양수인 경우에는 빈자리를 0으로 채우고, 음수인 경우에는 빈자리를 1로 채운다.</p><p>부호 없는 오른쪽 쉬프트 연산 (&gt;&gt;&gt;)을 사용하게 되면 피연산자의 부호와 상관없이 왼쪽 비트는 무조건 0으로 채우게 된다. 따라서 음수에 &gt;&gt;&gt; 연산을 하면 결과는 양수가 나온다</p><p>또한 쉬프트 연산자의 좌측 피연산자에는 산술 변환이 적용되어 int보다 작은 타입은 int로 자동 변환되고, 연산결과 역시 int 타입이 된다. 그러나 피연산자의 타입을 일치시킬 필요는 없기 때문에 오른쪽 피연산자에는 산술변환이 적용되지 않는다.</p><li><p>기선님의 문제 : numbers라는 int형 배열이 있다. 이 배열에 요소들은 한 숫자를 제외하고는 모두 두 번씩 들어있다. 단 한 번만 등장하는 숫자를 찾는 코드를 작성하라.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>  <span class="c1">// XOR을 활용하는 방식</span>
  <span class="c1">// XOR은 같으면 0 다르면 1</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">){</span>
      <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span> <span class="o">:</span> <span class="n">numbers</span><span class="o">){</span>
          <span class="n">result</span> <span class="o">^=</span> <span class="n">number</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">// 결합 순서가 바뀌어도 결과는 같기 때문에 중복되는 숫자들은 xor 연산을 통해 0이 됨</span>
</pre></table></code></div></div></ul><p><br /></p><h3 id="관계-연산자"><strong>관계 연산자</strong></h3><p>관계 연산자는 두 피연산자를 비교하는데 사용되는 연산자로, 주로 조건문과 반복문의 조건식에 사용되며 연산 결과는 <code class="language-plaintext highlighter-rouge">true</code>와 <code class="language-plaintext highlighter-rouge">false</code> 둘 중에 하나이다.</p><ul><li>대소비교 연산자 (&lt; &gt; &lt;= &gt;=)<br /> 두 피연산자의 값의 크기를 비교하는 연산자이다. boolean을 제외한 기본형에서 모두 사용 가능하지만, 참조형은 사용할 수 없다.<blockquote><p>피연산자가 char 타입이면 유니코드 값으로 비교 연산을 수행한다.</p></blockquote><li><p>등가비교 연산자 (== !=)<br /> 두 피연산자 사이의 값이 같은지 또는 다른지를 비교하는 연산자이다. 참조형을 포함한 모든 자료형에서 사용할 수 있다.</p><p>기본형의 경우, 변수에 저장되어 있는 값이 같은지를 알 수 있고, 참조형의 경우 객체의 주소값을 비교해 두 개의 피연산자가 같은 객체를 가리키고 있는지를 알 수 있다.</p><blockquote><p>만약 두 문자열의 내용을 비교할 때는 == 대신 equals() 메소드를 사용해야 한다.</p></blockquote><p>피연산자를 비교하기 전에 먼저 두 피연산자의 타입을 일치시킨다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>  <span class="sc">'A'</span> <span class="o">==</span> <span class="mi">65</span>       <span class="c1">//true, 'A'가 int로 변환된 후 비교</span>
  <span class="mi">3</span> <span class="o">==</span> <span class="mf">3.0</span>        <span class="c1">//true, int타입인 3을 double 타입으로 변환 후 비교</span>
</pre></table></code></div></div><p>그러나 아래와 같은 예외사항을 주의해야 한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>  <span class="mf">0.1</span> <span class="o">==</span> <span class="mf">0.1f</span>             <span class="c1">//false</span>
  <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="mf">0.1</span> <span class="o">==</span> <span class="mf">0.1f</span>      <span class="c1">//true</span>
</pre></table></code></div></div><p>부동 소수점을 사용하는 타입은 0.1을 정확하게 표현할 수 없기때문에 0.1f는 0.1의 근사값으로 표현되어 내부적으로 0.1000000149011612과 같은 값을 가진다. 따라서 피연산자를 모두 float으로 타입 캐스팅을 해준 뒤 비교 연산을 해야 한다.</p><p>또한, 기본형과 참조형은 서로 형변환이 불가능하기 때문에 등가비교 연산자로 비교할 수 없다.</p></ul><h3 id="논리-연산자"><strong>논리 연산자</strong></h3><p>논리 연산자는 피연산자로 boolean만을 사용하여 둘 이상의 조건을 AND(&amp;&amp;)나 OR(||)으로 연결하여 하나의 식으로 표현할 수 있게 한다. 또한 부정 연산자(!)는 단항 연산자로써 해당 값의 결과를 반대로 반환한다.</p><p><strong>단락 회로 평가 (Short Circuit Evaluation)</strong><br /> 논리 연산자가 효율적인 연산을 하기 위한 방식으로, &amp;&amp;와 || 연산을 사용할 때 첫 번째 피연산자의 결과에 따라 결과값이 정해졌을 경우, 두 번째 피연산자를 평가하지 않는 것을 말한다.</p><p>이런 점이 비트 연산자(&amp;나 |)와 논리 연산자(&amp;&amp;나 ||)를 사용할 때의 차이점이라고 볼 수 있으며 아래 예시를 참고하면 쉽게 이해할 수 있을 것이다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

<span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>

</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="go">Hello
1
0
//한 쪽을 검사해 조건이 만족되면 다른 쪽은 검사하지 않음
</span></pre></table></code></div></div><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

<span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">|</span> <span class="n">j</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>

</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="go">Hello
1
1
//양 쪽 조건을 모두 검사함
</span></pre></table></code></div></div><h3 id="instanceof"><strong>instanceof</strong></h3><p><code class="language-plaintext highlighter-rouge">instanceof</code> 연산자는 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용한다. 주로 조건문에 사용되며 <strong>좌측에는 참조변수</strong>, <strong>우측에는 타입(클래스명)</strong> 이 피연산자로 위치한다.</p><p>연산 결과로는 true와 false를 리턴하며, 값이 null인 참조변수에 대해서는 항상 false를 반환한다.</p><p>instaneof의 연산결과로 true를 얻었다는 것은 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 뜻한다. 따라서 주로 다운 캐스팅(하위 클래스로 형변환)하기 전에 인스턴스의 원래 자료형을 체크하기 위해 많이 사용한다.</p><p>우측 피연산자로 Primitive Type은 사용할 수 없지만, Primitive Type으로 구성된 배열은 사용가능하다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
<span class="nc">Integer</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>

<span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="k">instanceof</span> <span class="kt">int</span><span class="o">)</span>               <span class="c1">//error</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"a is true"</span><span class="o">);</span>

<span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="k">instanceof</span> <span class="nc">Integer</span><span class="o">)</span>           <span class="c1">//true</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"b is true"</span><span class="o">);</span>

<span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="k">instanceof</span> <span class="kt">int</span><span class="o">[])</span>             <span class="c1">//true</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"c is true"</span><span class="o">);</span>
</pre></table></code></div></div><p><br /></p><h3 id="assignment-operator"><strong>assignment(=) operator</strong></h3><p>대입 연산자는 변수에 값 또는 수식의 연산결과를 저장한다. 이 연산자는 오른쪽 피연산자의 값을 왼쪽 피연산자에 저장한다.</p><p>모든 연산자들 중에서 우선순위가 가장 낮기 때문에 식에서 가장 마지막에 실행된다. 또한 연산 진행방향이 오른쪽에서 왼쪽이기 때문에 <code class="language-plaintext highlighter-rouge">x = y = 3;</code>을 시행하면 <code class="language-plaintext highlighter-rouge">y = 3</code>이 먼저 수행되고 <code class="language-plaintext highlighter-rouge">x = y</code>가 수행된다.</p><p>다른 연산자와 대입 연산자를 결합해 복합 대입 연산자를 사용할 수 있다.<br /> 예를 들어, <code class="language-plaintext highlighter-rouge">i += 1</code>은 <code class="language-plaintext highlighter-rouge">i = i + 1</code>과 같다.</p><p><br /></p><h3 id="화살표--연산자"><strong>화살표(-&gt;) 연산자</strong></h3><p>JDK 1.8부터 추가된 <strong>람다식(Lambda expression)</strong>에서 사용되는 연산자이다. 람다식의 도입으로 인해 자바는 객체지향 언어인 동시에 함수형 언어가 되었다.</p><ul><li><p><strong>람다식이란?</strong><br /> 람다식은 메소드를 하나의 식(expression)으로 표현한 것이다. 람다식을 사용하면 함수를 간략하면서도 직관적으로 표현할 수 있게 해준다.</p><p>메소드를 람다식으로 표현하면 메소드의 이름과 반환타입이 없어지므로, 람다식을 익명 함수(anonymous function)라고도 부른다.</p><p>람다식 사용 예</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>  <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
  <span class="nc">Arrays</span><span class="o">.</span><span class="na">setAll</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span><span class="o">)-&gt;(</span><span class="kt">int</span><span class="o">)(</span><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()*</span><span class="mi">5</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
</pre></table></code></div></div><p>원래 메소드는 클래스 내부에 작성한 것을 호출해야 사용가능한데 람다식은 식 하나로 메소드 기능을 수행한다. 또한 람다식은 메소드의 매개변수로 전달가능해서 람다식으로 인해 메소드를 변수처럼 다루는 것이 가능해졌다.</p><li><p><strong>람다식 작성법</strong><br /> 람다식은 메소드의 이름과 반환타입을 제거하고 매개변수 선언부와 몸통{} 사이에 <code class="language-plaintext highlighter-rouge">-&gt;</code> 를 추가한다.</p><p>예를 들어 두 값 중 더 큰 값을 반환하는 메소드 max가 있다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>  <span class="kt">int</span> <span class="nf">max</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="o">;</span>
  <span class="o">}</span>
</pre></table></code></div></div><p>이것을 람다식으로 변환하면 다음과 같다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="o">;}</span>
</pre></table></code></div></div><p>위와 같이 반환값이 있는 메소드는 return문 대신 식으로 대체할 수 있다. 식의 연산 결과가 자동으로 반환값이 되는데 이 때 문장이 아니라 식이므로 끝에 <code class="language-plaintext highlighter-rouge">;</code> 를 붙이지 않아야 한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span>  <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span> 
</pre></table></code></div></div><p>람다식에 선언된 매개변수의 타입은 추론이 가능한 경우 생략 가능한데, 대부분의 경우에 생략 가능하다. 람다식에 반환 타입이 없는 이유는 항상 추론이 가능하기 때문이다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span>
</pre></table></code></div></div><p>만약 람다식에 선언된 매개변수가 하나뿐이라면 괄호()를 생략할 수 있다. 하지만 매개변수의 타입을 생략하지 않고 명시한다면 괄호를 생략할 수 없다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>  <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span>      <span class="c1">//ok</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">*</span> <span class="n">a</span>   <span class="c1">//error</span>
</pre></table></code></div></div><p>마지막으로, 괄호{} 안의 문장이 하나인 경우, 괄호를 생략할 수 있다. 이 때 문장의 끝에 <code class="language-plaintext highlighter-rouge">;</code>를 붙이지 않아야 한다. 그러나 괄호 안의 문장이 return 문이라면 괄호를 생략할 수 없으니 주의하자.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>  <span class="o">(</span><span class="n">number</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">number</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span>     <span class="c1">//ok</span>
  <span class="o">()</span> <span class="o">-&gt;</span> <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>                   <span class="c1">//error</span>
</pre></table></code></div></div><p><br /></p></ul><h3 id="3항-연산자"><strong>3항 연산자</strong></h3><p>3항 연산자는 c언어로부터 차용한 연산자이다. if ~ else 문장을 연산자로 표현할 수 있고 조건에 따라 결과를 반환할 수 있다. 조건 연산자 <code class="language-plaintext highlighter-rouge">? :</code>가 유일한 3항 연산자이다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">)</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">y</span><span class="o">;</span>
</pre></table></code></div></div><p>조건 연산자의 조건식의 평가 결과가 true이면 앞의 식이, false이면 뒤에 식이 결과로 반환된다. 조건식을 괄호()로 감싸서 가독성을 높일 수 있지만 필수는 아니다.</p><p><br /></p><h3 id="연산자-우선-순위"><strong>연산자 우선 순위</strong></h3><p>식에 사용된 연산자가 여러 개일 경우, 연산자의 우선순위에 의해 연산 순서가 결정된다. 하지만 힘들게 외울 필요 없이 대부분 상식선에서 해결된다.</p><p><img data-proofer-ignore data-src="https://media.vlpt.us/images/uhan2/post/29f94f17-268e-4cb3-bb33-4f21521d3a0b/image.png" width="500" /></p><p>출처 : <a href="https://velog.io/@uhan2/Java-Operator">https://velog.io/@uhan2/Java-Operator</a></p><p>정리해보면 <code class="language-plaintext highlighter-rouge">산술 &gt; 비교 &gt; 논리 &gt; 대입</code> 순이다.</p><p><br /></p><h3 id="optional-java-13-switch-연산자"><strong>(optional) Java 13. switch 연산자</strong></h3><p>Switch문은 Java12와 Java13을 거치며 추가된 사항들이 있는데, 먼저 기존의 Switch문을 살펴보자</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">time</span><span class="o">;</span>

<span class="k">switch</span><span class="o">(</span><span class="n">weekday</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nl">MONDAY:</span>
    <span class="k">case</span> <span class="nl">FRIDAY:</span>
        <span class="n">time</span> <span class="o">=</span> <span class="s">"10:00 - 18:00"</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="k">case</span> <span class="nl">TUESDAY:</span>
    <span class="k">case</span> <span class="nl">THURSDAY:</span>
        <span class="n">time</span> <span class="o">=</span> <span class="s">"10:00 - 14:00"</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="n">time</span> <span class="o">=</span> <span class="s">"휴일"</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>기존의 switch문은 코드가 불필요하게 장황하고, 에러 발생 시 디버깅이 어렵다는 단점과 함께 아래와 같은 문제점들이 있다.</p><ol><li>Default fall through due to missing break<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">itemCode</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="k">switch</span> <span class="o">(</span><span class="n">itemCode</span><span class="o">)</span> <span class="o">{</span>
 <span class="k">case</span> <span class="mo">001</span> <span class="o">:</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"It's a laptop!"</span><span class="o">);</span>
     <span class="c1">// missed out break here</span>
 <span class="k">case</span> <span class="mo">002</span> <span class="o">:</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"It's a desktop!"</span><span class="o">);</span>
     <span class="k">break</span><span class="o">;</span>
 <span class="k">case</span> <span class="mo">003</span> <span class="o">:</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"It's a hello!"</span><span class="o">);</span>
     <span class="k">break</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="go">It's a laptop!
It's a desktop!
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">case</code> 에서 <code class="language-plaintext highlighter-rouge">break</code> 키워드를 사용하는 것을 잊었을 경우, 그 아래에 있는 코드 블럭이 실행된다. 이 것을 fall-through라고 한다.</p><li>Multiple values per case not supported<br /> 하나의 case에는 하나의 값만 비교할 수 있기 때문에 여러 값에 해당되는 코드를 실행하기 위해서는 아래 코드처럼 불필요하게 길게 써야 한다.<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre> <span class="k">switch</span> <span class="o">(</span><span class="n">itemCode</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">case</span> <span class="mo">001</span><span class="o">:</span>
     <span class="k">case</span> <span class="mo">002</span><span class="o">:</span>
     <span class="k">case</span> <span class="mo">003</span><span class="o">:</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"It's an electronic gadget!"</span><span class="o">);</span>
 <span class="o">}</span>
</pre></table></code></div></div></ol><p><strong>java 12</strong></p><blockquote><p>참고로, java 12나 java 13부터 switch문 사용 방식이 변경된게 아니고 기존의 switch문은 그대로 있고 새로운 스위치 오퍼레이터가 생긴 것이다.</p></blockquote><p>java12 부터는 같은 기능을 하는 서로 다른 케이스들을 묶을 수 있다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">switch</span><span class="o">(</span><span class="n">weekday</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="no">MONDAY</span><span class="o">,</span> <span class="nl">FRIDAY:</span>
        <span class="n">time</span> <span class="o">=</span> <span class="s">"10:00 - 18:00"</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="k">case</span> <span class="no">TUESDAY</span><span class="o">,</span> <span class="nl">THURSDAY:</span>
        <span class="n">time</span> <span class="o">=</span> <span class="s">"10:00 - 14:00"</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="n">time</span> <span class="o">=</span> <span class="s">"휴일"</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>또한 <code class="language-plaintext highlighter-rouge">지시자(-&gt;)</code>를 통해 break를 생략할 수 있다. 하지만 지시자와 <code class="language-plaintext highlighter-rouge">:</code>를 혼용해서 사용할 수는 없다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">time</span><span class="o">;</span>

<span class="k">switch</span><span class="o">(</span><span class="n">weekday</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="no">MONDAY</span><span class="o">,</span> <span class="no">FRIDAY</span> <span class="o">-&gt;</span> <span class="n">time</span> <span class="o">=</span> <span class="s">"10:00 - 18:00"</span><span class="o">;</span>
    <span class="k">case</span> <span class="no">TUESDAY</span><span class="o">,</span> <span class="no">THURSDAY</span> <span class="o">-&gt;</span> <span class="n">time</span> <span class="o">=</span> <span class="s">"10:00 - 14:00"</span><span class="o">;</span>
    <span class="k">default</span> <span class="o">-&gt;</span> <span class="n">time</span> <span class="o">=</span> <span class="s">"휴일"</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>블록(<code class="language-plaintext highlighter-rouge">{}</code>)을 사용하여 여러 줄로 처리를 할 수도 있다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">time</span><span class="o">;</span>

<span class="k">switch</span><span class="o">(</span><span class="n">weekday</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="no">MONDAY</span><span class="o">,</span> <span class="no">FRIDAY</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">endTime</span> <span class="o">=</span> <span class="n">getEndTime</span><span class="o">();</span>
        <span class="n">time</span> <span class="o">=</span> <span class="s">"10:00 - "</span> <span class="o">+</span> <span class="n">endTime</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">case</span> <span class="no">TUESDAY</span><span class="o">,</span> <span class="no">THURSDAY</span> <span class="o">-&gt;</span> <span class="n">time</span> <span class="o">=</span> <span class="s">"10:00 - 14:00"</span><span class="o">;</span>
    <span class="k">default</span> <span class="o">-&gt;</span> <span class="n">time</span> <span class="o">=</span> <span class="s">"휴일"</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>switch를 식으로도 사용할 수 있게 되었는데, 지시자 문법을 사용하지 않는 경우나 지시자 문법에 블록을 사용한 경우에는 break로 값을 반환한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">time</span> <span class="o">=</span> <span class="k">switch</span><span class="o">(</span><span class="n">weekday</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="no">MONDAY</span><span class="o">,</span> <span class="no">FRIDAY</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">endTime</span> <span class="o">=</span> <span class="n">getEndTime</span><span class="o">();</span>
        <span class="k">break</span> <span class="s">"10:00 - "</span> <span class="o">+</span> <span class="n">endTime</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">case</span> <span class="no">TUESDAY</span><span class="o">,</span> <span class="no">THURSDAY</span> <span class="o">-&gt;</span> <span class="s">"10:00 - 14:00"</span><span class="o">;</span>
    <span class="k">default</span> <span class="o">-&gt;</span> <span class="s">"휴일"</span><span class="o">;</span>
<span class="o">};</span>
</pre></table></code></div></div><p><strong>java 13</strong><br /> java 13에서 수정사항이 생겼는데, <code class="language-plaintext highlighter-rouge">break</code>로 값을 반환하던 문법이 <code class="language-plaintext highlighter-rouge">yield</code>로 변경되었다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="k">switch</span><span class="o">(</span><span class="n">code</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
    <span class="n">yield</span> <span class="s">"code 1"</span><span class="o">;</span>
    <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
    <span class="n">yield</span> <span class="s">"code 2"</span><span class="o">;</span>
    <span class="k">default</span><span class="o">:</span>
    <span class="n">yield</span> <span class="s">"default"</span><span class="o">;</span>
<span class="o">};</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
</pre></table></code></div></div><h2 id="참조">참조</h2><p><a href="https://yadon079.github.io/2020/java%20study%20halle/week-03">https://yadon079.github.io/2020/java%20study%20halle/week-03</a><br /> <a href="https://github.com/yeGenieee/java-live-study/blob/main/%5B3%5DJava%20Live%20Study.md">https://github.com/yeGenieee/java-live-study/blob/main/%5B3%5DJava%20Live%20Study.md</a><br /> <a href="https://velog.io/@uhan2/Java-Operator">https://velog.io/@uhan2/Java-Operator</a><br /> <a href="https://blog.baesangwoo.dev/posts/java-livestudy-3week/">https://blog.baesangwoo.dev/posts/java-livestudy-3week/</a> <a href="https://yadon079.github.io/2020/java%20study%20halle/week-03">https://yadon079.github.io/2020/java%20study%20halle/week-03</a><br /> <a href="https://github.com/yeGenieee/java-live-study/blob/main/%5B3%5DJava%20Live%20Study.md">https://github.com/yeGenieee/java-live-study/blob/main/%5B3%5DJava%20Live%20Study.md</a><br /> <a href="https://velog.io/@uhan2/Java-Operator">https://velog.io/@uhan2/Java-Operator</a><br /> <a href="https://blog.baesangwoo.dev/posts/java-livestudy-3week/">https://blog.baesangwoo.dev/posts/java-livestudy-3week/</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/backend/'>Backend</a>, <a href='/categories/java/'>Java</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >java</a> <a href="/tags/java-study/" class="post-tag no-text-decoration" >java study</a> <a href="/tags/%EC%9E%90%EB%B0%94/" class="post-tag no-text-decoration" >자바</a> <a href="/tags/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%84%B0%EB%94%94/" class="post-tag no-text-decoration" >자바 스터디</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=자바 스터디 03 - 연산자 - yeoji21&url=https://yeoji21.github.io/posts/javastudy03/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=자바 스터디 03 - 연산자 - yeoji21&u=https://yeoji21.github.io/posts/javastudy03/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=자바 스터디 03 - 연산자 - yeoji21&url=https://yeoji21.github.io/posts/javastudy03/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink('', 'Link copied successfully!')" data-toggle="tooltip" data-placement="top" title="Copy link"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/polymorphism-inheritance/">객체지향에서의 상속과 다형성</a><li><a href="/posts/graduation-project-review/">졸업 작품 프로젝트 회고</a><li><a href="/posts/reflection-1/">[JAVA] Java Refelction 마스터 강의 1장</a><li><a href="/posts/mst/">[알고리즘] MST - 크루스칼 vs 프림</a><li><a href="/posts/injection/">[Spring] 의존성 주입 시 생성자 주입을 사용해야 하는 이유 </a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94/">자바</a> <a class="post-tag" href="/tags/java-study/">java study</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%84%B0%EB%94%94/">자바 스터디</a> <a class="post-tag" href="/tags/oop/">oop</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/guides/">guides</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/javastudy01/"><div class="card-body"> <span class="timeago small" >Aug 8, 2021<i class="unloaded">2021-08-08T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>자바 스터디 01 - JVM이란</h3><div class="text-muted small"><p> 들어가면서 백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다. 강의 링크 : [자바 뉴스 라이브] 2020/11/14, 자바 스터디 1주차 깃허브 링크 : 1주차 과제: JVM은 무엇이며 자바 코드는 어떻게 실행하는 것인가. 목차 JVM이란 무엇인가 컴파일 하는 방법 실행하는 방법 바...</p></div></div></a></div><div class="card"> <a href="/posts/javastudy02/"><div class="card-body"> <span class="timeago small" >Aug 10, 2021<i class="unloaded">2021-08-10T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>자바 스터디 02 - 자바 데이터 타입, 변수 그리고 배열</h3><div class="text-muted small"><p> 들어가면서 백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다. 강의 링크 : [자바 뉴스 라이브] 2020/11/21, 자바 스터디 2주차 깃허브 링크 : 2주차 과제: 자바 데이터 타입, 변수 그리고 배열 목차 프리미티브 타입 종류와 값의 범위 그리고 기본 값 프리미티브 타입과 레퍼런스 타...</p></div></div></a></div><div class="card"> <a href="/posts/javastudy04/"><div class="card-body"> <span class="timeago small" >Aug 14, 2021<i class="unloaded">2021-08-14T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>자바 스터디 04 - 제어문</h3><div class="text-muted small"><p> 들어가면서 백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다. 강의 영상 링크 : [자바 라이브 스터디] 2020/12/12, 4주차 제어문 강의 깃허브 링크 : 4주차 과제: 제어문 목차 선택문 반복문 제어문이란? 제어문은 프로그램의 실행 흐름(순서)를 제어하는 구문을 말한다. 일반적...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/javastudy02/" class="btn btn-outline-primary" prompt="Older"><p>자바 스터디 02 - 자바 데이터 타입, 변수 그리고 배열</p></a> <a href="/posts/javastudy04/" class="btn btn-outline-primary" prompt="Newer"><p>자바 스터디 04 - 제어문</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">yeoji21</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94/">자바</a> <a class="post-tag" href="/tags/java-study/">java study</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%84%B0%EB%94%94/">자바 스터디</a> <a class="post-tag" href="/tags/oop/">oop</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/guides/">guides</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://yeoji21.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
