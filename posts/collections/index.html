<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="[JAVA] 컬렉션 프레임워크 (Collections Framework)" /><meta name="author" content="yeoji21" /><meta property="og:locale" content="en" /><meta name="description" content="목차 컬렉션 프레임워크란? 컬렉션 프레임워크의 핵심 인터페이스 ArrayList LinkedList Stack과 Queue HashSet TreeSet HashMap과 Hashtable TreeMap 그 외" /><meta property="og:description" content="목차 컬렉션 프레임워크란? 컬렉션 프레임워크의 핵심 인터페이스 ArrayList LinkedList Stack과 Queue HashSet TreeSet HashMap과 Hashtable TreeMap 그 외" /><link rel="canonical" href="https://yeoji21.github.io/posts/collections/" /><meta property="og:url" content="https://yeoji21.github.io/posts/collections/" /><meta property="og:site_name" content="yeoji21" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-09-03T03:55:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[JAVA] 컬렉션 프레임워크 (Collections Framework)" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@yeoji21" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"yeoji21"},"dateModified":"2021-10-27T00:55:52+09:00","datePublished":"2021-09-03T03:55:00+09:00","description":"목차 컬렉션 프레임워크란? 컬렉션 프레임워크의 핵심 인터페이스 ArrayList LinkedList Stack과 Queue HashSet TreeSet HashMap과 Hashtable TreeMap 그 외","headline":"[JAVA] 컬렉션 프레임워크 (Collections Framework)","mainEntityOfPage":{"@type":"WebPage","@id":"https://yeoji21.github.io/posts/collections/"},"url":"https://yeoji21.github.io/posts/collections/"}</script><title>[JAVA] 컬렉션 프레임워크 (Collections Framework) | yeoji21</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="yeoji21"><meta name="application-name" content="yeoji21"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR:wght@500&display=swap" rel="stylesheet"><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile/img1.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">yeoji21</a></div><div class="site-subtitle font-italic">Don't look back in anger</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/yeoji21" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['yeozone0508','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[JAVA] 컬렉션 프레임워크 (Collections Framework)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[JAVA] 컬렉션 프레임워크 (Collections Framework)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> yeoji21 </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Sep 3, 2021, 3:55 AM +0900" >Sep 3, 2021<i class="unloaded">2021-09-03T03:55:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Oct 27, 2021, 12:55 AM +0900" >Oct 27, 2021<i class="unloaded">2021-10-27T00:55:52+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7477 words">41 min read</span></div></div><div class="post-content"><h2 id="목차">목차</h2><ul><li>컬렉션 프레임워크란?<li>컬렉션 프레임워크의 핵심 인터페이스<li>ArrayList<li>LinkedList<li>Stack과 Queue<li>HashSet<li>TreeSet<li>HashMap과 Hashtable<li>TreeMap<li>그 외</ul><h3 id="컬렉션-프레임워크란"><strong>컬렉션 프레임워크란?</strong></h3><p>컬렉션 프레임워크란, 데이터 군을 저장하는 클래스들을 표준화한 설계를 뜻한다. 여기서 <code class="language-plaintext highlighter-rouge">컬렉션(Collection)</code>은 다수의 데이터, 데이터 그룹을 의미하고 <code class="language-plaintext highlighter-rouge">프레임워크(Framework)</code>는 표준화된 프로그래밍 방식을 말한다.</p><p><code class="language-plaintext highlighter-rouge">JDK 1.2</code> 이전까지는 <code class="language-plaintext highlighter-rouge">Vector</code>, <code class="language-plaintext highlighter-rouge">Hashtable</code>, <code class="language-plaintext highlighter-rouge">Properties</code>와 같은 컬렉션 클래스들을 각자의 방식으로 처리해야 했으나, <code class="language-plaintext highlighter-rouge">JDK 1.2</code>부터 컬렉션 프레임워크가 등장하면서 다양한 종류의 컬렉션 클래스가 추가되고 모든 컬렉션 클래스를 표준화된 방식으로 다룰 수 있도록 체계화되었다.</p><h3 id="컬렉션-프레임워크의-핵심-인터페이스"><strong>컬렉션 프레임워크의 핵심 인터페이스</strong></h3><p>컬렉션 프레임워크에서는 컬렉션 데이터 그룹을 크게 세 가지 타입의 인터페이스로 나누었다. 그리고 인터페이스 <code class="language-plaintext highlighter-rouge">List</code>와 <code class="language-plaintext highlighter-rouge">Set</code>의 공통 부분을 뽑아서 새로운 인터페이스인 <code class="language-plaintext highlighter-rouge">Collection</code>을 추가로 정의했다. <code class="language-plaintext highlighter-rouge">Map</code> 인터페이스는 이들과는 전혀 다른 형태로 컬렉션을 다루기 때문에 같은 상속 계층도에 포함되지 못했다.</p><p><img data-proofer-ignore data-src="assets/../../../assets/img/collections/1.jpeg" width="500" /></p><blockquote><p>JDK 1.5부터 Iterable 인터페이스가 추가되고 Collection 인터페이스가 이것을 상속받도록 변경되었으나. 이것은 단지 공통적인 메소드를 뽑아서 중복을 제거하기 위한 것이므로 상속 계층도에서 별 의미가 없다.</p></blockquote><div class="table-wrapper"><table><thead><tr><th>인터페이스<th style="text-align: right">특징<th style="text-align: right">구현 클래스<tbody><tr><td>List<td style="text-align: right">순서가 있는 데이터의 집합, 데이터의 중복 허용 <br /> 예) 대기자 명단<td style="text-align: right">ArrayList, LinkedList, Stack, Vactor<tr><td>Set<td style="text-align: right">순서를 유지하지 않고 데이터의 중복이 허용되지 않음 <br /> 예) 양의 정수집합, 소수의 집합<td style="text-align: right">HashSet, TreeSet<tr><td>Map<td style="text-align: right">key와 value의 쌍으로 이루어진 데이터의 집합<br />순서유지 x, key는 중복허용 x, value는 중복허용 o<br />예) 우편번호, 전화번호<td style="text-align: right">HashMap,TreeMap,Hashtable,Properties</table></div><p>컬렉션 프레임워크의 모든 컬렉션 클래스들은 이 셋 중의 하나를 구현하고 있으며, 구현한 인터페이스의 이름이 클래스의 이름에 포함되어 있어서 이름만으로도 클래스의 특징을 쉽게 알 수 있다.</p><p>하지만 <code class="language-plaintext highlighter-rouge">Vector</code>, <code class="language-plaintext highlighter-rouge">Stack</code>, <code class="language-plaintext highlighter-rouge">Hashtable</code>, <code class="language-plaintext highlighter-rouge">Properties</code>와 같이 컬렉션 프레임워크가 만들어지기 이전부터 존재하던 클래스들은 이러한 명명 규칙을 따르지 않는다. 이런 기존의 컬렉션 클래스들은 호환을 위해 남겨두었지만 가능한 사용하지 않는 것이 좋다.</p><h4 id="collection-인터페이스">Collection 인터페이스</h4><div class="table-wrapper"><table><thead><tr><th style="text-align: right">메소드<th style="text-align: right">설명<tbody><tr><td style="text-align: right">boolean <strong>add(Object o)</strong><br />boolean <strong>addAll(Collection c)</strong><td style="text-align: right">지정된 객체(o) 또는 Collection의 객체들을 Collection에 추가<tr><td style="text-align: right">void <strong>clear()</strong><td style="text-align: right">Collection의 모든 객체를 삭제<tr><td style="text-align: right">boolean <strong>contains(Object o)</strong><br />boolean <strong>containsAll(Collection c)</strong><td style="text-align: right">지정된 객체 또는 Collection의 객체들이 Collection에 포함되어 있는지 확인<tr><td style="text-align: right">boolean <strong>equals(Object o)</strong><td style="text-align: right">동일한 Collection인지 비교<tr><td style="text-align: right">int <strong>hashCode()</strong><td style="text-align: right">Collection의 hash code 반환<tr><td style="text-align: right">boolean <strong>isEmpty()</strong><td style="text-align: right">Collection이 비어있는지 확인<tr><td style="text-align: right">Iterator <strong>iterator()</strong><td style="text-align: right">Collection의 iterator를 얻어서 반환<tr><td style="text-align: right">boolean <strong>remove(Object o)</strong><td style="text-align: right">지정된 객체를 삭제<tr><td style="text-align: right">boolean <strong>removeAll(Collection c)</strong><td style="text-align: right">지정된 Collection에 포함된 모든 객체를 삭제<tr><td style="text-align: right">boolean <strong>retainAll(Collection c)</strong><td style="text-align: right">지정된 Collection에 포함된 객체만 남기고 다른 나머지 객체들은 삭제 <br /> 이로인해 Collection에 변화가 생기면 true를 반환<tr><td style="text-align: right">int <strong>size()</strong><td style="text-align: right">Collection에 저장된 객체의 개수를 반환<tr><td style="text-align: right">Object[] <strong>toArray()</strong><td style="text-align: right">Collection에 저장된 객체를 객체 배열로 반환<tr><td style="text-align: right">Object[] <strong>toArray(Object[] a)</strong><td style="text-align: right">지정된 배열에 Collection의 객체를 저장해서 반환</table></div><p>이 외에도 <code class="language-plaintext highlighter-rouge">JDK 1.8</code>부터 추가된 <code class="language-plaintext highlighter-rouge">Lambda</code>와 <code class="language-plaintext highlighter-rouge">Stream</code>에 관련된 메소드들이 더 있는데, 이 것들은 해당 주제를 다루는 포스트에서 따로 언급하겠다.</p><blockquote><p>실제 Java API 문서를 보면 표에서 사용된 Object가 아닌 제네릭 타입 E로 표기되어 있는데, 이해를 돕기 위해 Object로 표기했다.</p></blockquote><h4 id="list-인터페이스">List 인터페이스</h4><p><code class="language-plaintext highlighter-rouge">List</code> 인터페이스는 <strong>중복을 허용</strong>하면서 <strong>저장순서가 유지</strong>되는 컬렉션을 구현하는데 사용된다.</p><p><img data-proofer-ignore data-src="assets/../../../assets/img/collections/2.jpeg" width="400" /></p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">메소드<th style="text-align: right">설명<tbody><tr><td style="text-align: right">void <strong>add(int index, Object element)</strong><br />boolean <strong>addAll(int index, Collection c)</strong><td style="text-align: right">지정된 위치에 객체 또는 컬렉션에 포함된 객체들을 추가<tr><td style="text-align: right">Object <strong>get(int index)</strong><td style="text-align: right">지정된 위치에 있는 객체를 반환<tr><td style="text-align: right">int <strong>indexOf(Object o)</strong><td style="text-align: right">지정된 객체의 위치를 반환<br />(List의 첫번째 요소부터 순방향으로 탐색)<tr><td style="text-align: right">int <strong>lastIndexOf(Object o)</strong><td style="text-align: right">지정된 객체의 위치를 반환<br />(List의 마지막 요소부터 역방향으로 탐색)<tr><td style="text-align: right">ListIterator <strong>listIterator()</strong><br />ListIterator <strong>listIterator(int index)</strong><td style="text-align: right">List의 객체에 접근할 수 있는 ListIterator 반환<tr><td style="text-align: right">Object <strong>remove(int idex)</strong><td style="text-align: right">지정된 위치에 있는 객체를 삭제하고 삭제된 객체를 반환<tr><td style="text-align: right">Object <strong>set(int index, Object element</strong>)<td style="text-align: right">지정된 위치에 객체를 저장<tr><td style="text-align: right">void <strong>sort(Comparator c)</strong><td style="text-align: right">지정된 비교자로 List를 정렬<tr><td style="text-align: right">List <strong>subList(int fromIndex, int toIndex)</strong><td style="text-align: right">지정된 범위에 있는 객체를 반환</table></div><h4 id="set-인터페이스">Set 인터페이스</h4><p><code class="language-plaintext highlighter-rouge">Set</code> 인터페이스는 <strong>중복을 허용하지 않고 저장순서가 유지되지 않는</strong> 컬렉션 클래스를 구현하는데 사용된다.</p><p><img data-proofer-ignore data-src="atssets/../../../assets/img/collections/3.jpeg" width="300" /></p><h4 id="map-인터페이스">Map 인터페이스</h4><p><code class="language-plaintext highlighter-rouge">Map</code>인터페이스는 key와 value를 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는 데 사용된다. 이 때 key는 중복될 수 없지만 value는 중복을 허용한다. 만약 기존에 저장된 데이터와 중복된 key로 데이터를 저장하면 기존의 value는 없어지고 덮어써진다.</p><p><img data-proofer-ignore data-src="asserts/../../../assets/img/collections/4.jpeg" width="450" /></p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">메소드<th style="text-align: right">설명<tbody><tr><td style="text-align: right">void <strong>clear()</strong><td style="text-align: right">Map의 모든 객체를 삭제<tr><td style="text-align: right">boolean <strong>containsKey(Object key)</strong><td style="text-align: right">지정된 key와 일치하는 Map의 key가 있는지 확인<tr><td style="text-align: right">boolean <strong>containsValue(Object value)</strong><td style="text-align: right">지정된 value와 일치하는 Map의 value가 있는지 확인<tr><td style="text-align: right">Set <strong>entrySet()</strong><td style="text-align: right">Map의 key-value쌍을 Map.Entry타입의 객체로 저장한 Set으로 반환<tr><td style="text-align: right">boolean <strong>equals(Object o)</strong><td style="text-align: right">동일한 Map인지 비교<tr><td style="text-align: right">Object <strong>get(Object key)</strong><td style="text-align: right">지정한 key에 대응하는 value를 반환<tr><td style="text-align: right">int <strong>hashCode()</strong><td style="text-align: right">해시코드를 반환<tr><td style="text-align: right">boolean <strong>isEmpty()</strong><td style="text-align: right">Map이 비어있는지 확인<tr><td style="text-align: right">Set <strong>keySet()</strong><td style="text-align: right">Map에 저장된 모든 key를 반환<tr><td style="text-align: right">Object <strong>put(Object key, Object value)</strong><td style="text-align: right">Map에 key-value쌍을 저장<tr><td style="text-align: right">void <strong>putAll(Map t)</strong><td style="text-align: right">지정된 Map의 모든 key-value쌍을 추가<tr><td style="text-align: right">Object <strong>remove(Object key)</strong><td style="text-align: right">지정된 key와 일치하는 key-value쌍을 삭제<tr><td style="text-align: right">int <strong>size()</strong><td style="text-align: right">Map에 저장된 key-value쌍의 개수를 반환<tr><td style="text-align: right">Collection <strong>values()</strong><td style="text-align: right">Map에 저장된 모든 value객체를 반환</table></div><p>여기서 <code class="language-plaintext highlighter-rouge">values()</code>의 반환타입은 <code class="language-plaintext highlighter-rouge">Collection</code>이고, <code class="language-plaintext highlighter-rouge">keySet()</code>의 반환타입은 <code class="language-plaintext highlighter-rouge">Set</code>인 것에 주목하자. Map 인터페이스에서 값은 중복을 허용하기 때문에 Collection타입으로 반환하고, 키는 중복을 허용하지 않기 때문에 Set타입으로 반환한다.</p><h4 id="mapentry-인터페이스">Map.Entry 인터페이스</h4><p><code class="language-plaintext highlighter-rouge">Map.Entry</code> 인터페이스는 <code class="language-plaintext highlighter-rouge">Map</code>인터페이스의 내부 인터페이스다. Map에 저장되는 key-value 쌍을 다루기 위해 내부적으로 <code class="language-plaintext highlighter-rouge">Entry</code> 인터페이스를 정의해 놓았다.</p><blockquote><p>내부 클래스처럼 인터페이스도 인터페이스 안에 인터페이스를 정의하는 내부 인터페이스를 정의할 수 있다.</p></blockquote><div class="table-wrapper"><table><thead><tr><th style="text-align: right">메소드<th style="text-align: right">설명<tbody><tr><td style="text-align: right">boolean <strong>equals(Object o)</strong><td style="text-align: right">동일한 Entry인지 비교<tr><td style="text-align: right">Object <strong>getKey()</strong><td style="text-align: right">Entry의 key객체를 반환<tr><td style="text-align: right">Object <strong>getValue()</strong><td style="text-align: right">Entry의 value객체를 반환<tr><td style="text-align: right">int <strong>hashCode()</strong><td style="text-align: right">Entry의 해시코드를 반환<tr><td style="text-align: right">Object <strong>setValue(Object value)</strong><td style="text-align: right">Entry의 value객체를 지정된 객체로 변경</table></div><h3 id="arraylist"><strong>ArrayList</strong></h3><p><code class="language-plaintext highlighter-rouge">ArrayList</code>는 컬렉션 프레임워크 중에서 가장 많이 사용되는 컬렉션 클래스다. 이름에서 알 수 있듯이 <code class="language-plaintext highlighter-rouge">List</code> 인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고 중복을 허용한다는 특징을 갖는다.</p><p><code class="language-plaintext highlighter-rouge">ArrayList</code>는 기존의 <code class="language-plaintext highlighter-rouge">Vector</code>를 개선한 것으로, 구현원리와 기능적인 측면에서 동일하다고 할 수 있다. 앞서 얘기했듯이 <code class="language-plaintext highlighter-rouge">Vector</code>는 <code class="language-plaintext highlighter-rouge">legacy code</code>와의 호환성을 위해 계속 남겨두고 있을 뿐, 가능한 <code class="language-plaintext highlighter-rouge">ArrayList</code>를 사용해야 한다.</p><p><code class="language-plaintext highlighter-rouge">ArrayList</code>는 내부적으로 <code class="language-plaintext highlighter-rouge">Object 배열</code>을 이용해서 데이터를 순차적으로 저장한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">AbstractList</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;,</span> 
    <span class="nc">RandomAccess</span><span class="o">,</span> <span class="nc">Cloneable</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span><span class="o">{</span>
        <span class="o">...</span>
<span class="kd">transient</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">elementData</span><span class="o">;</span>
        <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><p>따라서 <code class="language-plaintext highlighter-rouge">ArrayList</code>나 <code class="language-plaintext highlighter-rouge">Vector</code> 같이 배열을 이용한 자료구조는 데이터를 읽어오고 저장하는 데는 효율이 좋지만, <strong>용량을 변경해야 할 때는 새로운 배열을 생성한 후 기존으 배열로부터 새로 생성된 배열로 데이터를 복사</strong>해야하기 때문에 상당히 효율이 떨어진다는 단점을 가진다.</p><p>그래서 처음에 인스턴스를 생성할 때, 저장할 데이터의 개수를 잘 고려하여 충분한 용량의 인스턴스를 생성하는 것이 좋다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">생성자<th style="text-align: right">설명<tbody><tr><td style="text-align: right">ArrayList()<td style="text-align: right">크기가 10인 ArrayList를 생성<tr><td style="text-align: right">ArrayList(Collection c)<td style="text-align: right">주어진 Collection이 저장된 ArrayList 생성<tr><td style="text-align: right">ArrayList(int initCapacity)<td style="text-align: right">지정된 초기용량을 갖는 ArrayList 생성</table></div><p>생성할 때 지정한 크기보다 더 많은 객체를 저장하면 자동적으로 크기가 늘어나기는 하지만 이 과정에서 처리 시간이 많이 소요된다.</p><p><img data-proofer-ignore data-src="assets/../../../assets/img/collections/5.jpeg" width="700" /></p><p><code class="language-plaintext highlighter-rouge">ArrayList</code>의 <code class="language-plaintext highlighter-rouge">Object remove(int index)</code>메소드는 지정된 위치에 있는 객체를 삭제하고 삭제한 객체를 반환하는데, 삭제할 객체의 바로 아래에 있는 데이터를 한 칸씩 위로 복사해서 삭제할 객체를 덮어쓰는 방식으로 처리한다. 만일 삭제할 객체가 마지막 데이터라면, 단순히 <code class="language-plaintext highlighter-rouge">null</code>로 변경해주기만 하면 된다.</p><h3 id="linkedlist"><strong>LinkedList</strong></h3><p>배열은 간단하며 사용하기 쉽고, 데이터를 읽어오는데 걸리는 시간(access time)이 가장 빠르다는 장점을 가지고 있지만 다음과 같은 단점도 있다.</p><ol><li>크기를 변경할 수 없다.<br /> 크기를 변경할 수 없어 새로운 배열을 생성해 기존 데이터를 복사해야 한다. 이를 막기 위해서 충분히 큰 크기의 배열을 생성해야 하므로 메모리가 낭비된다.<li>비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.<br /> 차례대로 데이터를 추가하고 마지막 데이터를 삭제하는 것은 빠르지만, 배열의 중간에 데이터를 추가하거나 삭제하면 다른 데이터들이 이동해야 한다.</ol><p>이러한 배열의 단점을 보완하기 위해서 <code class="language-plaintext highlighter-rouge">LinkedList</code>라는 자료구조가 고안되었다. <code class="language-plaintext highlighter-rouge">LinkedList</code>는 불연속적으로 존재하는 데이터를 서로 연결(link)한 형태로 구성되어 있다.</p><blockquote><p>실제 LinkedList 클래스는 접근성을 높이기 위해 이름과 달리 linked list가 아닌 double linked list로 구현되어 있다.</p></blockquote><p>하지만 <code class="language-plaintext highlighter-rouge">LinkedList</code>는 원하는 값을 얻으려면 처음부터 n번째 데이터까지 차례대로 따라가야 한다는 단점이 있다. 그래서 저장해야하는 데이터의 개수가 많아질수록 데이터를 읽어오는 시간이 길어진다.</p><p>따라서 데이터의 개수가 변하지 않거나 순차적으로 추가/삭제하는 경우에는 <code class="language-plaintext highlighter-rouge">ArrayList</code>가 <code class="language-plaintext highlighter-rouge">LinkedList</code>보다 좋은 선택이고, 데이터 개수의 변경이 잦거나 중간 데이터를 추가/삭제하는 경우에는 <code class="language-plaintext highlighter-rouge">LinkedList</code>가 <code class="language-plaintext highlighter-rouge">ArrayList</code>보다 유리하다.</p><h3 id="stack과-queue"><strong>Stack과 Queue</strong></h3><p><strong>stack 클래스의 메소드</strong></p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">메소드<th style="text-align: right">설명<tbody><tr><td style="text-align: right">boolean <strong>empty()</strong><td style="text-align: right">Stack이 비었는지<tr><td style="text-align: right">Object <strong>peek()</strong><td style="text-align: right">Stack의 맨 위에 저장된 객체를 반환 (꺼내지는 않음)<tr><td style="text-align: right">Object <strong>pop()</strong><td style="text-align: right">Stack의 맨 위에 저장된 객체를 꺼냄<tr><td style="text-align: right">Object <strong>push(Object item)</strong><td style="text-align: right">Stack에 객체를 저장<tr><td style="text-align: right">int <strong>search(Object o)</strong><td style="text-align: right">주어진 객체를 찾아서 위치를 반환, 없으면 -1 <br /> (배열과 달리 위치는 0이아닌 1부터 시작)</table></div><p><br /></p><p><strong>Queue 인터페이스의 메소드</strong></p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">메소드<th style="text-align: right">설명<tbody><tr><td style="text-align: right">boolean <strong>add(Object o)</strong><td style="text-align: right">지정된 객체를 Queue에 추가<br />성공하면 true, 저장공간이 부족하면 IllegalStateException 발생<tr><td style="text-align: right">Object <strong>remove()</strong><td style="text-align: right">Queue에서 객체를 꺼내 반환 <br /> 비어있으면 NoSuchElementException 발생<tr><td style="text-align: right">Object <strong>element()</strong><td style="text-align: right">삭제없이 요소를 읽어옴 <br /> 비어있으면 NoSuchElementException 발생<tr><td style="text-align: right">boolean <strong>offer(Object o)</strong><td style="text-align: right">Queue에 객체를 저장 <br /> 성공하면 true, 실패하면 false 리턴<tr><td style="text-align: right">Object <strong>poll()</strong><td style="text-align: right">Queue에서 객체를 꺼내서 반환. 비어있으면 null<tr><td style="text-align: right">Object <strong>peek()</strong><td style="text-align: right">삭제없이 요소를 읽어옴. 비어있으면 null</table></div><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="n">s</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="n">s</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">s</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>

    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>

    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"---stack---"</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">s</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"---queue---"</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Stack</code>과 <code class="language-plaintext highlighter-rouge">Queue</code>에 데이터를 저장하고 출력하는 기본적인 예제다. 여기서 특이점을 발견했는가?</p><p>Java에서 스택은 <code class="language-plaintext highlighter-rouge">Stack 클래스</code>로 구현해 제공하고 있지만, 큐는 <code class="language-plaintext highlighter-rouge">Queue 인터페이스</code>로만 정의해 놓았을 뿐 별도의 클래스를 제공하지 않고 있다. 대신 <code class="language-plaintext highlighter-rouge">Queue</code> 인터페이스를 구현한 클래스들이 있어서 이 중에 하나를 선택해서 사용하면 된다.</p><p>큐는 데이터를 꺼낼 때 항상 첫 번째에 저장된 데이터를 삭제하므로, <code class="language-plaintext highlighter-rouge">ArrayList</code>와 같이 배열기반의 컬렉션 클래스를 사용하면 데이터를 꺼낼 때마다 빈 공간을 채우기 위해 데이터의 복사가 발생하므로 비효율적이다. 그래서 큐는 데이터의 추가/삭제가 쉬운 <code class="language-plaintext highlighter-rouge">LinkedList</code>로 구현하는 것이 적합하다.</p><h3 id="hashset"><strong>HashSet</strong></h3><p><code class="language-plaintext highlighter-rouge">HashSet</code>은 <code class="language-plaintext highlighter-rouge">Set</code>인터페이스를 구현한 가장 대표적인 컬렉션이다. <code class="language-plaintext highlighter-rouge">HashSet</code>에 새로운 요소를 추가할 때는 <code class="language-plaintext highlighter-rouge">add</code>메소드나 <code class="language-plaintext highlighter-rouge">addAll</code>메소드를 사용하는데, 이미 <code class="language-plaintext highlighter-rouge">HashSet</code>에 저장되어 있는 요소와 중복된 요소를 추가하고자 한다면 이 메소드들은 <code class="language-plaintext highlighter-rouge">false</code>를 반환함으로써 중복된 요소이기때문에 추가에 실패했다는 것을 알린다.</p><p><code class="language-plaintext highlighter-rouge">List</code>인터페이스를 구현한 컬렉션과 달리 <code class="language-plaintext highlighter-rouge">HashSet</code>은 저장순서를 유지하지 않으므로 저장순서를 유지하고자 한다면 <code class="language-plaintext highlighter-rouge">LinkedHashSet</code>을 사용해야 한다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">생성자<th style="text-align: right">설명<tbody><tr><td style="text-align: right">HashSet()<td style="text-align: right">HashSet 객체를 생성<tr><td style="text-align: right">HashSet(Collection c)<td style="text-align: right">주어진 컬렉션을 포한하는 HashSet 객체 생성<tr><td style="text-align: right">HashSet(int initialCapacity)<td style="text-align: right">주어진 값을 초기용량으로 하는 HashSet 객체 생성<tr><td style="text-align: right">HashSet(int initialCapacity, float loadFactor)<td style="text-align: right">초기용량과 loadFactor를 지정하는 생성자</table></div><blockquote><p>load factor는 컬렉션 클래스의 저장공간이 가득 차기 전에 미리 용량을 확보하기 위한 것으로 이 값을 0.8로 지정하면, 저장공간의 80%가 채워졌을 때 용량이 두 배로 늘어난다. 기본값은 0.75이다.</p></blockquote><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">HashSetEx</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Object</span><span class="o">[]</span> <span class="n">objArr</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="s">"2"</span><span class="o">,</span><span class="s">"2"</span><span class="o">,</span><span class="s">"2"</span><span class="o">,</span><span class="s">"3"</span><span class="o">,</span><span class="s">"4"</span><span class="o">,</span><span class="s">"4"</span><span class="o">,</span><span class="s">"4"</span><span class="o">};</span>
        <span class="nc">Set</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">objArr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">objArr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="go">[1, 1, 2, 3, 4]
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">HashSet</code>을 사용한 기본적인 예제이다. 그런데 예상과 달리, 결과를 보면 1이 두 번 출력되는 것을 알 수 있다. 두개의 1 중에서 하나는 <code class="language-plaintext highlighter-rouge">String</code> 인스턴스이고 다른 하나는 <code class="language-plaintext highlighter-rouge">Integer</code> 인스턴스로 서로 다른 객체이므로 중복으로 간주되지 않는 것이다.</p><p>또 다른 예제를 살펴보자</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Digimon</span><span class="o">{</span>
    <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Digimon</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Digimon</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Digimon</span><span class="o">(</span><span class="s">"agumon"</span><span class="o">,</span> <span class="mi">10</span><span class="o">));</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Digimon</span><span class="o">(</span><span class="s">"agumon"</span><span class="o">,</span> <span class="mi">10</span><span class="o">));</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="go">[agumon:10, agumon:10]
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Digimon</code> 클래스는 <code class="language-plaintext highlighter-rouge">name</code>과 <code class="language-plaintext highlighter-rouge">age</code>를 멤버변수로 갖는다. 이름과 나이가 같으면 같은 객체로 인식하도록 하려는 의도로 작성하였지만, 결과를 보면 <code class="language-plaintext highlighter-rouge">name</code>과 <code class="language-plaintext highlighter-rouge">age</code>가 같음에도 불구하고 서로 다른 것으로 인식하여 <code class="language-plaintext highlighter-rouge">agumon:10</code>가 두 번 출력되었다.</p><p>원래 클래스 작성 의도대로 이 두 인스턴스를 같은 것으로 인식하게 하려면 어떻게 해야 할까?</p><p><code class="language-plaintext highlighter-rouge">HashSet</code>의 <code class="language-plaintext highlighter-rouge">add()</code>는 새로운 요소를 추가하기 전에 기존에 저장된 요소와 같은 것인지 판별하기 위해 추가하려는 요소의 <code class="language-plaintext highlighter-rouge">equals()</code>와 <code class="language-plaintext highlighter-rouge">hashCode()</code>를 호출하기 때문에 <code class="language-plaintext highlighter-rouge">equals()</code>와 <code class="language-plaintext highlighter-rouge">hashCode()</code>를 목적에 맞게 오버라이딩해야 한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">name</span><span class="o">+</span><span class="n">age</span><span class="o">).</span><span class="na">hashCode</span><span class="o">();</span>
<span class="o">}</span>

<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">Digimon</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Digimon</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Digimon</span><span class="o">)</span><span class="n">obj</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">temp</span><span class="o">.</span><span class="na">name</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">age</span> <span class="o">==</span> <span class="n">temp</span><span class="o">.</span><span class="na">age</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>두 인스턴스의 <code class="language-plaintext highlighter-rouge">name</code>과 <code class="language-plaintext highlighter-rouge">age</code>가 서로 같으면 <code class="language-plaintext highlighter-rouge">true</code>를 반환하도록 <code class="language-plaintext highlighter-rouge">equals()</code>를 오버라이딩했다. 그리고 <code class="language-plaintext highlighter-rouge">hashCode()</code>는 <code class="language-plaintext highlighter-rouge">String</code>클래스의 <code class="language-plaintext highlighter-rouge">hashCode()</code>를 이용해서 구현했다.</p><p>위의 <code class="language-plaintext highlighter-rouge">hashCode()</code>를 <code class="language-plaintext highlighter-rouge">JDK 1.8</code>부터 추가된 <code class="language-plaintext highlighter-rouge">java.util.Objects</code>클래스의 <code class="language-plaintext highlighter-rouge">hash()</code>를 이용해서 작성하면 아래와 같다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="treeset"><strong>TreeSet</strong></h3><p><code class="language-plaintext highlighter-rouge">TreeSet</code>은 <code class="language-plaintext highlighter-rouge">이진 검색 트리(binary search tree)</code>의 형태로 데이터를 저장하는 컬렉션 클래스다. 이진 검색 트리는 정렬, 검색, 범위검색(range search)에 높은 성능을 보이는 자료구조이며, <code class="language-plaintext highlighter-rouge">TreeSet</code>은 이진 검색 트리의 성능을 향상시킨 <code class="language-plaintext highlighter-rouge">레드-블랙 트리</code>로 구현되어 있다.</p><p>그리고 <code class="language-plaintext highlighter-rouge">Set</code>인터페이스를 구현했으므로 중복된 데이터의 저장을 허용하지 않으며, 정렬된 위치에 저장하므로 저장순서를 유지하지도 않는다.</p><p>이진 검색 트리는 부모노드의 왼쪽에는 부모노드보다 작은 값의 자식노드를, 오른쪽에는 부모노드보다 큰 값의 자식노드를 저장하기 때문에 <code class="language-plaintext highlighter-rouge">TreeSet</code>에 저장되는 객체가 <code class="language-plaintext highlighter-rouge">Comparable</code>을 구현하거나, <code class="language-plaintext highlighter-rouge">TreeSet</code>에게 <code class="language-plaintext highlighter-rouge">Comparator</code>를 제공해서 두 객체를 비교할 방법을 알려줘야 한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">TreeSetLotto</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeSet</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">45</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="go">[9, 13, 15, 33, 36, 41]
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">TreeSet</code>은 이진 검색 트리로 저장되기 때문에, 저장 시에 이미 정렬되어 읽어올 때 따로 정렬할 필요가 없다.</p><h3 id="hashmap과-hashtable"><strong>HashMap과 Hashtable</strong></h3><p><code class="language-plaintext highlighter-rouge">HashMap</code>과 <code class="language-plaintext highlighter-rouge">Hashtable</code>은 앞서 살펴 본 <code class="language-plaintext highlighter-rouge">Vector</code>와 <code class="language-plaintext highlighter-rouge">ArrayList</code>의 관계와 같아서 가능한 <code class="language-plaintext highlighter-rouge">HashMap</code>을 사용할 것을 권장한다.</p><p><code class="language-plaintext highlighter-rouge">HashMap</code>은 <code class="language-plaintext highlighter-rouge">Map</code>을 구현했으므로 이전에 언급한 <code class="language-plaintext highlighter-rouge">Map</code>의 특징을 가지면서 <code class="language-plaintext highlighter-rouge">해싱(hashing)</code>을 사용하기 때문에 많은 양의 데이터를 검색하는데 있어서 뛰어난 성능을 보인다.</p><p>다음은 <code class="language-plaintext highlighter-rouge">HashMap</code> 클래스 중 일부분이다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">AbstractMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;,</span> 
                                                        <span class="nc">Cloneable</span><span class="o">,</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">transient</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">table</span><span class="o">;</span>
    <span class="o">...</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">;</span>
        <span class="kd">final</span> <span class="no">K</span> <span class="n">key</span><span class="o">;</span>
        <span class="no">V</span> <span class="n">value</span><span class="o">;</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
        <span class="o">...</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">HashMap</code>은 <code class="language-plaintext highlighter-rouge">Node</code>라는 내부 클래스를 정의하고, 다시 <code class="language-plaintext highlighter-rouge">Node</code> 타입의 배열을 선언하고 있다. <code class="language-plaintext highlighter-rouge">key</code>와 <code class="language-plaintext highlighter-rouge">value</code>는 서로 별개의 값이 아니기때문에 각각의 배열로 선언하기 보다는 하나의 클래스로 정의해서 배열로 다루는 것이 데이터의 무결성적인 측면에서 더 바람직하기 때문이다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">생성자<th style="text-align: right">설명<tbody><tr><td style="text-align: right">HashMap()<td style="text-align: right">HashMap 객체 생성<tr><td style="text-align: right">HashMap(int initialCapacity)<td style="text-align: right">주어진 값을 초기용량으로 하는 HashMap 객체 생성<tr><td style="text-align: right">HashMap(int initialCapacity, float loadFactor)<td style="text-align: right">초기용량과 loadFactor를 지정하는 생성자<tr><td style="text-align: right">HashMap(Map m)<td style="text-align: right">지정된 Map의 모든 요소를 포함하는 HashMap 객체 생성</table></div><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">HashMapEx</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="o">{</span><span class="s">"A"</span><span class="o">,</span><span class="s">"K"</span><span class="o">,</span><span class="s">"A"</span><span class="o">,</span><span class="s">"K"</span><span class="o">,</span><span class="s">"D"</span><span class="o">,</span><span class="s">"K"</span><span class="o">,</span><span class="s">"A"</span><span class="o">,</span><span class="s">"K"</span><span class="o">,</span><span class="s">"A"</span><span class="o">,</span><span class="s">"K"</span><span class="o">,</span><span class="s">"K"</span><span class="o">,</span><span class="s">"K"</span><span class="o">,</span><span class="s">"Z"</span><span class="o">,</span><span class="s">"D"</span><span class="o">};</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="nc">Integer</span> <span class="n">value</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">().</span><span class="na">iterator</span><span class="o">();</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>       <span class="c1">//auto boxing</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">()</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> 
                                        <span class="n">printBar</span><span class="o">(</span><span class="sc">'*'</span><span class="o">,</span><span class="n">value</span><span class="o">)</span> <span class="o">+</span> <span class="s">" "</span><span class="o">+</span> <span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">printBar</span><span class="o">(</span><span class="kt">char</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">bar</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">value</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bar</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">bar</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">bar</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="go">A:**** 4
D:** 2
Z:* 1
K:******* 7
</span></pre></table></code></div></div><p>한정된 범위 내에 있는 순차적인 값들의 빈도수는 배열을 이용하지만, 이처럼 한정되지 않은 범위의 비순차적인 값들의 빈도수는 <code class="language-plaintext highlighter-rouge">HashMap</code>을 이용해서 구할 수 있다.</p><blockquote><p>결과를 통해 HashMap과 같이 해싱을 구현한 컬렉션 클래스들은 저장순서를 유지하지 않는다는 사실을 다시 한 번 확인하자.</p></blockquote><h3 id="treemap"><strong>TreeMap</strong></h3><p><code class="language-plaintext highlighter-rouge">TreeMap</code>은 이름에서 알 수 있듯이 <code class="language-plaintext highlighter-rouge">이진 검색 트리</code>의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장한다. 그래서 검색과 정렬에 적합한 컬렉션 클래스다.</p><p>앞에서 다 설명한 내용들의 조합이기에 특별한 점은 없다. <code class="language-plaintext highlighter-rouge">HashMap</code>과 <code class="language-plaintext highlighter-rouge">TreeMap</code>의 검색 성능은 대부분의 경우에서 <code class="language-plaintext highlighter-rouge">HashMap</code>이 더 뛰어나지만, 범위검색이나 정렬이 필요한 경우에는 <code class="language-plaintext highlighter-rouge">TreeMap</code>을 사용하도록 하자.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">TreeMapEx</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="o">{</span><span class="s">"A"</span><span class="o">,</span><span class="s">"K"</span><span class="o">,</span><span class="s">"A"</span><span class="o">,</span><span class="s">"K"</span><span class="o">,</span><span class="s">"D"</span><span class="o">,</span><span class="s">"K"</span><span class="o">,</span><span class="s">"A"</span><span class="o">,</span><span class="s">"K"</span><span class="o">,</span><span class="s">"A"</span><span class="o">,</span><span class="s">"K"</span><span class="o">,</span><span class="s">"K"</span><span class="o">,</span><span class="s">"K"</span><span class="o">,</span><span class="s">"Z"</span><span class="o">,</span><span class="s">"D"</span><span class="o">};</span>

        <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="nc">Integer</span> <span class="n">value</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">().</span><span class="na">iterator</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"---기본정렬---"</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">()</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> 
                                        <span class="n">printBar</span><span class="o">(</span><span class="sc">'*'</span><span class="o">,</span><span class="n">value</span><span class="o">)</span> <span class="o">+</span> <span class="s">" "</span><span class="o">+</span> <span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="c1">//map을 ArrayList로 변환한 후 Collections.sort()로 정렬</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">();</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">set</span><span class="o">);</span>

        <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ValueComparator</span><span class="o">());</span>

        <span class="n">it</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"---값의 크기가 큰 순으로 정렬---"</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">()</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> 
                                        <span class="n">printBar</span><span class="o">(</span><span class="sc">'*'</span><span class="o">,</span><span class="n">value</span><span class="o">)</span> <span class="o">+</span> <span class="s">" "</span><span class="o">+</span> <span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ValueComparator</span> <span class="kd">implements</span> <span class="nc">Comparator</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o1</span> <span class="k">instanceof</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span> <span class="o">&amp;&amp;</span> <span class="n">o2</span> <span class="k">instanceof</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span> <span class="n">e1</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">)</span> <span class="n">o1</span><span class="o">;</span>
                <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span> <span class="n">e2</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">)</span> <span class="n">o2</span><span class="o">;</span>

                <span class="kt">int</span> <span class="n">v1</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span><span class="n">e1</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
                <span class="kt">int</span> <span class="n">v2</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span><span class="n">e2</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>

                <span class="k">return</span> <span class="n">v2</span><span class="o">-</span><span class="n">v1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">printBar</span><span class="o">(</span><span class="kt">char</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">bar</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">value</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bar</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">bar</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">bar</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="go">---기본정렬---
A:**** 4
D:** 2
K:******* 7
Z:* 1

---값의 크기가 큰 순으로 정렬---
K:******* 7
A:**** 4
D:** 2
Z:* 1
</span></pre></table></code></div></div><p>이 예제는 직전의 <code class="language-plaintext highlighter-rouge">HashMap</code>예제를 <code class="language-plaintext highlighter-rouge">TreeMap</code>으로 변경한 것인데, <code class="language-plaintext highlighter-rouge">TreeMap</code>을 사용했기 때문에 <code class="language-plaintext highlighter-rouge">HashMap</code>의 결과와 달리 기본적으로 <code class="language-plaintext highlighter-rouge">key</code>가 오름차순으로 정렬되어 있는 것을 알 수 있다.</p><p><code class="language-plaintext highlighter-rouge">key</code>가 <code class="language-plaintext highlighter-rouge">String</code>인스턴스이기 때문에 <code class="language-plaintext highlighter-rouge">String</code> 클래스에 정의된 정렬 기준에 의해서 정렬된 것이고, <code class="language-plaintext highlighter-rouge">Comparator</code>를 구현한 클래스로 <code class="language-plaintext highlighter-rouge">value</code>를 내림차순으로 정렬하는 방법도 알 수 있다.</p><h3 id="그-외"><strong>그 외</strong></h3><h4 id="arrays"><strong>Arrays</strong></h4><p><code class="language-plaintext highlighter-rouge">Arrays</code>클래스에는 배열을 다루는데 유용한 메소드들이 정의되어 있다.</p><ul><li><p><strong>배열의 복사 - copyOf(), copyOfRange()</strong><br /> <code class="language-plaintext highlighter-rouge">copyOf()</code>는 배열 전체를, <code class="language-plaintext highlighter-rouge">copyOfRange()</code>는 배열의 일부를 복사해서 새로운 배열을 만들어 반환한다. <code class="language-plaintext highlighter-rouge">copyOfRange()</code>의 지정된 범위의 끝은 포함되지 않는다. (깊은 복사)</p><li><p><strong>배열 채우기 - fill(), setAll()</strong><br /> <code class="language-plaintext highlighter-rouge">fill()</code>은 배열의 모든 요소를 지정된 값으로 채운다. <code class="language-plaintext highlighter-rouge">setAll()</code>은 배열을 채우는데 사용할 함수형 인터페이스를 매개변수로 받는다. 따라서 이 메소드를 호출할 때는 함수형 인터페이스를 구현한 객체를 매개변수로 전달하던가 람다식을 지정해야 한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>  <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
  <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">9</span><span class="o">);</span>
  <span class="nc">Arrays</span><span class="o">.</span><span class="na">setAll</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">5</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
  <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">print</span><span class="o">);</span>
</pre></table></code></div></div><li><p><strong>배열의 정렬과 탐색 - sort(), binarySearch()</strong><br /> <code class="language-plaintext highlighter-rouge">sort()</code>는 배열을 정렬할 때, <code class="language-plaintext highlighter-rouge">binarySearch()</code>는 배열에 저장된 요소를 검색할 때 사용한다. <code class="language-plaintext highlighter-rouge">binarySearch()</code>는 지정된 값이 저장된 위치(index)를 반환하는데, 반드시 배열이 정렬된 상태여야만 올바른 결과를 얻는다. 그리고 만일 검색한 값과 일치하는 요소들이 여러 개 있다면, 이 중에서 어떤 것의 위치가 반환될지는 알 수 없다.</p><li><p><strong>배열의 비교와 출력 - equals(), toString()</strong><br /> <code class="language-plaintext highlighter-rouge">toString()</code>로 배열의 모든 요소를 문자열로 편하게 출력할 수 있다. 다만 <code class="language-plaintext highlighter-rouge">toString()</code>은 1차원 배열에서만 사용할 수 있으므로 다차원 배열에는 <code class="language-plaintext highlighter-rouge">deepToString()</code>을 사용해야 한다. <code class="language-plaintext highlighter-rouge">deepToString()</code>은 배열의 모든 요소를 재귀적으로 접근해서 문자열을 구성하므로 2차원뿐만 아니라 3차원 이상의 배열에도 동작한다.</p><p><code class="language-plaintext highlighter-rouge">equals()</code>는 두 배열에 저장된 모든 요소를 비교해서 같으면 <code class="language-plaintext highlighter-rouge">true</code>를 반환한다. <code class="language-plaintext highlighter-rouge">equals()</code>도 일차원 배열에만 가능하므로, 다차원 배열의 비교에는 <code class="language-plaintext highlighter-rouge">deepEquals()</code>를 사용하자.</p><li><p><strong>배열을 List로 반환 - asList(Object…a)</strong><br /> <code class="language-plaintext highlighter-rouge">asList()</code>는 배열을 <code class="language-plaintext highlighter-rouge">List</code>에 담아서 반환한다. 매개변수의 타입이 가변인수라서 배열의 생성 없이 저장할 요소들을 나열하는 것도 가능하다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">});</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
  <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">6</span><span class="o">);</span>        <span class="c1">//UnsupportedOperationException 발생</span>
</pre></table></code></div></div><p>한가지 주의할 점은 <code class="language-plaintext highlighter-rouge">asList()</code>가 반환한 <code class="language-plaintext highlighter-rouge">List</code>의 크기를 변경할 수 없다는 것이다. 즉 추가 또는 삭제가 불가능하고 내용변경은 가능하다. 만약 크기를 변경할 수 있는 <code class="language-plaintext highlighter-rouge">List</code>가 필요하다면 다음과 같이 하면 된다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>
</pre></table></code></div></div></ul><h4 id="comparator와-comparable"><strong>Comparator와 Comparable</strong></h4><p><code class="language-plaintext highlighter-rouge">Comparator</code>와 <code class="language-plaintext highlighter-rouge">Comparable</code>은 둘 다 인터페이스로, 컬렉션을 정렬하는데 필요한 메소드를 정의하고 있다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="no">T</span> <span class="n">o</span><span class="o">);</span>
<span class="o">}</span>

<span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="no">T</span> <span class="n">o1</span><span class="o">,</span> <span class="no">T</span> <span class="n">o2</span><span class="o">);</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">compare()</code>와 <code class="language-plaintext highlighter-rouge">compareTo()</code>는 선언형태와 이름이 약간 다를 뿐 두 객체를 비교한다는 같은 기능을 목적을 가진다. 두 메소드에서 비교하는 두 객체가 같으면 0, 비교하는 값보다 작으면 음수, 크면 양수를 반환하도록 구현해야 한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Integer</span> <span class="kd">extends</span> <span class="nc">Number</span> <span class="kd">implements</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">anotherInteger</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">compare</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">,</span> <span class="n">anotherInteger</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="o">((</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><p>위 코드는 실제 <code class="language-plaintext highlighter-rouge">Integer</code>클래스의 일부이다. <code class="language-plaintext highlighter-rouge">Comparable</code>의 <code class="language-plaintext highlighter-rouge">compareTo()</code>를 구현한 것을 알 수 있는데, 두 <code class="language-plaintext highlighter-rouge">Integer</code> 객체의 값을 비교해 같으면 0, 크면 1, 작으면 -1을 반환한다.</p><p><code class="language-plaintext highlighter-rouge">Comparable</code>을 구현한 클래스들이 기본적으로 오름차순으로 정렬되어 있지만, 내림차순으로 정렬하거나 혹은 어떤 다른 기준에 의해서 정렬되도록 하고 싶을 때 <code class="language-plaintext highlighter-rouge">Comparator</code>를 구현해서 정렬 기준을 제공할 수 있다.</p><blockquote><p>Comparator는 익명 클래스로 사용되는 경우가 많다.</p></blockquote><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="s">"cat"</span><span class="o">,</span> <span class="s">"Dog"</span><span class="o">,</span> <span class="s">"lion"</span><span class="o">,</span> <span class="s">"tiger"</span><span class="o">};</span>

    <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>

    <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">CASE_INSENSITIVE_ORDER</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>

    <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">String</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o1</span> <span class="k">instanceof</span> <span class="nc">Comparable</span> <span class="o">&amp;&amp;</span> <span class="n">o2</span> <span class="k">instanceof</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">o1</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">o2</span><span class="o">)</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">});</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
<span class="o">}</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="go">[Dog, cat, lion, tiger]
[cat, Dog, lion, tiger]
[tiger, lion, cat, Dog]
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Arrays.sort()</code>는 배열을 정렬할 때, <code class="language-plaintext highlighter-rouge">Comparator</code>를 지정해주지 않으면 저장하는 객체에 구현된 내용에 따라 정렬된다. (주로 Comprable의 compareTo())</p><p><code class="language-plaintext highlighter-rouge">String</code>의 <code class="language-plaintext highlighter-rouge">Comparable</code>구현은 문자열이 사전 순으로 정렬되도록 작성되어 있다. 문자열의 오름차순 정렬은 공백, 숫자, 대문자, 소문자의 순으로 정렬되는 것을 의미하고, 정확히 얘기하면 유니코드의 순서가 작은 값부터 큰 값으로 정렬되는 것이다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="no">CASE_INSENSITIVE_ORDER</span>
                                         <span class="o">=</span> <span class="k">new</span> <span class="nc">CaseInsensitiveComparator</span><span class="o">();</span>
</pre></table></code></div></div><p>이 <code class="language-plaintext highlighter-rouge">Comparator</code>를 이용하면 문자열을 대소문자 구분없이 정렬할 수 있다.</p><p><code class="language-plaintext highlighter-rouge">String</code>의 기본정렬을 반대로 하는 것, 즉 문자열을 내림차순으로 구현하는 것은 아주 간단한데, <code class="language-plaintext highlighter-rouge">String</code>에 구현된 <code class="language-plaintext highlighter-rouge">compareTo()</code>의 결과에 -1을 곱하기만 하면 된다. 또는 비교하는 객체의 위치를 바꿔서 <code class="language-plaintext highlighter-rouge">o2.compareTo(o1)</code>과 같이 해도 된다.</p><h2 id="참조">참조</h2><p><a href="http://www.yes24.com/Product/Goods/24259565">자바의 정석</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/backend/'>Backend</a>, <a href='/categories/java/'>Java</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >java</a> <a href="/tags/%EC%9E%90%EB%B0%94/" class="post-tag no-text-decoration" >자바</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[JAVA] 컬렉션 프레임워크 (Collections Framework) - yeoji21&url=https://yeoji21.github.io/posts/collections/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[JAVA] 컬렉션 프레임워크 (Collections Framework) - yeoji21&u=https://yeoji21.github.io/posts/collections/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[JAVA] 컬렉션 프레임워크 (Collections Framework) - yeoji21&url=https://yeoji21.github.io/posts/collections/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink('', 'Link copied successfully!')" data-toggle="tooltip" data-placement="top" title="Copy link"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/polymorphism-inheritance/">객체지향에서의 상속과 다형성</a><li><a href="/posts/graduation-project-review/">졸업 작품 프로젝트 회고</a><li><a href="/posts/reflection-1/">[JAVA] Java Refelction 마스터 강의 1장</a><li><a href="/posts/mst/">[알고리즘] MST - 크루스칼 vs 프림</a><li><a href="/posts/injection/">[Spring] 의존성 주입 시 생성자 주입을 사용해야 하는 이유 </a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94/">자바</a> <a class="post-tag" href="/tags/java-study/">java study</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%84%B0%EB%94%94/">자바 스터디</a> <a class="post-tag" href="/tags/oop/">oop</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/guides/">guides</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/javastudy01/"><div class="card-body"> <span class="timeago small" >Aug 8, 2021<i class="unloaded">2021-08-08T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>자바 스터디 01 - JVM이란</h3><div class="text-muted small"><p> 들어가면서 백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다. 강의 링크 : [자바 뉴스 라이브] 2020/11/14, 자바 스터디 1주차 깃허브 링크 : 1주차 과제: JVM은 무엇이며 자바 코드는 어떻게 실행하는 것인가. 목차 JVM이란 무엇인가 컴파일 하는 방법 실행하는 방법 바...</p></div></div></a></div><div class="card"> <a href="/posts/javastudy02/"><div class="card-body"> <span class="timeago small" >Aug 10, 2021<i class="unloaded">2021-08-10T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>자바 스터디 02 - 자바 데이터 타입, 변수 그리고 배열</h3><div class="text-muted small"><p> 들어가면서 백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다. 강의 링크 : [자바 뉴스 라이브] 2020/11/21, 자바 스터디 2주차 깃허브 링크 : 2주차 과제: 자바 데이터 타입, 변수 그리고 배열 목차 프리미티브 타입 종류와 값의 범위 그리고 기본 값 프리미티브 타입과 레퍼런스 타...</p></div></div></a></div><div class="card"> <a href="/posts/javastudy03/"><div class="card-body"> <span class="timeago small" >Aug 11, 2021<i class="unloaded">2021-08-11T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>자바 스터디 03 - 연산자</h3><div class="text-muted small"><p> 들어가면서 백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다. 강의 영상 링크 : [자바 라이브 스터디] 2020/11/28, 자바 스터디 3주차 연산자를 알아보자. 강의 깃허브 링크 : 3주차 과제: 연산자 목차 산술 연산자 비트 연산자 관계 연산자 논리 연산자 instance...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/object_orientation/" class="btn btn-outline-primary" prompt="Older"><p>[도서] 객체지향의 사실과 오해</p></a> <a href="/posts/stream/" class="btn btn-outline-primary" prompt="Newer"><p>[JAVA] 스트림 (Stream)</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">yeoji21</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94/">자바</a> <a class="post-tag" href="/tags/java-study/">java study</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%84%B0%EB%94%94/">자바 스터디</a> <a class="post-tag" href="/tags/oop/">oop</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/guides/">guides</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://yeoji21.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
