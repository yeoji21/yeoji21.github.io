<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="[JPA] JPA 기초 정리 - 2" /><meta name="author" content="yeoji21" /><meta property="og:locale" content="en" /><meta name="description" content="들어가면서 인프런에 있는 김영한님의 자바 ORM 표준 JPA 프로그래밍 - 기본편 강의를 정리한 글입니다. 세부사항이나 설정 등은 포스팅하지 않으니, 자세한 내용은 강의를 통해 확인해주시길 바랍니다." /><meta property="og:description" content="들어가면서 인프런에 있는 김영한님의 자바 ORM 표준 JPA 프로그래밍 - 기본편 강의를 정리한 글입니다. 세부사항이나 설정 등은 포스팅하지 않으니, 자세한 내용은 강의를 통해 확인해주시길 바랍니다." /><link rel="canonical" href="https://yeoji21.github.io/posts/jpa-basic-2/" /><meta property="og:url" content="https://yeoji21.github.io/posts/jpa-basic-2/" /><meta property="og:site_name" content="yeoji21" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-09-19T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[JPA] JPA 기초 정리 - 2" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@yeoji21" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"yeoji21"},"dateModified":"2022-01-11T00:08:15+09:00","datePublished":"2021-09-19T00:00:00+09:00","description":"들어가면서 인프런에 있는 김영한님의 자바 ORM 표준 JPA 프로그래밍 - 기본편 강의를 정리한 글입니다. 세부사항이나 설정 등은 포스팅하지 않으니, 자세한 내용은 강의를 통해 확인해주시길 바랍니다.","headline":"[JPA] JPA 기초 정리 - 2","mainEntityOfPage":{"@type":"WebPage","@id":"https://yeoji21.github.io/posts/jpa-basic-2/"},"url":"https://yeoji21.github.io/posts/jpa-basic-2/"}</script><title>[JPA] JPA 기초 정리 - 2 | yeoji21</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="yeoji21"><meta name="application-name" content="yeoji21"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR:wght@500&display=swap" rel="stylesheet"><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile/img1.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">yeoji21</a></div><div class="site-subtitle font-italic">Don't look back in anger</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/yeoji21" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['yeozone0508','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[JPA] JPA 기초 정리 - 2</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[JPA] JPA 기초 정리 - 2</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> yeoji21 </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Sep 19, 2021, 12:00 AM +0900" >Sep 19, 2021<i class="unloaded">2021-09-19T00:00:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Jan 11, 2022, 12:08 AM +0900" >Jan 11<i class="unloaded">2022-01-11T00:08:15+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7269 words">40 min read</span></div></div><div class="post-content"><h2 id="들어가면서">들어가면서</h2><p>인프런에 있는 김영한님의 <a href="https://www.inflearn.com/course/ORM-JPA-Basic/dashboard">자바 ORM 표준 JPA 프로그래밍 - 기본편</a> 강의를 정리한 글입니다. 세부사항이나 설정 등은 포스팅하지 않으니, 자세한 내용은 강의를 통해 확인해주시길 바랍니다.</p><h2 id="목차">목차</h2><ul><li>값 타입<li>객체지향 쿼리 언어 (JPQL)</ul><h3 id="값-타입"><strong>값 타입</strong></h3><p>JPA의 데이터 타입은 크게 두 가지로 분류할 수 있다.</p><ul><li>엔티티 타입<ul><li><code class="language-plaintext highlighter-rouge">@Entity</code>로 정의하는 객체<li>데이터가 변해도 식별자(PK)로 지속해서 추적 가능</ul><li>값 타입<ul><li><code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">Integer</code>, <code class="language-plaintext highlighter-rouge">String</code>처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체<li>식별자가 없고 값만 있으므로 데이터 변경 시 추적 불가</ul></ul><p>여기서 값 타입은 또 세 가지 유형으로 나뉜다.</p><ul><li>기본값 타입<li>임베디드 타입 (embedded type, 복합 값 타입)<li>컬렉션 값 타입 (collection value type)</ul><p>이 값 타입의 세 가지 유형에 대해 자세히 알아보자.</p><h4 id="기본값-타입">기본값 타입</h4><p>ex) <code class="language-plaintext highlighter-rouge">String name</code>, <code class="language-plaintext highlighter-rouge">Integer age</code>, <code class="language-plaintext highlighter-rouge">double height</code> 기본값 타입은 생명주기를 엔티티에 의존한다. 예를 들어, 회원을 삭제하면 기본값 타입인 이름과 나이 등의 필드는 함께 삭제된다. 이는 기본값 타입만 해당되는 것이 아니고, 엔티티 타입이 아닌 모든 값 타입에 적용된다.</p><p>또한, 값 타입은 공유되도록 사용하면 안되는데, 만약 회원 이름 변경 시 다른 회원의 이름도 함께 변경된다면 큰 문제가 발생할 것이다. <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">double</code> 같은 <code class="language-plaintext highlighter-rouge">primitive type</code>은 절대 공유되지 않는다. 또한, <code class="language-plaintext highlighter-rouge">Integer</code>같은 래퍼 클래스나 <code class="language-plaintext highlighter-rouge">String</code>같은 특수한 클래스는 공유 가능한 객체이지만, 값을 변경할 수 없기때문에 (Integer setInteger()같은건 없음) 사이드 이펙트가 발생하지 않는다.</p><h4 id="임베디드-타입">임베디드 타입</h4><p>임베디드 타입은 새로운 값 타입을 직접 정의해서 사용할 수 있도록 한다. 주로 기본값 타입을 모아서 만들기 때문에 복합 값 타입이라고도 한다.</p><p>임베디드 타입을 사용하기 위해서는 값 타입을 정의하는 클래스에 <code class="language-plaintext highlighter-rouge">@Embeddable</code>, 값 타입을 사용하는 곳에 <code class="language-plaintext highlighter-rouge">@Embedded</code>를 사용하면 된다. 이 때 기본 생성자가 필수이고, 두 개의 어노테이션 중에 하나만 명시해도 컴파일에 문제는 없으나 명확성을 위해 둘 다 명시하는 것이 좋다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">Period</span> <span class="n">workPeriod</span><span class="o">;</span>
    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">Address</span> <span class="n">homeAddress</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nd">@Embeddable</span>
<span class="nd">@Getter</span> <span class="nd">@Setter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Period</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">startDate</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">endDate</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="nd">@Embeddable</span>
<span class="nd">@Getter</span> <span class="nd">@Setter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Address</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">city</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">street</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">Address</span> <span class="n">address</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Address</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
        <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">city</span><span class="o">,</span> <span class="n">address</span><span class="o">.</span><span class="na">city</span><span class="o">)</span> 
        <span class="o">&amp;&amp;</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">street</span><span class="o">,</span> <span class="n">address</span><span class="o">.</span><span class="na">street</span><span class="o">)</span> 
        <span class="o">&amp;&amp;</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">zipcode</span><span class="o">,</span> <span class="n">address</span><span class="o">.</span><span class="na">zipcode</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">city</span><span class="o">,</span> <span class="n">street</span><span class="o">,</span> <span class="n">zipcode</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>임베디드 타입 사용 전후의 테이블은 똑같지만 객체를 임베디드 타입으로 묶음으로써 코드에서 좀 더 객체지향적으로 설계하는 것이다. 또한 임베디드 타입은 재사용이 가능하고, <code class="language-plaintext highlighter-rouge">Period.isWork()</code>처럼 해당 값 타입에만 사용하는 의미있는 메소드를 만들 수 있다는 장점을 가진다.</p><p>만약 한 엔티티에서 같은 값 타입을 두 번 이상 사용하려면 어떻게 해야할까? 그냥 <code class="language-plaintext highlighter-rouge">@Embedded</code>를 두 번 사용하면 컬럼명이 중복되어 오류가 발생할 것이다. 따라서 <code class="language-plaintext highlighter-rouge">@AttributeOverrides</code>, <code class="language-plaintext highlighter-rouge">@AttributeOverride</code>를 사용해서 컬럼명을 다르게 지정해야 한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span><span class="o">{</span>
    <span class="o">....</span>
    <span class="nd">@Embeded</span>
    <span class="kd">private</span> <span class="nc">Address</span> <span class="n">homeAddress</span><span class="o">;</span>

    <span class="nd">@Embeded</span>
    <span class="nd">@AttributeOverrides</span><span class="o">({</span>
        <span class="nd">@AttributeOverrid</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"city"</span><span class="o">,</span> <span class="n">column</span><span class="o">=</span><span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"work_city"</span><span class="o">)),</span>
        <span class="nd">@AttributeOverrid</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"street"</span><span class="o">,</span> <span class="n">column</span><span class="o">=</span><span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"work_street"</span><span class="o">)),</span>
        <span class="nd">@AttributeOverrid</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"zipcode"</span><span class="o">,</span> <span class="n">column</span><span class="o">=</span><span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"work_zipcode"</span><span class="o">))</span>
    <span class="o">})</span>
    <span class="kd">private</span> <span class="nc">Address</span> <span class="n">workAddress</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="값-타입과-불변-객체">값 타입과 불변 객체</h4><p>임베디드 타입같은 값 타입을 여러 엔티티에서 공유하면 예기치 못한 부작용(side effect)이 발생할 수 있다.</p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/20.png" width="500" /></p><p>위 그림에서 회원1과 회원2가 같은 <code class="language-plaintext highlighter-rouge">Address</code>의 참조를 가지고있다. 이것을 코드로 표현하면 아래와 같다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="nc">Address</span> <span class="n">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"city"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">);</span>
<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
<span class="n">member</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"member1"</span><span class="o">);</span>
<span class="n">member</span><span class="o">.</span><span class="na">setHomeAddress</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

<span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
<span class="n">member2</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"member2"</span><span class="o">);</span>
<span class="n">member2</span><span class="o">.</span><span class="na">setHomeAddress</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>

<span class="n">member</span><span class="o">.</span><span class="na">getHomeAddress</span><span class="o">().</span><span class="na">setCity</span><span class="o">(</span><span class="s">"newCity"</span><span class="o">);</span>
</pre></table></code></div></div><p>이렇게 되면, <code class="language-plaintext highlighter-rouge">UPDATE</code> 쿼리가 두 방 나가고, <code class="language-plaintext highlighter-rouge">member1</code>과 <code class="language-plaintext highlighter-rouge">member2</code> 모두 <code class="language-plaintext highlighter-rouge">city</code>가 <code class="language-plaintext highlighter-rouge">newCity</code>로 변경된다. 이것은 명백한 사이드 이펙트이고, 이런 오류는 발견하기 굉장히 어렵다. 만약 개발자가 이런 동작을 의도했다하더라도 이런 방식을 원하면 임베디드 타입이 아니라 엔티티로 공유했어야 한다.</p><p>임베디드 타입은 객체로 만들어지기 때문에 참조 값을 직접 대입하는 것을 막을 방법이 없다. 따라서 참조를 공유하더라도 객체의 타입을 수정할 수 없게 만들어서 부작용을 원천 차단해야 하기 때문에 값 타입은 <code class="language-plaintext highlighter-rouge">불변 객체(immutable object)</code>로 설계해야 한다. 이를 위해 생성자로만 값을 설정하도록 하고 <code class="language-plaintext highlighter-rouge">Setter</code>를 만들지 않으면 된다.</p><blockquote><p>Integer, String은 자바가 제공하는 대표적인 불변 객체이다.</p></blockquote><h4 id="값-타입의-비교">값 타입의 비교</h4><p>값 타입에서는 인스턴스가 달라도 그 안의 값이 같으면 같은 것으로 봐야하기 때문에 <code class="language-plaintext highlighter-rouge">equals()</code>와 <code class="language-plaintext highlighter-rouge">hashCode()</code>를 적절히 오버라이딩해야 한다. 인텔리제이의 자동생성을 사용하면 편리한데, 이 때 <code class="language-plaintext highlighter-rouge">Getter</code> 사용 옵션을 켜야 엔티티가 프록시일 때도 접근이 가능하므로 꼭 켜주도록 하자.</p><h4 id="값-타입-컬렉션">값 타입 컬렉션</h4><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/21.png" width="500" /></p><p>값을 하나 이상 저장하는 컬렉션을 사용할 때, 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없기때문에 이것을 저장하기 위해 <code class="language-plaintext highlighter-rouge">@ElementCollection</code>과 <code class="language-plaintext highlighter-rouge">@CollectionTable</code>을 사용해서 별도의 테이블을 따로 만들어야 한다.(개념적으로 보면 일대다 매핑)</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="nd">@ElementCollection</span>
    <span class="nd">@CollectionTable</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"favorite_food"</span><span class="o">,</span> <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"member_id"</span><span class="o">))</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"food_name"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">favoriteFoods</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>

    <span class="nd">@ElementCollection</span>
    <span class="nd">@CollectionTable</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"address"</span><span class="o">,</span> <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"member_id"</span><span class="o">))</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Address</span><span class="o">&gt;</span> <span class="n">addressHistory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>값타입 컬렉션도 결국 값타입이다. 값타입은 스스로의 생명주기를 가지지않고 엔티티에 종속적이기 때문에 컬렉션 내의 데이터들은 다른 테이블에 저장됨에도 불구하고</p><p>엔티티만 <code class="language-plaintext highlighter-rouge">persist</code>해도 컬렉션 내의 데이터들은 자동으로 테이블에 저장된다. 따라서 컬렉션들은 기본이 지연로딩 전략이 사용되고, 영속성 전이(Cascade)와 고아 객체 제거기능을 필수로 가진다고 볼 수 있다.</p><p>하지만 값 타입 컬렉션은 여러 가지 한계점을 가진다.</p><ul><li>값 타입은 엔티티와 다르게 식별자 개념이 없다.<ul><li>값타입 컬렉션 내의 값을 변경하고 싶을 때도 <code class="language-plaintext highlighter-rouge">Setter</code>를 사용해서는 안되고, <code class="language-plaintext highlighter-rouge">remove()</code>를 통해서 해당 값을 지우고 <code class="language-plaintext highlighter-rouge">add()</code>를 통해서 새로운 값을 넣어야 한다.</ul><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>  <span class="n">member</span><span class="o">.</span><span class="na">getAddressHistory</span><span class="o">().</span><span class="na">remove</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"old1"</span><span class="o">,</span><span class="s">"street"</span><span class="o">,</span><span class="s">"10000"</span><span class="o">));</span>
  <span class="n">member</span><span class="o">.</span><span class="na">getAddressHistory</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"newCity1"</span><span class="o">,</span><span class="s">"street"</span><span class="o">,</span><span class="s">"10000"</span><span class="o">));</span>
</pre></table></code></div></div><blockquote><p>기본적으로 컬렉션들은 remove 시에 equals()를 통해 해당 데이터를 찾기 때문에, 값타입의 equals를 항상 구현해두어야 함</p></blockquote><li><p>값을 변경하면 추적이 어렵다.</p><li>값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다.<ul><li>위의 <code class="language-plaintext highlighter-rouge">remove()</code> 후 <code class="language-plaintext highlighter-rouge">add()</code> 코드의 쿼리를 살펴보면, <code class="language-plaintext highlighter-rouge">ADDRESS</code> 테이블에서 해당 <code class="language-plaintext highlighter-rouge">member_id</code>를 가진 데이터를 모두 <code class="language-plaintext highlighter-rouge">delete</code> 해버리고 새로 갈아끼운다.(데이터의 개수만큼 insert 쿼리가 나감)</ul><li>값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 PK를 구성해야 한다. 따라서 <code class="language-plaintext highlighter-rouge">null</code> 입력이 불가하고, 중복 저장이 허용되지 않는다.</ul><p>따라서 실무에서 사용할 때는 <strong>값 타입 컬렉션 대신에 일대다 매핑을 고려해야 한다.</strong></p><p>일대다 관계를 위한 엔티티를 만들고 여기에서 값 타입을 사용한다. 이 때 영속성 전이와 고아 객체 제거를 사용해서 값 타입 컬렉션처럼 동작하도록 사용하면 된다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="nd">@Getter</span> <span class="nd">@Setter</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"ADDRESS"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AddressEntity</span><span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Address</span> <span class="n">address</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>이렇게 <code class="language-plaintext highlighter-rouge">Address</code>를 엔티티로 한 번 감싸주고</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nd">@ElementCollection</span>
<span class="nd">@CollectionTable</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"address"</span><span class="o">,</span> <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"member_id"</span><span class="o">))</span>
<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Address</span><span class="o">&gt;</span> <span class="n">addressHistory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</pre></table></code></div></div><p>이렇게 값 타입 컬렉션으로 사용하던 부분을</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nd">@OneToMany</span><span class="o">(</span><span class="n">cascade</span> <span class="o">=</span> <span class="nc">CascadeType</span><span class="o">.</span><span class="na">ALL</span><span class="o">,</span> <span class="n">orphanRemoval</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"member_id"</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">AddressEntity</span><span class="o">&gt;</span> <span class="n">addressHistory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</pre></table></code></div></div><p>이렇게 일대다 연관관계 매핑으로 바꾸면 된다.</p><h3 id="객체지향-쿼리-언어-jpql"><strong>객체지향 쿼리 언어 (JPQL)</strong></h3><h4 id="jpql이란">JPQL이란?</h4><p>JPA를 사용하면 엔티티 객체를 중심으로 개발을 하게되기 때문에 검색을 할 때도 실제 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 검색할 수 있어야 한다. 따라서 이러한 엔티티 중심적인 쿼리를 지원하기 위해서 JPA는 <strong>SQL을 추상화한 JPQL이라는 객체지향 쿼리 언어</strong>를 제공한다.</p><p>기본 SQL과 가장 큰 차이점은 <strong>JPQL은 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 쿼리</strong>한다는 점이다. 이 때 SQL을 추상화하기 때문에 특정 SQL 문법에 의존하지 않는다. 따라서 JQPL을 한 마디로 정의하자면 객체지향 SQL이라고 볼 수 있다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"select m from Member m where m.age &gt; 18"</span><span class="o">;</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
</pre></table></code></div></div><pre><code class="language-database">Hibernate: 
    /* select
        m 
    from
        Member m 
    where
        m.age &gt; 18 */ select
            member0_.id as id1_0_,
            member0_.age as age2_0_,
            member0_.team_id as team_id4_0_,
            member0_.username as username3_0_ 
        from
            Member member0_ 
        where
            member0_.age&gt;18
</code></pre><h4 id="jpql-문법">JPQL 문법</h4><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"select m from Member m where m.username like '%kim%'"</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
</pre></table></code></div></div><p>여기서 <code class="language-plaintext highlighter-rouge">Member</code>는 테이블 이름이 아니고 엔티티 이름이며, <code class="language-plaintext highlighter-rouge">Member</code>, <code class="language-plaintext highlighter-rouge">username</code>처럼 엔티티와 속성은 대소문자를 구분해야 하고, <code class="language-plaintext highlighter-rouge">select</code>, <code class="language-plaintext highlighter-rouge">from</code>, <code class="language-plaintext highlighter-rouge">where</code>같은 JPQL 키워드는 대소문자를 구분하지 않는다.</p><p>이 때 엔티티 이름에 대한 별칭(alias)이 필수이며, as는 생략 가능하다.</p><ul><li>TypeQuery, Query<ul><li>TypeQuery : 반환 타입이 명확할 때 사용<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">TypeQuery</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select m from Member m"</span>
                                                 <span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</pre></table></code></div></div><li>Query : 반환 타입이 명확하지 않을 때 사용<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">Qeury</span> <span class="n">query</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select m.username, m.age from Member m"</span><span class="o">);</span>
</pre></table></code></div></div></ul><li>결과 조회 API<ul><li><p><code class="language-plaintext highlighter-rouge">query.getResultList()</code> : 결과가 하나 이상일 때 <code class="language-plaintext highlighter-rouge">List</code>를 반환, 결과가 없으면 빈 리스트를 반환</p><li><p><code class="language-plaintext highlighter-rouge">query.getSingleResult()</code> : 결과가 정확히 하나일 때 단일 객체 반환, <br /> 결과가 없으면 javax.persistence.NoResultException,<br /> 둘 이상이면 javax.persistence.NonUniqueResultException</p></ul><li>파라미터 바인딩 - 이름 기준<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>  <span class="nc">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"select m from Member m where m.username=:username"</span>
  <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span><span class="s">"member1"</span><span class="o">).</span><span class="na">getSingleResult</span><span class="o">();</span>
</pre></table></code></div></div><p>순서(위치)기준으로 파라미터 바인딩하는 방법도 있으나, 순서가 바뀔 수 있으므로 사용하지 않아야 한다.</p><li>페이징 API<br /> JPA는 페이징을 다음 두 가지 API로 추상화하였다.<ul><li><code class="language-plaintext highlighter-rouge">setFirstResult(int startPosition)</code> : 조회 시작 위치 (0부터 시작)<li><code class="language-plaintext highlighter-rouge">setMaxResults(int maxResult)</code> : 조회할 데이터 수</ul><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>  <span class="nc">String</span> <span class="n">jpql</span> <span class="o">=</span> <span class="s">"select m from Member m order by m.name desc"</span><span class="o">;</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">jpql</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
                          <span class="o">.</span><span class="na">setFirstResult</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
                          <span class="o">.</span><span class="na">setMaxResults</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span>
                          <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</pre></table></code></div></div></ul><h4 id="프로젝션">프로젝션</h4><p>프로젝션이란, <code class="language-plaintext highlighter-rouge">SELECT</code>절에서 조회할 대상을 지정하는 것을 말한다. <br /> 프로젝션 대상 : 엔티티, 임베디드 타입, 스칼라 타입(숫자,문자 등 기본 데이터 타입)</p><ul><li>select <code class="language-plaintext highlighter-rouge">m</code> from Member m -&gt; 엔티티 프로젝션<li>select <code class="language-plaintext highlighter-rouge">m.team</code> from Member m -&gt; 엔티티 프로젝션<li>select <code class="language-plaintext highlighter-rouge">m.address</code> from Member m -&gt; 임베디드 타입 프로젝션<li>select <code class="language-plaintext highlighter-rouge">m.username, m.age</code> from Member m -&gt; 스칼라 타입 프로젝션</ul><p>엔티티 프로젝션하면 <code class="language-plaintext highlighter-rouge">List</code>로 반환된 것들이 모두 영속성 컨텍스트 내에서 엔티티로 관리된다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select m from Member m"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
<span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">findMember</span><span class="o">.</span><span class="na">setAge</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>
</pre></table></code></div></div><p>이 상황에서 <code class="language-plaintext highlighter-rouge">findMember</code>에 대한 <code class="language-plaintext highlighter-rouge">UPDATE</code> 쿼리가 나가는 것을 확인할 수 있기때문에 영속성 컨텍스트에 의해 관리된다는 것을 알 수 있다.</p><p>스칼라 타입 프로젝션에서 여러 값을 조회할 때 데이터의 자료형이 다르다면 어떻게 받아와야 할까?</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"select m.usernmae, m.age from Member m"</span><span class="o">;</span>
</pre></table></code></div></div><p>이에 대한 세 가지 방법이 있다.</p><ol><li><code class="language-plaintext highlighter-rouge">Query</code> 타입으로 조회<li><code class="language-plaintext highlighter-rouge">Object[]</code> 타입으로 조회<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre> <span class="nc">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"select m.username, m.age from Member m"</span>
 <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">[]&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">query</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
 <span class="nc">Object</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">resultList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"username = "</span> <span class="o">+</span> <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"age = "</span> <span class="o">+</span> <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
</pre></table></code></div></div><li><code class="language-plaintext highlighter-rouge">new</code> 명령어로 조회<br /> 조회할 데이터들을 담은 <code class="language-plaintext highlighter-rouge">DTO</code>를 만들어 바로 조회한다.<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre> <span class="kn">package</span> <span class="nn">jpql</span><span class="o">;</span>

 <span class="nd">@AllArgsConstructor</span>
 <span class="nd">@Getter</span> <span class="nd">@Setter</span>
 <span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberDTO</span><span class="o">{</span>
     <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>
     <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
 <span class="o">}</span>
</pre></table></code></div></div><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre> <span class="nc">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"select new jpql.MemberDTO(m.username, m.name) from Member m"</span>
 <span class="nc">List</span><span class="o">&lt;</span><span class="nc">MemberDTO</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="nc">MemberDTO</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
 <span class="nc">MemberDTO</span> <span class="n">memberDTO</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"username = "</span> <span class="o">+</span> <span class="n">memberDTO</span><span class="o">.</span><span class="na">getUsername</span><span class="o">());</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"age = "</span> <span class="o">+</span> <span class="n">memberDTO</span><span class="o">.</span><span class="na">getAge</span><span class="o">());</span>
</pre></table></code></div></div><p>이 때 DTO의 패키지명을 포함한 클래스명을 적어줘야 하고, 순서와 타입이 일치하는 생성자를 만들어 두어야 한다.</p></ol><h4 id="조인">조인</h4><ul><li>내부 조인<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="n">select</span> <span class="n">m</span> <span class="n">from</span> <span class="nc">Member</span> <span class="n">m</span> <span class="o">[</span><span class="n">inner</span><span class="o">]</span> <span class="n">join</span> <span class="n">m</span><span class="o">.</span><span class="na">team</span> <span class="n">t</span>
</pre></table></code></div></div><li>외부 조인<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="n">select</span> <span class="n">m</span> <span class="n">from</span> <span class="nc">Member</span> <span class="n">m</span> <span class="n">left</span> <span class="o">[</span><span class="n">outer</span><span class="o">]</span> <span class="n">join</span> <span class="n">m</span><span class="o">.</span><span class="na">team</span> <span class="n">t</span>
</pre></table></code></div></div><li>세타 조인<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="n">select</span> <span class="nf">count</span><span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="n">from</span> <span class="nc">Member</span> <span class="n">m</span><span class="o">,</span> <span class="nc">Team</span> <span class="n">t</span> <span class="n">where</span> <span class="n">m</span><span class="o">.</span><span class="na">username</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">name</span>
</pre></table></code></div></div></ul><h4 id="on을-이용한-join">on을 이용한 join</h4><p>조인 대상을 필터링하거나 연관관계가 없는 엔티티와 외부 조인할 때 <code class="language-plaintext highlighter-rouge">on</code>을 사용한다.</p><ol><li>조인 대상 필터링<br /> ex) 회원과 팀을 조인하면서 팀 이름이 A인 팀만 조인<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre> <span class="n">select</span> <span class="n">m</span><span class="o">,</span> <span class="n">t</span> <span class="n">from</span> <span class="nc">Member</span> <span class="n">m</span> <span class="n">left</span> <span class="n">join</span> <span class="n">m</span><span class="o">.</span><span class="na">team</span> <span class="n">t</span> <span class="n">on</span> <span class="n">t</span><span class="o">.</span><span class="na">name</span><span class="o">=</span><span class="sc">'A'</span>
</pre></table></code></div></div><div lang="sql" class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre> <span class="k">select</span> <span class="n">m</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="o">*</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">left</span> <span class="k">join</span> <span class="n">Team</span> <span class="n">t</span> 
                                     <span class="k">on</span> <span class="n">m</span><span class="p">.</span><span class="n">team_id</span><span class="o">=</span><span class="n">t</span><span class="p">.</span><span class="n">id</span> <span class="k">and</span> <span class="n">t</span><span class="p">.</span><span class="n">name</span><span class="o">=</span><span class="s1">'A'</span>
</pre></table></code></div></div><li>연관관계가 없는 엔티티와 외부 조인<br /> ex) 회원의 이름과 팀의 이름이 같은 대상 외부 조인<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre> <span class="n">select</span> <span class="n">m</span><span class="o">,</span> <span class="n">t</span> <span class="n">from</span> <span class="nc">Member</span> <span class="n">m</span> <span class="n">left</span> <span class="n">join</span> <span class="nc">Team</span> <span class="n">t</span> <span class="n">on</span> <span class="n">m</span><span class="o">.</span><span class="na">username</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">name</span>
</pre></table></code></div></div><div lang="sql" class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre> <span class="k">select</span> <span class="n">m</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="o">*</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">left</span> <span class="k">join</span> <span class="n">Team</span> <span class="n">t</span> <span class="k">on</span> <span class="n">m</span><span class="p">.</span><span class="n">usernmae</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">name</span>
</pre></table></code></div></div></ol><h4 id="서브쿼리">서브쿼리</h4><ul><li>나이가 평균보다 많은 회원<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">select</span> <span class="n">m</span> <span class="n">from</span> <span class="nc">Member</span> <span class="n">m</span> <span class="n">where</span> <span class="n">m</span><span class="o">.</span><span class="na">age</span> <span class="o">&gt;</span> <span class="o">(</span><span class="n">select</span> <span class="nf">avg</span><span class="o">(</span><span class="n">m2</span><span class="o">.</span><span class="na">age</span><span class="o">)</span> <span class="n">from</span> <span class="nc">Member</span> <span class="n">m2</span><span class="o">)</span>
</pre></table></code></div></div><p>메인쿼리와 서브쿼리는 서로 연관관계가 없기 때문에 m과 m2는 서로 다르다. 서브쿼리에서 m을 사용하면 성능이 저하된다.</p><li>한 건이라도 주문한 고객<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">select</span> <span class="n">m</span> <span class="n">from</span> <span class="nc">Member</span> <span class="n">m</span> <span class="nf">where</span> <span class="o">(</span><span class="n">select</span> <span class="nf">count</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="n">from</span> <span class="nc">Order</span> <span class="n">o</span> <span class="n">where</span> <span class="n">m</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="na">member</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
</pre></table></code></div></div><li>팀 A 소속인 회원<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">select</span> <span class="n">m</span> <span class="n">from</span> <span class="nc">Member</span> <span class="n">m</span> <span class="n">where</span> <span class="nf">exists</span><span class="o">(</span><span class="n">select</span> <span class="n">t</span> <span class="n">from</span> <span class="n">m</span><span class="o">.</span><span class="na">team</span> <span class="n">t</span> <span class="n">where</span> <span class="n">t</span><span class="o">.</span><span class="na">name</span><span class="o">=</span><span class="s">"팀A"</span><span class="o">)</span>
</pre></table></code></div></div><li>어떤 팀이든 팀에 소속된 회원<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">select</span> <span class="n">m</span> <span class="n">from</span> <span class="nc">Member</span> <span class="n">m</span> <span class="n">where</span> <span class="n">m</span><span class="o">.</span><span class="na">team</span> <span class="o">=</span> <span class="n">any</span><span class="o">(</span><span class="n">select</span> <span class="n">t</span> <span class="n">from</span> <span class="nc">Team</span> <span class="n">t</span><span class="o">)</span>
</pre></table></code></div></div><li>JPA 서브쿼리의 한계<ul><li><p>JPA는 <code class="language-plaintext highlighter-rouge">where</code>, <code class="language-plaintext highlighter-rouge">having</code>절에서만 서브쿼리를 사용할 수 있다. <br /> (하이버네이트는 <code class="language-plaintext highlighter-rouge">select</code>절에서도 서브쿼리를 사용할 수 있도록 지원)</p><li><p><code class="language-plaintext highlighter-rouge">from</code>절의 서브쿼리는 현재 JPQL에서는 불가능<br /> 조인으로 풀 수 있으면 풀어서 해결해야 함</p></ul></ul><h4 id="조건식---case-식">조건식 - CASE 식</h4><p>기본 CASE 식</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">query</span> <span class="o">=</span>  <span class="s">"select 
                    case
                        when m.age &lt;= 20 then '학생'
                        else '성인'
                    end
                from Member m"</span><span class="o">;</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
</pre></table></code></div></div><p>단순 CASE 식</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">select</span>
    <span class="k">case</span> <span class="n">t</span><span class="o">.</span><span class="na">name</span>
        <span class="n">when</span> <span class="s">"팀A"</span> <span class="n">then</span> <span class="s">"인센티브110%"</span>
        <span class="n">when</span> <span class="s">"팀B"</span> <span class="n">then</span> <span class="s">"인센티브120%"</span>
        <span class="k">else</span> <span class="s">"인센티브105%"</span>
    <span class="n">end</span>
<span class="n">from</span> <span class="nc">Team</span> <span class="n">t</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">COALESCE</code> : 하나씩 조회해서 null인 경우 값을 대체</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">select</span> <span class="nf">coalesce</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">username</span><span class="o">,</span> <span class="s">"이름없는 회원"</span><span class="o">)</span> <span class="n">from</span> <span class="nc">Member</span> <span class="n">m</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">NULLIF</code> : 두 값이 같으면 null반환, 다르면 첫 번째 인자의 값 반환</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">select</span> <span class="nf">nullif</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">username</span><span class="o">,</span> <span class="s">"관리자"</span><span class="o">)</span> <span class="n">from</span> <span class="nc">Member</span> <span class="n">m</span>
</pre></table></code></div></div><h4 id="jpql-타입-표현">JPQL 타입 표현</h4><ul><li>문자 : ‘HELLO’ , ‘She’’s’<li>숫자 : 10L (Long), 10D (Double), 10F (Float)<li>Boolean : TRUE, FALSE<li>ENUM : jpabook.MemberType.Admin (패키지명 포함)<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>  <span class="nc">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"select m.username, 'HELLO', true from Member m "</span> 
                                  <span class="o">+</span> <span class="s">"where m.type=:userType"</span><span class="o">;</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">[]&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">query</span><span class="o">)</span>
                          <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"userType"</span><span class="o">,</span> <span class="nc">MemberType</span><span class="o">.</span><span class="na">ADMIN</span><span class="o">)</span>
                          <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</pre></table></code></div></div><p>이렇게 파라미터 바인딩을 사용하면 enum의 전체 패키지명을 명시하지 않고 import해서 사용할 수 있다.</p><li>엔티티 타입 : TYPE(m) = Member (상속 관계에서 사용)<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>  <span class="nc">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"select i from Item i where type(i) = Book"</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">creaeteQuery</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="nc">Item</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
</pre></table></code></div></div></ul><h4 id="경로-표현식">경로 표현식</h4><p>경로 표현식이란 <code class="language-plaintext highlighter-rouge">.</code>(점)을 찍어 객체 그래프를 탐색하는 것을 말한다.</p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/22.png" width="400" /></p><ul><li>상태 필드(state field) : 단순히 값을 저장하기 위한 필드. 경로 탐색의 끝이므로 추가 탐색 x<li>연관 필드(association field) : 연관관계를 위한 필드<ul><li>단일 값 연관 필드 : @ManyToOne, @OneToOne -&gt; 대상이 엔티티 <br /> 묵시적 내부 조인 발생, 탐색 o<li>컬렉션 값 연관 필드 : @OneToMany, @ManyToMany -&gt; 대상이 컬렉션 <br /> 묵시적 내부 조인 발생, 탐색 x</ul></ul><p>JPQL에서 단일 값 연관 경로를 사용하면 내부적으로 <code class="language-plaintext highlighter-rouge">inner join</code>을 사용하는 쿼리가 나가는데, <code class="language-plaintext highlighter-rouge">join</code> 같은 쿼리가 묵시적으로 나가면 직관적이지도 않고 운영/튜닝이 너무 힘들어지기 때문에 좋지않다. 가장 좋은 방법은 묵시적 조인을 사용하지않고 명시적 조인을 사용하는 것이다.</p><p>위가 <code class="language-plaintext highlighter-rouge">JPQL</code> 쿼리이고, 아래가 해당 <code class="language-plaintext highlighter-rouge">JPQL</code>로 인해 만들어지는 <code class="language-plaintext highlighter-rouge">SQL</code> 쿼리이다. 묵시적으로 <code class="language-plaintext highlighter-rouge">inner join</code>을 사용하는 것을 알 수 있다.</p><div lang="sql" class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">select</span> <span class="n">o</span><span class="p">.</span><span class="n">member</span> <span class="k">from</span> <span class="k">Order</span> <span class="n">o</span>
</pre></table></code></div></div><div lang="sql" class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">select</span> <span class="n">m</span><span class="p">.</span><span class="o">*</span> <span class="k">from</span> <span class="k">Order</span> <span class="n">o</span> <span class="k">inner</span> <span class="k">join</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">on</span> <span class="n">o</span><span class="p">.</span><span class="n">member_id</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">id</span>
</pre></table></code></div></div><p>컬렉션 값 연관 경로도 묵시적인 내부 조인이 발생하는데, 탐색은 되지 않는다. 탐색이 안된다는 말은 즉, 해당 컬렉션의 멤버변수에 접근할 수 없다는 것을 의미한다. 대신 <code class="language-plaintext highlighter-rouge">.size</code>로 컬렉션의 크기를 구할 수는 있다. 컬렉션의 탐색을 위해서는 <code class="language-plaintext highlighter-rouge">from</code>절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통해서 탐색할 수 있다.</p><h4 id="jpql---패치-조인-fetch-join">JPQL - 패치 조인 (fetch join)</h4><p><code class="language-plaintext highlighter-rouge">[LEFT [OUTER] | INNNER ] JOIN FETCH 조인경로</code></p><p>패치 조인은 SQL이 제공하는 join의 종류가 아니고 JPQL에서 성능을 최적화하기 위해 제공하는 기능이다. 마치 즉시로딩을 사용하는 것처럼, 연관된 엔티티나 컬렉션을 SQL 하나로 한번에 조회한다.</p><p>다음 예제를 살펴보자.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="nc">Team</span> <span class="n">teamA</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">();</span>
<span class="n">teamA</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"A팀"</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">teamA</span><span class="o">);</span>

<span class="nc">Team</span> <span class="n">teamB</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">();</span>
<span class="n">teamB</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"B팀"</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">teamB</span><span class="o">);</span>

<span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
<span class="n">member1</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"회원1"</span><span class="o">);</span>
<span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">teamA</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>

<span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
<span class="n">member2</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"회원2"</span><span class="o">);</span>
<span class="n">member2</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">teamA</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>

<span class="nc">Member</span> <span class="n">member3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
<span class="n">member3</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"회원3"</span><span class="o">);</span>
<span class="n">member3</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">teamB</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member3</span><span class="o">);</span>

<span class="n">em</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
<span class="n">em</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>

<span class="nc">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"select m from Member m"</span><span class="o">;</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
<span class="n">result</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"member = "</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="na">getUsername</span><span class="o">()</span> 
                        <span class="o">+</span> <span class="s">" : "</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="na">getTeam</span><span class="o">().</span><span class="na">getName</span><span class="o">()));</span>
<span class="n">transaction</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre><td class="rouge-code"><pre><span class="go">Hibernate: 
    /* insert ch10.Team
        */ insert 
        into
            Team
            (name, team_id) 
        values
            (?, ?)
Hibernate: 
    /* insert ch10.Team
        */ insert 
        into
            Team
            (name, team_id) 
        values
            (?, ?)
Hibernate: 
    /* insert ch10.Member
        */ insert 
        into
            Member
            (age, team_id, username, id) 
        values
            (?, ?, ?, ?)
Hibernate: 
    /* insert ch10.Member
        */ insert 
        into
            Member
            (age, team_id, username, id) 
        values
            (?, ?, ?, ?)
Hibernate: 
    /* insert ch10.Member
        */ insert 
        into
            Member
            (age, team_id, username, id) 
        values
            (?, ?, ?, ?)
Hibernate: 
    /* select
        m 
    from
        Member m */ select
            member0_.id as id1_0_,
            member0_.age as age2_0_,
            member0_.team_id as team_id4_0_,
            member0_.username as username3_0_ 
        from
            Member member0_
Hibernate: 
    select
        team0_.team_id as team_id1_1_0_,
        team0_.name as name2_1_0_ 
    from
        Team team0_ 
    where
        team0_.team_id=?
member = 회원1 : A팀
member = 회원2 : A팀
Hibernate: 
    select
        team0_.team_id as team_id1_1_0_,
        team0_.name as name2_1_0_ 
    from
        Team team0_ 
    where
        team0_.team_id=?
member = 회원3 : B팀
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">select m from Member m</code>로 <code class="language-plaintext highlighter-rouge">JPQL</code>을 작성하니, <code class="language-plaintext highlighter-rouge">Team</code>은 프록시 값이 들어가있어서 사용할 때마다 따로 쿼리가 나가는 것을 확인할 수 있다. 만약 회원이 100명있다면 쿼리가 100번이 나간다. 이런 현상을 <code class="language-plaintext highlighter-rouge">N+1 문제</code>라고 한다. 이것을 해결하는 방법이 패치 조인이다.</p><p>패치 조인을 사용하는 방법은 간단한데,</p><div lang="sql" class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">select</span> <span class="n">m</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">join</span> <span class="k">fetch</span> <span class="n">m</span><span class="p">.</span><span class="n">team</span>
</pre></table></code></div></div><p>이렇게 <code class="language-plaintext highlighter-rouge">m.team</code>과의 <code class="language-plaintext highlighter-rouge">join fetch</code>를 명시하면 <code class="language-plaintext highlighter-rouge">Member</code> 뿐 아니라 <code class="language-plaintext highlighter-rouge">Team</code>도 함께 조회한다.</p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/23.png" width="600" /></p><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="go">Hibernate: 
    /* select
        m 
    from
        Member m 
    join
        fetch m.team */ select
            member0_.id as id1_0_0_,
            team1_.team_id as team_id1_1_1_,
            member0_.age as age2_0_0_,
            member0_.team_id as team_id4_0_0_,
            member0_.username as username3_0_0_,
            team1_.name as name2_1_1_ 
        from
            Member member0_ 
        inner join
            Team team1_ 
                on member0_.team_id=team1_.team_id
member = 회원1 : A팀
member = 회원2 : A팀
member = 회원3 : B팀
</span></pre></table></code></div></div><p>이전 결과와 달리 쿼리 한 번으로 원하는 결과를 얻어왔다.</p><p>그런데 만약 <code class="language-plaintext highlighter-rouge">Member</code>에서 <code class="language-plaintext highlighter-rouge">team</code>을 <code class="language-plaintext highlighter-rouge">@ManyToOne</code>으로 매핑할 때 <code class="language-plaintext highlighter-rouge">LAZY</code> 옵션을 주지 않고 <code class="language-plaintext highlighter-rouge">select m from Member m</code>로 쿼리를 날리면 어떻게 될까?</p><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="go">Hibernate: 
    /* select
        m 
    from
        Member m */ select
            member0_.id as id1_0_,
            member0_.age as age2_0_,
            member0_.team_id as team_id4_0_,
            member0_.username as username3_0_ 
        from
            Member member0_
Hibernate: 
    select
        team0_.team_id as team_id1_1_0_,
        team0_.name as name2_1_0_ 
    from
        Team team0_ 
    where
        team0_.team_id=?
Hibernate: 
    select
        team0_.team_id as team_id1_1_0_,
        team0_.name as name2_1_0_ 
    from
        Team team0_ 
    where
        team0_.team_id=?
member = 회원1 : A팀
member = 회원2 : A팀
member = 회원3 : B팀
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">select</code> 쿼리가 <code class="language-plaintext highlighter-rouge">N+1번</code> 발생하는 것을 알 수 있다. 따라서 <strong>즉시 로딩이든 지연 로딩이든 상관없이 발생하는 N+1 문제</strong>를 <code class="language-plaintext highlighter-rouge">fetch join</code>이 해결해준다.</p><p>아래는 컬렉션 패치 조인의 간단한 예제이다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"select t from Team t join fetch t.members"</span><span class="o">;</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Team</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="nc">Team</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
<span class="n">result</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"team = "</span><span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span><span class="s">" : "</span><span class="o">);</span>
    <span class="n">t</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">getUsername</span><span class="o">()+</span><span class="s">" "</span><span class="o">));</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
<span class="o">});</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="go">team = A팀 : 회원1 회원2 
team = A팀 : 회원1 회원2 
team = B팀 : 회원3 
</span></pre></table></code></div></div><p>그런데 결과를 보면 A팀에 대한 결과가 중복해서 나타나는 것을 확인할 수 있는데, 일대다 매핑에서 <code class="language-plaintext highlighter-rouge">join</code>하면 데이터가 뻥튀기되기 때문이다. 현재 <code class="language-plaintext highlighter-rouge">Team</code> 테이블에는 2개의 데이터가 있지만 조인하면서 3개로 합쳐지기 때문에 A팀의 내용이 두 번 나온 것이다.</p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/24.png" width="450" /></p><p><code class="language-plaintext highlighter-rouge">SQL의 DISTINCT</code>만으로는 우리가 없애려는 중복을 모두 없앨 수 없어서 <code class="language-plaintext highlighter-rouge">JPQL의 DISTINCT</code>를 사용해야 한다. JPQL의 DISTINCT는 SQL에 DISTINCT를 추가하고, 애플리케이션에서 같은 식별자(PK)를 가진 엔티티를 중복으로 판단하고 제거한다.</p><p><code class="language-plaintext highlighter-rouge">select distinct t from Team t join fetch t.members</code> 사용</p><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="go">team = A팀 : 회원1 회원2 
team = B팀 : 회원3 
</span></pre></table></code></div></div><p>우리가 원하던 결과를 확인할 수 있다.</p><p><strong>패치 조인의 특징과 한계</strong></p><ul><li>패치 조인 대상에는 별칭을 줄 수 없다. 하이버네이트는 가능하나, 사용하지 않는 것이 좋다.<li>둘 이상의 컬렉션은 패치 조인할 수 없다.<li>컬렉션을 패치 조인하면 페이징 API를 사용할 수 없다.<ul><li>일대일, 다대일 같은 단일 값 연관 필드들은 패치 조인해도 페이징 가능<li>하이버네이트의 경우, 컴파일러가 경고 로그를 남기고 메모리에서 페이징하는데 이 때 테이블의 데이터를 모두 메모리로 가져와서 페이징하기 때문에 문제가 생길 여지가 매우 큼<li>따라서 이런 경우, 다대일로 쿼리 방향을 뒤집어서 페이징 API를 사용할 수는 있는데 이러면 N+1 문제가 발생<li>이 때 <code class="language-plaintext highlighter-rouge">BatchSize</code>를 적용하면 쿼리가 N번 수행되지 않고, where 조건절이 in 절로 바뀌어 수행되기 때문에 성능이 향상된다.<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>  <span class="nd">@Entity</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span><span class="o">{</span>
  <span class="o">...</span>
  <span class="nd">@BatchSize</span><span class="o">(</span><span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="o">)</span>
  <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span><span class="o">=</span><span class="s">"team"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  <span class="o">}</span>
</pre></table></code></div></div><p>이렇게 하면 팀 테이블과 연관된 멤버를 최대 100개까지 한 번에 가져온다</p><blockquote><p>&lt;property name=”hibernate.default_batch_fetch_size” value=”100”/&gt; <br /> BatchSize는 persistence.xml에서 위 처럼 전역설정을 할 수도 있다. (값은 1,000 이하로 줄 것)</p></blockquote></ul><li>연관된 엔티티들을 SQL 한 번으로 조회하기 때문에 성능 최적화에 유리하다.<li>엔티티에 직접 적용하는 지연 로딩 전략보다 우선순위가 높다.<li>패치 조인은 객체 그래프를 유지할 때 사용하면 효과적이다.<li>여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하면, 패치 조인 보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적이다.</ul><h4 id="jpql---다형성-쿼리">JPQL - 다형성 쿼리</h4><ul><li>TYPE : 조회 대상을 특정 자식으로 한정<br /> ex) Item 중에 Book, Movie를 조회<div lang="sql" class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">select</span> <span class="n">i</span> <span class="k">from</span> <span class="n">Item</span> <span class="n">i</span> <span class="k">where</span> <span class="k">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span> <span class="p">(</span><span class="n">Book</span><span class="p">,</span> <span class="n">Movie</span><span class="p">)</span>
</pre></table></code></div></div><li>TREAT : 상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용<br /> FROM, WEHRE, SELECT(하이버네이트 지원)에서 사용<br /> ex) 부모인 Item과 자식 Book<div lang="sql" class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">select</span> <span class="n">i</span> <span class="k">from</span> <span class="n">Item</span> <span class="n">i</span> <span class="k">where</span> <span class="k">treat</span><span class="p">(</span><span class="n">i</span> <span class="k">as</span> <span class="n">Book</span><span class="p">).</span><span class="n">author</span> <span class="o">=</span> <span class="s1">'kim'</span>
</pre></table></code></div></div></ul><h4 id="jpql---엔티티-직접-사용">JPQL - 엔티티 직접 사용</h4><p>JPQL에서 엔티티를 직접 사용하면 SQL에서는 해당 엔티티의 PK를 사용한다.</p><div lang="sql" class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
<span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
</pre></table></code></div></div><p>위의 두 가지 JPQL은 내부적으로 같은 SQL을 생성한다.</p><p>엔티티를 파라미터로 전달</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">jpql</span> <span class="o">=</span> <span class="s">"select m from Member m where m =: member"</span><span class="o">;</span>
<span class="nc">List</span> <span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQeury</span><span class="o">(</span><span class="n">jpql</span><span class="o">).</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"member"</span><span class="o">,</span><span class="n">member</span><span class="o">)</span>
                <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</pre></table></code></div></div><p>식별자를 직접 전달</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">jpql</span> <span class="o">=</span> <span class="s">"select m from Member m where m.id =: memberId"</span><span class="o">;</span>
<span class="nc">List</span> <span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQeury</span><span class="o">(</span><span class="n">jpql</span><span class="o">).</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"memberId"</span><span class="o">,</span><span class="n">memberId</span><span class="o">)</span>
                <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</pre></table></code></div></div><p>실행된 SQL</p><div lang="sql" class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">select</span> <span class="n">m</span><span class="p">.</span><span class="o">*</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">where</span> <span class="n">m</span><span class="p">.</span><span class="n">id</span><span class="o">=?</span>
</pre></table></code></div></div><h4 id="jpql---named-쿼리">JPQL - Named 쿼리</h4><p>Named 쿼리란 이름 그대로 미리 정의해서 이름을 부여해두고 사용하는 JPQL을 말한다. 애플리케이션이 시작되어 로딩될 때 Named 쿼리를 파싱해서 가지고 있다가 사용될 때마다 재사용하기 때문에 쿼리로 변환할 때 필요한 코스트를 줄일 수 있다는 장점을 가지고, 애플리케이션 로딩 시점에 쿼리를 검사할 수 있다는 장점을 가진다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="nd">@NamedQuery</span><span class="o">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"Member.findByUsername"</span><span class="o">,</span>
    <span class="n">query</span> <span class="o">=</span> <span class="s">"select m from Member m where m.username =:username"</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span><span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><p>이 때 만약 query에 오타가 나거나 잘못적은게 있다면 컴파일 시점에 예외가 발생해서 잘못된 쿼리임을 검사할 수 있다는 엄청난 장점을 가진다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createNamedQuery</span><span class="o">(</span><span class="s">"Member.findByUsername"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span><span class="s">"회원1"</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
</pre></table></code></div></div><p>이후에 <code class="language-plaintext highlighter-rouge">Spring Data JPA</code>를 사용하면, <code class="language-plaintext highlighter-rouge">@Query</code> 어노테이션을 사용해서 메소드 위에 Named Query를 만들 수 있어서 편리하게 사용 가능하다.</p><h4 id="jpql---벌크-연산">JPQL - 벌크 연산</h4><p>벌크연산은 흔히 알고있는 <code class="language-plaintext highlighter-rouge">UPDATE</code>나 <code class="language-plaintext highlighter-rouge">DELETE</code>문이라고 보면 되는데, JPA의 변경 감지만으로만 실행하려면 매번 하나씩 UPDATE문이 발생되어 너무 많은 SQL문이 실행되어야 하므로 벌크 연산을 사용한다.</p><p>쿼리 한 번으로 테이블의 여러 로우를 변경한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">resultCount</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"update Member m set m.age = 20"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span>
</pre></table></code></div></div><p>벌크연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리하기 때문에 벌크연산 후 영속성 컨텍스트를 초기화해주어야만 데이터가 꼬이지 않는다.</p><p>JPQL 실행 시 자동으로 <code class="language-plaintext highlighter-rouge">flush()</code>는 되지만 영속성 컨텍스트를 초기화하기 위해서는 <code class="language-plaintext highlighter-rouge">clear()</code>로 영속성 컨텍스트를 비워줘야 한다. <code class="language-plaintext highlighter-rouge">Spring Data JPA</code>에서는 <code class="language-plaintext highlighter-rouge">@Modifying</code>을 통해 벌크연산을 실행하면서 옵션을 통해 <code class="language-plaintext highlighter-rouge">clear()</code>까지 자동화할 수 있다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/backend/'>Backend</a>, <a href='/categories/orm/'>ORM</a>, <a href='/categories/jpa/'>JPA</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >java</a> <a href="/tags/jpa/" class="post-tag no-text-decoration" >jpa</a> <a href="/tags/spring/" class="post-tag no-text-decoration" >spring</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[JPA] JPA 기초 정리 - 2 - yeoji21&url=https://yeoji21.github.io/posts/jpa-basic-2/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[JPA] JPA 기초 정리 - 2 - yeoji21&u=https://yeoji21.github.io/posts/jpa-basic-2/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[JPA] JPA 기초 정리 - 2 - yeoji21&url=https://yeoji21.github.io/posts/jpa-basic-2/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink('', 'Link copied successfully!')" data-toggle="tooltip" data-placement="top" title="Copy link"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/polymorphism-inheritance/">객체지향에서의 상속과 다형성</a><li><a href="/posts/graduation-project-review/">졸업 작품 프로젝트 회고</a><li><a href="/posts/reflection-1/">[JAVA] Java Refelction 마스터 강의 1장</a><li><a href="/posts/mst/">[알고리즘] MST - 크루스칼 vs 프림</a><li><a href="/posts/injection/">[Spring] 의존성 주입 시 생성자 주입을 사용해야 하는 이유 </a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94/">자바</a> <a class="post-tag" href="/tags/java-study/">java study</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%84%B0%EB%94%94/">자바 스터디</a> <a class="post-tag" href="/tags/oop/">oop</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/guides/">guides</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/jpa-basic-1/"><div class="card-body"> <span class="timeago small" >Sep 13, 2021<i class="unloaded">2021-09-13T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[JPA] JPA 기초 정리 - 1</h3><div class="text-muted small"><p> 들어가면서 인프런에 있는 김영한님의 자바 ORM 표준 JPA 프로그래밍 - 기본편 강의를 정리한 글입니다. 세부사항이나 설정 등은 포스팅하지 않으니, 자세한 내용은 강의를 통해 확인해주시길 바랍니다. 목차 JPA 시작 영속성 관리 엔티티 매핑 연관관계 매핑 기초 다양한 연관관계 매핑 고급 매핑 프록시와 연관관계 관리 J...</p></div></div></a></div><div class="card"> <a href="/posts/spring-data-jpa1/"><div class="card-body"> <span class="timeago small" >Oct 3, 2021<i class="unloaded">2021-10-03T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[JPA] Spring Data JPA</h3><div class="text-muted small"><p> 들어가면서 인프런에 있는 김영한님의 실전! 스프링 데이터 JPA 강의를 정리한 글입니다. 세부사항이나 설정 등은 포스팅하지 않으니, 자세한 내용은 강의를 통해 확인해주시길 바랍니다. 목차 공통 인터페이스 기능 쿼리 메소드 기능 페이징과 정렬 벌크성 수정 쿼리 @EntityGraph 확장 기능 새로운 엔티티를 구별하는 방법 ...</p></div></div></a></div><div class="card"> <a href="/posts/jpa-one-to-one/"><div class="card-body"> <span class="timeago small" >Jul 17<i class="unloaded">2022-07-17T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[JPA] @OneToOne 연관관계 매핑 시 주의사항</h3><div class="text-muted small"><p> 이번 포스트에서는 JPA의 @OneToOne 매핑을 사용하면서 마주한 문제에 대해 얘기해보겠습니다. 결론부터 말씀드리자면 JPA에서 OneToOne 관계로 엔티티를 연결할 경우, Lazy Loading이 보장되지 않을 수 있습니다. 어떤 경우에 이런 문제가 발생하고, 어떻게 해결하면 좋을까요? 문제 상황을 간단히 하면 다음과 같습니다. 하나의...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/jpa-basic-1/" class="btn btn-outline-primary" prompt="Older"><p>[JPA] JPA 기초 정리 - 1</p></a> <a href="/posts/spring-mvc-1/" class="btn btn-outline-primary" prompt="Newer"><p>[Spring] Spring MVC</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">yeoji21</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94/">자바</a> <a class="post-tag" href="/tags/java-study/">java study</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%84%B0%EB%94%94/">자바 스터디</a> <a class="post-tag" href="/tags/oop/">oop</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/guides/">guides</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://yeoji21.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
