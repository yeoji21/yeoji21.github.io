<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="[JPA] JPA 기초 정리 - 1" /><meta name="author" content="yeoji21" /><meta property="og:locale" content="en" /><meta name="description" content="들어가면서 인프런에 있는 김영한님의 자바 ORM 표준 JPA 프로그래밍 - 기본편 강의를 정리한 글입니다. 세부사항이나 설정 등은 포스팅하지 않으니, 자세한 내용은 강의를 통해 확인해주시길 바랍니다." /><meta property="og:description" content="들어가면서 인프런에 있는 김영한님의 자바 ORM 표준 JPA 프로그래밍 - 기본편 강의를 정리한 글입니다. 세부사항이나 설정 등은 포스팅하지 않으니, 자세한 내용은 강의를 통해 확인해주시길 바랍니다." /><link rel="canonical" href="https://yeoji21.github.io/posts/jpa-basic-1/" /><meta property="og:url" content="https://yeoji21.github.io/posts/jpa-basic-1/" /><meta property="og:site_name" content="yeoji21" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-09-13T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[JPA] JPA 기초 정리 - 1" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@yeoji21" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"yeoji21"},"dateModified":"2021-12-28T12:51:40+09:00","datePublished":"2021-09-13T00:00:00+09:00","description":"들어가면서 인프런에 있는 김영한님의 자바 ORM 표준 JPA 프로그래밍 - 기본편 강의를 정리한 글입니다. 세부사항이나 설정 등은 포스팅하지 않으니, 자세한 내용은 강의를 통해 확인해주시길 바랍니다.","headline":"[JPA] JPA 기초 정리 - 1","mainEntityOfPage":{"@type":"WebPage","@id":"https://yeoji21.github.io/posts/jpa-basic-1/"},"url":"https://yeoji21.github.io/posts/jpa-basic-1/"}</script><title>[JPA] JPA 기초 정리 - 1 | yeoji21</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="yeoji21"><meta name="application-name" content="yeoji21"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR:wght@500&display=swap" rel="stylesheet"><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile/img1.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">yeoji21</a></div><div class="site-subtitle font-italic">Don't look back in anger</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/yeoji21" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['yeozone0508','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[JPA] JPA 기초 정리 - 1</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[JPA] JPA 기초 정리 - 1</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> yeoji21 </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Sep 13, 2021, 12:00 AM +0900" >Sep 13, 2021<i class="unloaded">2021-09-13T00:00:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Dec 28, 2021, 12:51 PM +0900" >Dec 28, 2021<i class="unloaded">2021-12-28T12:51:40+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7730 words">42 min read</span></div></div><div class="post-content"><h2 id="들어가면서">들어가면서</h2><p>인프런에 있는 김영한님의 <a href="https://www.inflearn.com/course/ORM-JPA-Basic/dashboard">자바 ORM 표준 JPA 프로그래밍 - 기본편</a> 강의를 정리한 글입니다. 세부사항이나 설정 등은 포스팅하지 않으니, 자세한 내용은 강의를 통해 확인해주시길 바랍니다.</p><h2 id="목차">목차</h2><ul><li>JPA 시작<li>영속성 관리<li>엔티티 매핑<li>연관관계 매핑 기초<li>다양한 연관관계 매핑<li>고급 매핑<li>프록시와 연관관계 관리</ul><h3 id="jpa-시작"><strong>JPA 시작</strong></h3><h4 id="hello-jpa---애플리케이션-개발">Hello JPA - 애플리케이션 개발</h4><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/1.png" width="500" /></p><h4 id="객체와-테이블을-생성하고-매핑하기">객체와 테이블을 생성하고 매핑하기</h4><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="nd">@Getter</span> <span class="nd">@Setter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span><span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><div lang="sql" class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">create</span> <span class="k">table</span> <span class="n">Member</span><span class="p">(</span>
    <span class="n">id</span> <span class="nb">bigint</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
    <span class="k">primary</span> <span class="k">key</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">);</span>
</pre></table></code></div></div><h4 id="회원-등록">회원 등록</h4><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">EntityManagerFactory</span> <span class="n">emf</span> <span class="o">=</span> <span class="nc">Persistence</span><span class="o">.</span><span class="na">createEntityManagerFactory</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
    <span class="nc">EntityManager</span> <span class="n">em</span> <span class="o">=</span> <span class="n">emf</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>
    <span class="nc">EntityTransaction</span> <span class="n">transaction</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>
    <span class="n">transaction</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
    <span class="k">try</span><span class="o">{</span>
        <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
        <span class="n">member</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
        <span class="n">member</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"memberA"</span><span class="o">);</span>
        <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
        <span class="n">transaction</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
    <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">){</span>
        <span class="n">transaction</span><span class="o">.</span><span class="na">rollback</span><span class="o">();</span>
    <span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
        <span class="n">em</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="n">emf</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="회원수정">회원수정</h4><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
<span class="n">findMember</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"HelloJPA"</span><span class="o">);</span>
<span class="n">transaction</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Collection</code>에서 데이터를 꺼내서 수정한 뒤 다시 컬렉션에 저장하지 않는 것처럼, <code class="language-plaintext highlighter-rouge">JPA</code>로 꺼내 온 데이터도 수정한 뒤에 다시 저장하지 않는다.</p><h4 id="회원-삭제">회원 삭제</h4><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">findMember</span><span class="o">);</span>
<span class="n">transaction</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
</pre></table></code></div></div><h4 id="회원-모두-조회---jpql">회원 모두 조회 - JPQL</h4><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select m from Member as m"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
                                                                <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
<span class="n">result</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">getUsername</span><span class="o">()));</span>
</pre></table></code></div></div><h3 id="영속성-관리"><strong>영속성 관리</strong></h3><p>JPA에서 가장 중요한 두 가지는 아래와 같다.</p><ul><li>객체와 관계형 데이터베이스 매핑하기 (Object Relational Mapping)<li>영속성 컨텍스트</ul><h4 id="영속성-컨텍스트란">영속성 컨텍스트란?</h4><p>영속성 컨텍스트는 눈에 보이지 않는 논리적인 개념인데, <strong>엔티티를 영구 저장하는 환경</strong>이라는 뜻이다. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있게 된다.</p><p>예를 들어, <code class="language-plaintext highlighter-rouge">EntityManager.persist(entity)</code>는 사실 DB에 데이터를 저장하는 것이 아니고 엔티티를 영속성 컨텍스트에 저장하는 메소드이다.</p><h4 id="엔티티의-생명주기">엔티티의 생명주기</h4><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/8.png" width="500" /></p><ul><li><p>비영속 (new/transient)<br /> 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태</p><li><p>영속 (managed)<br /> 영속성 컨텍스트에 의해 관리되고 있는 상태</p><li><p>준영속 (detached)<br /> 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)된 상태, 영속성 컨텍스트가 제공하는 기능을 사용하지 못한다.</p><li><p>삭제 (removed)<br /> 삭제된 상태</p></ul><h4 id="영속성-컨텍스트의-이점">영속성 컨텍스트의 이점</h4><ul><li><p>1차 캐시<br /> DB에서 데이터를 조회하기 위해 <code class="language-plaintext highlighter-rouge">em.find()</code>를 호출하면 바로 DB에서 데이터를 찾는 것이 아니고 영속성 컨텍스트 내의 1차 캐시에서 먼저 데이터를 찾아본다.</p><p>만약 1차 캐시에 없는 데이터를 읽으려고 하면 DB에서 해당 데이터를 조회한 후 1차캐시에 저장 후 데이터를 반환해준다.</p><blockquote><p>1차 캐시는 한 트랜잭션 안에서만 유효하기 때문에 캐시로 인한 성능적 이점이 매우 크지는 않다.</p></blockquote><li><p>동일성(identity) 보장</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>  <span class="nc">Member</span> <span class="n">memberOne</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
  <span class="nc">Member</span> <span class="n">memberTwo</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">memberOne</span> <span class="o">==</span> <span class="n">memberTwo</span><span class="o">);</span>     <span class="c1">//true</span>
</pre></table></code></div></div><p>마치 컬렉션에서 데이터를 꺼내서 비교하는 것처럼 JPA에서 같은 PK를 통해 꺼내온 데이터는 동일성이 보장된다.</p><li><p>트랜잭션을 지원하는 쓰기 지연 (transactional write-behind)</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>  <span class="n">transaction</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
  <span class="nc">Member</span> <span class="n">memberA</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"memberA"</span><span class="o">);</span>
  <span class="nc">Member</span> <span class="n">memberB</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"memberB"</span><span class="o">);</span>

  <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">memberA</span><span class="o">);</span>
  <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">memberB</span><span class="o">);</span>
  <span class="c1">//여기까지 INSERT QUERY를 DB에 보내지 않고</span>
    
  <span class="c1">//커밋하는 순간 DB에 쿼리를 전송</span>
  <span class="n">transaction</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
</pre></table></code></div></div><p>JPA 관련 메소드 실행 시, 바로 DB에 쿼리를 보내지 않고 우선 영속성 컨텍스트 내 <code class="language-plaintext highlighter-rouge">쓰기 지연 SQL 저장소</code>에 저장해둔다. 그리고 <code class="language-plaintext highlighter-rouge">commit()</code>이 호출되거나 <code class="language-plaintext highlighter-rouge">flush()</code>를 호출될 때 쓰기 지연 SQL 저장소에 보관하고 있던 쿼리들을 DB에 반영하는 <code class="language-plaintext highlighter-rouge">쓰기 지연</code> 방식을 사용한다.</p><li><p>변경감지(Dirty Checking)</p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/11.png" width="500" /></p><p>앞서 언급한 것처럼, JPA로 꺼내온 엔티티의 데이터를 수정한 뒤에 다시 DB에 해당 엔티티를 저장하는 코드를 작성하지 않아도 된다.</p><p>영속성 컨텍스트 내 1차 캐시에서는 해당 엔티티들의 스냅샷을 가지고 있기때문에 엔티티의 데이터 변경이 발생하면 자동으로 <code class="language-plaintext highlighter-rouge">UPDATE</code> 쿼리를 보낸다.</p><li><p>지연 로딩(Lazy Loading)<br /> 만약 <code class="language-plaintext highlighter-rouge">Member</code>라는 엔티티와 <code class="language-plaintext highlighter-rouge">Team</code> 엔티티가 다대일 관계로 매핑되어 있을 때, <code class="language-plaintext highlighter-rouge">Member</code> 엔티티를 조회할 시 <code class="language-plaintext highlighter-rouge">Team</code> 엔티티의 값을 바로 읽어오지 않고 프록시 값으로 채워진다. 이후 <code class="language-plaintext highlighter-rouge">Team</code> 엔티티의 값을 사용해야 할 때가 되어서야 <code class="language-plaintext highlighter-rouge">Team</code> 엔티티를 조회하는데, 이러한 방식을 지연 로딩이라 한다.</p><p><code class="language-plaintext highlighter-rouge">@ManyToOne(fetch = FetchType.EAGER)</code>를 사용해서 fatch 타입을 LAZY에서 EAGER로 변환하면 즉시 로딩을 사용할 수도 있는데, 관련 내용은 이후에 엔티티 매핑 파트에서 더 자세히 다루겠다.</p></ul><h4 id="플러시">플러시</h4><p><code class="language-plaintext highlighter-rouge">flush()</code>는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것을 말한다. <code class="language-plaintext highlighter-rouge">flush()</code>를 호출한다고 1차 캐시에 있는 내용이 영향을 받는 것은 아니고, 단지 쓰기 지연 저장소에 있던 SQL이 DB에 반영된다.</p><p>영속성 컨텍스트를 플러시하기 위해서는 다음과 같은 방법이 있다.</p><ul><li><code class="language-plaintext highlighter-rouge">em.flush()</code> - 직접호출<li>트랜잭션 커밋 - 플러시 자동 호출<li>JPQL 쿼리 실행 - 플러시 자동 호출</ul><h3 id="엔티티-매핑"><strong>엔티티 매핑</strong></h3><h4 id="엔티티-매핑-어노테이션">엔티티 매핑 어노테이션</h4><ul><li>객체와 테이블 매핑 : <code class="language-plaintext highlighter-rouge">@Entity</code>, <code class="language-plaintext highlighter-rouge">@Table</code><li>필드와 컬럼 매핑 : <code class="language-plaintext highlighter-rouge">@Column</code><li>기본 키 매핑 : <code class="language-plaintext highlighter-rouge">@Id</code><li>연관관계 매핑 : <code class="language-plaintext highlighter-rouge">@ManyToOne</code>, <code class="language-plaintext highlighter-rouge">@JoinColumn</code></ul><h4 id="1-객체와-테이블-매핑">1. 객체와 테이블 매핑</h4><p><code class="language-plaintext highlighter-rouge">@Entity</code>가 붙은 클래스는 JPA가 관리하고, 이것을 엔티티라고 한다. JPA를 사용해서 테이블과 매핑할 클래스는 <code class="language-plaintext highlighter-rouge">@Entity</code>가 필수이다. 해당 엔티티 클래스에는 <strong>기본 생성자</strong>가 필수이고 <code class="language-plaintext highlighter-rouge">final</code> 클래스나 <code class="language-plaintext highlighter-rouge">enum</code>, <code class="language-plaintext highlighter-rouge">interface</code>, <code class="language-plaintext highlighter-rouge">inner</code> 클래스는 엔티티가 될 수 없다.</p><p><code class="language-plaintext highlighter-rouge">@Table</code>은 엔티티와 매핑할 테이블을 지정한다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">속성<th style="text-align: right">기능<tbody><tr><td style="text-align: right">name<td style="text-align: right">매핑할 테이블 이름<tr><td style="text-align: right">catalog<td style="text-align: right">데이터베이스 catalog 매핑<tr><td style="text-align: right">schema<td style="text-align: right">데이터베이스 schema 매핑<tr><td style="text-align: right">uniqueConstraints(DDL)<td style="text-align: right">DDL 생성 시에 유니크 제약 조건 생성</table></div><h4 id="2-필드와-컬럼-매핑">2. 필드와 컬럼 매핑</h4><p>매핑 어노테이션 정리</p><div class="table-wrapper"><table><tbody><tr><td>어노테이션<td>설명<tr><td>@Column<td>컬럼 매핑<tr><td>@Temporal<td>날짜 타입 매핑<tr><td>@Enumerated<td>enum 타입 매핑<tr><td>@Lob<td>BLOB, CLOB 매핑<tr><td>@Transient<td>특정 필드를 컬럼에 매핑하지 않음</table></div><p>위 어노테이션들을 하나씩 자세히 알아보자</p><p><strong>@Column</strong></p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">속성<th style="text-align: right">설명<th style="text-align: right">기본값<tbody><tr><td style="text-align: right">name<td style="text-align: right">필드와 매핑할 테이블의 컬럼명<td style="text-align: right">객체의 필드이름<tr><td style="text-align: right">insertable,<br /> updatable<td style="text-align: right">등록, 변경 가능 여부<td style="text-align: right">TRUE<tr><td style="text-align: right">nullable(DDL)<td style="text-align: right">null값 허용 여부. false로 설정하면 DDL 생성 시에 <br /> not null 제약 조건이 붙는다.<td style="text-align: right"> <tr><td style="text-align: right">unique(DDL)<td style="text-align: right">@Table의 uniqueConstraints와 같은 역할<td style="text-align: right"> <tr><td style="text-align: right">columnDefinition(DDL)<td style="text-align: right">데이터베이스 컬럼 정보를 직접 입력<br /> ex) varchar(100) default ‘EMPTY’<td style="text-align: right">필드의 자바 타입과 방언 정보<tr><td style="text-align: right">length(DDL)<td style="text-align: right">문자 길이 제약 조건, String타입에만 사용<td style="text-align: right">255<tr><td style="text-align: right">precision, <br /> scale(DDL)<td style="text-align: right">BigDecimal이나 BigInteger처럼 아주 큰 숫자나 <br />정밀한 소수를 다룰 때 사용<td style="text-align: right">precision = 19,<br />scale=2</table></div><p><strong>@Enumerated</strong><br /> : 자바 enum 타입을 매핑할 때 사용</p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">속성<th style="text-align: right">설명<th style="text-align: right">기본값<tbody><tr><td style="text-align: right">value<td style="text-align: right">EnumType.ORDINAL : enum 순서를 저장 <br /> EnumType.STRING : enum 이름을 저장<td style="text-align: right">EnumType.ORDINAL</table></div><p>기본값이 <code class="language-plaintext highlighter-rouge">ORDINAL</code>이므로, <code class="language-plaintext highlighter-rouge">@Enumerated</code>를 사용할 때는 항상 <code class="language-plaintext highlighter-rouge">value</code> 설정을 명시적으로 <code class="language-plaintext highlighter-rouge">STRING</code>으로 변경해주자</p><p><strong>@Temporal</strong><br /> : 날짜 타입(<code class="language-plaintext highlighter-rouge">java.util.Date</code>, <code class="language-plaintext highlighter-rouge">java.util.Calendar</code>)을 매핑할 때 사용한다. Java8 이후 버전은 <code class="language-plaintext highlighter-rouge">LocalDate</code>, <code class="language-plaintext highlighter-rouge">LocalDateTime</code>을 사용하면 <code class="language-plaintext highlighter-rouge">@Temporal</code>을 사용하지 않아도 자동 매핑된다.</p><div class="table-wrapper"><table><thead><tr><th>속성<th style="text-align: left">설명<tbody><tr><td>value<td style="text-align: left">TemporalType.DATE : 날짜를 데이터베이스 date 타입과 매핑<br />(ex. 2021-09-15)<br />TemporalType.TIME : 시간과 데이터베이스 time 타입을 매핑 <br /> (ex. 18:01:42)<br /> TemporalType.TIMESTAMP : 날짜와 시간을 데이터베이스 timestamp 타입과 매핑 <br /> (ex. 2021-09-15 18:01:42)</table></div><p><strong>@Lob</strong><br /> : 데이터베이스 BLOB, CLOB 타입과 매핑</p><p>여기서 <code class="language-plaintext highlighter-rouge">LOB</code>이란 Text, 그래픽, 이미지, 비디오, 사운드 등 구조화되지 않은 대형 데이터를 저장하는 타입을 말한다. <code class="language-plaintext highlighter-rouge">BLOB</code>은 이진 대형 객체를 저장하고, <code class="language-plaintext highlighter-rouge">CLOB</code>은 문자 대형 객체를 저장한다.</p><p><code class="language-plaintext highlighter-rouge">@Lob</code>은 따로 지정할 수 있는 속성이 없다. 매핑하는 필드 타입이 문자면 <code class="language-plaintext highlighter-rouge">CLOB</code>에 매핑되고, 나머지는 모두 <code class="language-plaintext highlighter-rouge">BLOB</code>으로 매핑된다.</p><p><strong>@Transient</strong><br /> : 해당 필드를 데이터베이스에 매핑하지 않도록 한다. 주로 메모리 상에서만 임시로 어떤 값을 보관하고 싶을 때 사용한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nd">@Transient</span>
<span class="kd">private</span> <span class="nc">Integer</span> <span class="n">temp</span><span class="o">;</span>
</pre></table></code></div></div><h4 id="3-기본-키-매핑">3. 기본 키 매핑</h4><p>기본 키 매핑에 사용하는 어노테이션은 <code class="language-plaintext highlighter-rouge">@Id</code>와 <code class="language-plaintext highlighter-rouge">@GeneratedValue</code>가 있다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nd">@Id</span> <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">AUTO</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
</pre></table></code></div></div><p><strong>기본 키 매핑 방법</strong></p><ul><li>직접 할당 : <code class="language-plaintext highlighter-rouge">@Id</code>만 사용<li>자동 생성 : <code class="language-plaintext highlighter-rouge">@GeneratedValue</code><ul><li>IDENTITY : 데이터베이스에 위임, MYSQL<li>SEQUENCE : 데이터베이스 시퀀스 오브젝트 사용, ORACLE (@SequenceGenerator 필요)<li>TABLE : 키 생성용 테이블 사용, 모든 DB에서 사용가능 (@TableGenerator 필요)<li>AUTO : 방언에 따라 자동 지정, AUTO가 defualt임</ul></ul><p><strong>IDENTITY 전략 - 특징</strong></p><ul><li>기본 키 생성을 데이터베이스에 위임한다.<li>주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용 (MySQL의 <code class="language-plaintext highlighter-rouge">AUTO_INCREMENT</code>)<li>JPA는 영속성 컨텍스트 내에서 기본값을 기준으로 1차 캐시에 엔티티들을 저장하고 있다가 트랜잭션 커밋 시점에 <code class="language-plaintext highlighter-rouge">INSERT SQL</code>을 실행하는데, IDENTITY를 사용하면 DB에 INSERT SQL을 사용한 후에 기본값을 알 수 있다.<br /> 때문에 IDENTITY 전략을 사용할 때는 <code class="language-plaintext highlighter-rouge">em.persist()</code>호출 시점에 즉시 INSERT SQL을 실행하고 DB에서 기본값을 조회한다.</ul><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nd">@Id</span> <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">IDENTITY</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
</pre></table></code></div></div><p><strong>SEQUENCE 전략 - 특징</strong></p><ul><li>데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트이다. (Oracle의 시퀀스)<li>Oracle, PostgreSQL, DB2, H2 데이터베이스에서 사용한다.</ul><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="nd">@SequenceGenerator</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"DIGIMON_SEQ_GENERATOR"</span><span class="o">,</span>
        <span class="n">sequenceName</span> <span class="o">=</span> <span class="s">"DIGIMON_SEQ"</span><span class="o">,</span> <span class="c1">//매핑할 데이터베이스 시퀀스 이름</span>
        <span class="n">initialValue</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">allocationSize</span> <span class="o">=</span> <span class="mi">1</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Digimon</span><span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">SEQUENCE</span><span class="o">,</span> 
            <span class="n">generator</span> <span class="o">=</span> <span class="s">"DIGIMON_SEQ_GENERATOR"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>SEQUENCE - @SequenceGenerator</strong></p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">속성<th style="text-align: right">설명<th style="text-align: right">기본값<tbody><tr><td style="text-align: right">name<td style="text-align: right">식별자 생성기 이름<td style="text-align: right">필수<tr><td style="text-align: right">sequenceName<td style="text-align: right">데이터베이스에 등록한 시퀀스 이름<td style="text-align: right">hibernate_sequence<tr><td style="text-align: right">initialValue<td style="text-align: right">DDL생성 시에만 사용되는데, 시퀀스 DDL 생성 시 <br />처음 시작하는 수를 지정한다.<td style="text-align: right">1<tr><td style="text-align: right">allocationSize<td style="text-align: right">시퀀스 한 번 호출에 증가하는 수 (성능최적화) <br /> 데이터베이스 시퀀스 값이 하나씩 증가하도록 설정되어있으면 <br />이 값을 반드시 1로 설정해야 한다.<td style="text-align: right">50<tr><td style="text-align: right">catalog, schema<td style="text-align: right">데이터베이스 catalog, schema 이름<td style="text-align: right"> </table></div><p><strong>TABLE 전략</strong></p><ul><li>키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략<li>모든 데이터베이스에 적용 가능하다는 장점을 가지지만 성능 이슈가 있다.</ul><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="nd">@TableGenerator</span><span class="o">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s">"DIGIMON_SEQ_GENERATOR"</span><span class="o">,</span>
        <span class="n">table</span><span class="o">=</span><span class="s">"MY_SEQUENCE"</span><span class="o">,</span>
        <span class="n">pkColumnValue</span> <span class="o">=</span> <span class="s">"DIGIMON_SEQ"</span><span class="o">,</span> <span class="n">allocationSize</span> <span class="o">=</span> <span class="mi">1</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Digimon</span><span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">TABLE</span><span class="o">,</span>
            <span class="n">generator</span> <span class="o">=</span> <span class="s">"DIGIMON_SEQ_GENERATOR"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>생성된 키 생성 전용 테이블은 아래와 같다.</p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/12.png" width="300" /></p><p><strong>@TableGenerator - 속성</strong></p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">속성<th style="text-align: right">설명<th style="text-align: right">기본값<tbody><tr><td style="text-align: right">name<td style="text-align: right">식별자 생성기 이름<td style="text-align: right">필수<tr><td style="text-align: right">table<td style="text-align: right">키 생성 테이블명<td style="text-align: right">hibernate_sequence<tr><td style="text-align: right">pkColumnName<td style="text-align: right">시퀀스 컬럼명<td style="text-align: right">sequence_name<tr><td style="text-align: right">valueColumnName<td style="text-align: right">시퀀스 값 컬럼명<td style="text-align: right">next_val<tr><td style="text-align: right">pkColumnValue<td style="text-align: right">키로 사용할 이름<td style="text-align: right">엔티티 이름<tr><td style="text-align: right">initialValue<td style="text-align: right">초기값, 마지막으로 생성된 값이 기준이다.<td style="text-align: right">0<tr><td style="text-align: right">allocationSize<td style="text-align: right">시퀀스 한 번 호출에 증가하는 수 (성능최적화)<td style="text-align: right">50<tr><td style="text-align: right">catalog, schema<td style="text-align: right">데이터베이스 catalog, schema 이름<td style="text-align: right"> <tr><td style="text-align: right">uniqueConstraints(DDL)<td style="text-align: right">유니크 제약 조건<td style="text-align: right"> </table></div><h3 id="연관관계-매핑-기초"><strong>연관관계 매핑 기초</strong></h3><p><strong>객체를 테이블에 맞춰서 데이터 중심적으로 모델링하면 협력관계를 만들 수 없다.</strong> 데이터베이스의 테이블은 외래키로 <code class="language-plaintext highlighter-rouge">Join</code>을 사용해서 연관된 테이블을 찾고, 자바의 객체는 <code class="language-plaintext highlighter-rouge">참조</code>를 사용해서 연관된 객체를 찾는다는 차이점을 가진다.</p><h4 id="단방향-연관관계">단방향 연관관계</h4><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/2.png" width="500" /></p><p>객체의 참조와 테이블의 외래키를 매핑</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span><span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"username"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"team_id"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="양방향-연관관계와-연관관계의-주인">양방향 연관관계와 연관관계의 주인</h4><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/3.png" width="500" /></p><p><code class="language-plaintext highlighter-rouge">Member</code> 엔티티는 단방향과 동일</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span><span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span><span class="o">=</span><span class="s">"team"</span><span class="o">)</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 두 개라고 볼 수 있다. 그에 반해, 테이블은 FK 하나로 두 테이블의 연관관계를 관리할 수 있기 때문에 <strong>양방향 연결관계에서 두 엔티티 중 하나로 FK를 관리해야 한다.</strong></p><p>여기서 연관관계의 FK를 관리하는 엔티티를 <code class="language-plaintext highlighter-rouge">연관관계의 주인(Owner)</code>이라고 한다. 연관관계의 주인이 아닌 쪽은 읽기만 가능하고 데이터의 등록과 수정은 할 수 없다. 1:N 관계에서 N쪽이 FK를 가지므로 FK가 있는 쪽을 연관관계의 주인으로 설정하면 된다. 반대쪽은 읽기전용값임을 주의하자.</p><p>주인은 <code class="language-plaintext highlighter-rouge">mappedBy</code> 속성을 사용하지 않고, 주인이 아닌 쪽에서 <code class="language-plaintext highlighter-rouge">mappedBy</code> 속성을 통해서 연관관계의 주인을 지정해야 한다.</p><p>순수 객체 상태를 고려해서 양쪽에 값을 설정해야 하는데, 연관관계 편의 메소드를 생성해서 활용하면 된다. 또한, <code class="language-plaintext highlighter-rouge">toString()</code>, <code class="language-plaintext highlighter-rouge">lombok</code>, <code class="language-plaintext highlighter-rouge">JSON 생성 라이브러리</code> 등을 사용할 때 양방향 매핑의 무한 루프를 주의해야 한다.</p><p>설계 시에는 단방향 매핑만으로 연관관계 매핑을 정의하고, 양방향 연결은 이후 개발단계에서 양방향 연결이 필요할 때 생성하는 것을 추천한다. 양방향 매핑은 테이블에 영향을 주지 않기 때문에 필요할 때 추가해도 된다.</p><h3 id="다양한-연관관계-매핑"><strong>다양한 연관관계 매핑</strong></h3><h4 id="연관관계-매핑-시-고려사항-3가지">연관관계 매핑 시 고려사항 3가지</h4><ul><li>다중성<ul><li>다대일 : @ManyToOne<li>일대다 : @OneToMany<li>일대일 : @OneToOne<li>다대다 : @ManyToMany</ul><li>단방향, 양방향<ul><li>테이블 : FK 하나로 양쪽 조인 가능 =&gt; 사실 방향이라는 개념이 없음<li>객체 : 참조용 필드가 있는 쪽으로만 참조 가능</ul><li>연관관계의 주인<ul><li>연관관계의 주인 : FK를 관리하는 참조<li>주인의 반대편 : FK에 영향을 주지않고 단순 조회만 가능</ul></ul><h4 id="manytoone---주요-속성">@ManyToOne - 주요 속성</h4><div class="table-wrapper"><table><thead><tr><th style="text-align: right">속성<th style="text-align: right">설명<th style="text-align: right">기본값<tbody><tr><td style="text-align: right">optional<td style="text-align: right">false로 설정하면 항상 연관된 엔티티가 있어야 함<td style="text-align: right">TRUE<tr><td style="text-align: right">fetch<td style="text-align: right">글로벌 패치 전략을 설정<td style="text-align: right">@ManyToOne=FetchType.EAGER<br />@OneToMany=FetchType.LAZY<tr><td style="text-align: right">cascade<td style="text-align: right">영속성 전이 기능을 사용<td style="text-align: right"> <tr><td style="text-align: right">targetEntity<td style="text-align: right">연관된 엔티티의 타입 정보를 설정<br />(잘 사용되지 않음)<td style="text-align: right"> </table></div><h4 id="onetomany---주요-속성">@OneToMany - 주요 속성</h4><div class="table-wrapper"><table><thead><tr><th style="text-align: right">속성<th style="text-align: right">설명<th style="text-align: right">기본값<tbody><tr><td style="text-align: right">mappedBy<td style="text-align: right">연관관계의 주인필드 설정<td style="text-align: right"> <tr><td style="text-align: right">fetch<td style="text-align: right">글로벌 패치 전략을 설정<td style="text-align: right">@ManyToOne=FetchType.EAGER<br />@OneToMany=FetchType.LAZY<tr><td style="text-align: right">cascade<td style="text-align: right">영속성 전이 기능을 사용<td style="text-align: right"> <tr><td style="text-align: right">targetEntity<td style="text-align: right">연관된 엔티티의 타입 정보를 설정<br />(잘 사용되지 않음)<td style="text-align: right"> </table></div><h4 id="joincolumn---주요-속성">@JoinColumn - 주요 속성</h4><div class="table-wrapper"><table><thead><tr><th style="text-align: right">속성<th style="text-align: right">설명<th style="text-align: right">기본값<tbody><tr><td style="text-align: right">name<td style="text-align: right">매핑할 외래키 이름<td style="text-align: right">필드명+_+참조하는 테이블의 기본 키 컬럼명<tr><td style="text-align: right">referencedColumnName<td style="text-align: right">외래키가 참조하는 대상 테이블의 컬럼명<td style="text-align: right">참조하는 테이블의 기본키 컬럼명<tr><td style="text-align: right">foreignKey(DDL)<td style="text-align: right">외래키 제약 조건을 직접 지정<td style="text-align: right"> <tr><td style="text-align: right">unique<br />nullable insertable<br />updatable<br />columnDefinition<br />table<td style="text-align: right">@Column의 속성과 같음<td style="text-align: right"> </table></div><h4 id="다대일-n1">다대일 [N:1]</h4><p><strong>다대일 단방향</strong></p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/4.png" width="500" /></p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span><span class="o">{</span>
    <span class="o">...</span>
    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"team_id"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>다대일 양방향</strong></p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/5.png" width="500" /></p><p><code class="language-plaintext highlighter-rouge">Member</code> 엔티티는 단방향과 같고 <code class="language-plaintext highlighter-rouge">Team</code> 엔티티에 참조 변수를 추가해준다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span><span class="o">{</span>
    <span class="o">...</span>
    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span><span class="o">=</span><span class="s">"team"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="일대다-1n">일대다 [1:N]</h4><p><strong>일대다 단방향</strong></p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/6.png" width="500" /></p><p><code class="language-plaintext highlighter-rouge">Member</code> 엔티티는 <code class="language-plaintext highlighter-rouge">Team</code> 엔티티 값을 참조하지 않고, <code class="language-plaintext highlighter-rouge">Team</code> 엔티티는 <code class="language-plaintext highlighter-rouge">Member</code> 엔티티를 참조하고 있다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span><span class="o">{</span>
    <span class="o">...</span>
    <span class="nd">@OneToMany</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"team_id"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>일대다 단방향에서는 일(1)이 연관관계의 주인이고, 다(N)쪽에 FK가 있다. 이는 객체와 테이블의 차이때문에 반대편 테이블의 FK를 관리하는 특이한 구조인데, 이 때는 반드시 <code class="language-plaintext highlighter-rouge">@JoinColumn</code>을 사용해야 한다. 그렇지 않으면 조인 테이블 방식을 사용한다.</p><p>일대다 단방향에서는 엔티티가 관리하는 FK가 다른 테이블에 있기때문에 연관관계 관리를 위해 추가로 <code class="language-plaintext highlighter-rouge">UPDATE SQL</code>이 실행되어야 한다. 따라서 <strong>일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하도록 하자.</strong></p><p><strong>일대다 양방향</strong></p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/7.png" width="500" /></p><p>이런 매핑은 JPA에서 공식적으로 지원하지 않는다. 하지만 읽기 전용 필드를 사용해서 양방향처럼 사용하는 방법이 있는데, <code class="language-plaintext highlighter-rouge">@JoinColumn(inserable=false, updatable=false)</code> 을 사용하면 된다. 하지만 웬만하면 다대일 양방향을 사용하도록 하자.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span><span class="o">{</span>
    <span class="o">...</span>
    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"team_id"</span><span class="o">,</span> <span class="n">insertable</span><span class="o">=</span><span class="kc">false</span><span class="o">,</span> <span class="n">updatable</span><span class="o">=</span><span class="kc">false</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="일대일11">일대일[1:1]</h4><p>일대일 관계는 그 반대도 일대일이기 때문에, 주 테이블이나 대상 테이블 중에 FK를 선택할 수 있다. 이 때 FK에 데이터베이스 유니크(UNI) 제약조건을 추가해주어야 한다.</p><p><strong>일대일 : 주 테이블에 FK 단방향</strong></p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/9.png" width="500" /></p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span><span class="o">{</span>
    <span class="o">...</span>
    <span class="nd">@OneToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"locker_id"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Locker</span> <span class="n">locker</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>다대일(@ManyToOne) 단방향 매핑과 유사한 방식</p><p><strong>일대일 : 주 테이블에 FK 양방향</strong></p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/10.png" width="500" /></p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Locker</span><span class="o">{</span>
    <span class="o">...</span>
    <span class="nd">@OneToOne</span><span class="o">(</span><span class="n">mappedBy</span><span class="o">=</span><span class="s">"locker"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Member</span> <span class="n">member</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>다대일 양방향 매핑처럼 FK가 있는 곳이 연관관계의 주인이고 반대편은 <code class="language-plaintext highlighter-rouge">mappedBy</code>를 적용한다.</p><p><strong>일대일 : 대상 테이블에 FK 단방향</strong></p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/13.png" width="500" /></p><p>이런 형태는 JPA에서 지원하지 않음</p><p><strong>일대일 : 대상 테이블에 FK 양방향</strong></p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/14.png" width="500" /></p><p>일대일 주 테이블에 FK 양방향과 매핑방법이 같음</p><p><strong>정리</strong></p><ul><li>주 테이블에 FK<ul><li>주 객체가 대상 객체의 참조를 가지는 것처럼, 주 테이블에 FK를 두고 대상 테이블을 찾기 때문에 JPA 매핑이 편리해서 객체지향 개발자가 선호<li>장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능<li>단점 : 값이 없으면 FK에 null을 허용</ul><li>대상 테이블에 FK<ul><li>대상 테이블에 FK가 존재하는 형태로, 데이터베이스 개발자가 선호<li>장점 : 주 테이블과 대상 테이블의 관계를 일대일에서 일대다로 변경할 때 테이블 구조를 유지함<li>단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨 (null인지 확인해야 해서)</ul></ul><h4 id="다대다-nm">다대다 [N:M]</h4><p>관계형 데이터베이스에서는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없기때문에 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야 하는 반면, 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계를 구현할 수 있다.</p><p><code class="language-plaintext highlighter-rouge">@ManyToMany</code>를 사용하고 <code class="language-plaintext highlighter-rouge">@JoinTable</code>로 연결 테이블을 지정해서 단방향 또는 양방향으로 다대다 매핑을 구현할 수 있지만, 연결테이블의 여러가지 한계에 부딪혀 실무에서는 다대다 매핑을 사용할 수 없다.</p><p>다대다 매핑의 한계를 극복하기 위해서는, 연결 테이블을 엔티티로 지정하여 <code class="language-plaintext highlighter-rouge">@ManyToMany</code>를 <code class="language-plaintext highlighter-rouge">@OneToMany</code>와 <code class="language-plaintext highlighter-rouge">@ManyToOne</code>으로 변경해서 매핑해야 한다.</p><h3 id="고급-매핑"><strong>고급 매핑</strong></h3><h4 id="상속관계-매핑">상속관계 매핑</h4><p>관계형 데이터베이스에는 자바에서의 상속 관계같은 개념이 없다. 하지만 슈퍼타입과 서브타입 관계라는 모델링 기법이 객체의 상속과 유사한데, 이를 <code class="language-plaintext highlighter-rouge">상속관계 매핑</code>이라 한다.</p><p>상속관계 매핑에는 크게 세 가지 방법이 있다.</p><ul><li>각각 테이블로 변환 -&gt; 조인 전략<li>통합 테이블로 변환 -&gt; 단일 테이블 전략<li>서브타입 테이블로 변환 -&gt; 구현 클래스마다 테이블 전략</ul><p>세 방법 중 어떤 것을 사용해도 JPA의 어노테이션을 통해 매핑 가능하다.</p><ul><li><code class="language-plaintext highlighter-rouge">@Inheritance(strategy=InheritanceType.XXX)</code><ul><li>JOINED : 조인 전략<li>SINGLE_TABLE : 단일 테이블 전략<li>TABLE_PER_CLASS : 구현 클래스마다 테이블 전략</ul><li><code class="language-plaintext highlighter-rouge">@DiscriminatorColumn(name="DTYPE")</code><li><code class="language-plaintext highlighter-rouge">@DiscriminatorValue("XXX")</code></ul><p>세 가지 방법에 대해 하나씩 알아보자.</p><h4 id="조인-전략">조인 전략</h4><p>조인 전략은 공통적인 부분을 하나의 테이블로 분리하고 JOIN을 통해 서브 테이블들과 연결을 맺은 형태이다.</p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/15.png" width="700" /></p><ul><li>장점<ul><li>테이블 정규화<li>FK 참조 무결성 제약조건 활용 가능<li>저장공간 효율화 (데이터 중복이 없음)</ul><li>단점<ul><li>조회 시 조인을 많이 사용해 성능 저하<li>조회 쿼리가 복잡<li>데이터 저장 시 INSERT SQL 두 번 호출</ul></ul><h4 id="단일-테이블-전략">단일 테이블 전략</h4><p>단일 테이블 전략은 테이블들의 구조가 복잡하지 않을 때, 하나의 테이블로 합쳐서 관리하는 것을 말한다.</p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/16.png" width="600" /></p><ul><li>장점<ul><li>조인이 없어서 조회 성능이 빠름<li>조회 쿼리가 단순함</ul><li>단점<ul><li>자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 함<li>단일 테이블에 모든 것을 저장하므로 테이블이 너무 커져서 오히려 조회 성능이 떨어질 수 있음</ul></ul><h4 id="구현-클래스마다-테이블-전략">구현 클래스마다 테이블 전략</h4><p>이 전략은 각각의 테이블이 공통 부분을 따로 가지는 형태이다.</p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/17.png" width="600" /></p><ul><li>장점<ul><li>서브 타입을 명확하게 구분해서 처리할 때 효과적<li>not null 제약조건 사용 가능</ul><li>단점<ul><li>여러 자식 테이블을 함께 조회할 때 성능이 느림<li>자식 테이블을 통합해서 쿼리하기 이러움</ul></ul><p>이 전략은 단점이 장점을 가릴 정도로 치명적이기에 실제로는 사용하지 않는 것이 좋다.</p><h4 id="mappedsupperclass">@MappedSupperclass</h4><p>이 어노테이션은 공통 매핑 정보가 필요할 때 사용한다. 상속관계 매핑을 하거나, 엔티티로 취급해 테이블과 매핑하는 것이 아니고, 해당 클래스를 상속받는 자식 클래스에 매핑 정보만 제공한다.</p><p>이 클래스에 선언된 속성으로는 데이터를 조회하거나 검색할 수 없다. 따라서 직접 생성해서 사용할 일이 없으므로 추상 클래스로 선언할 것을 권장한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nd">@MappedSuperclass</span>
<span class="nd">@Getter</span> <span class="nd">@Setter</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">BaseEntity</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">createdBy</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">createdDate</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">lastModifiedBy</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">lastModifiedDate</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>주로 등록일, 수정일같이 전체 엔티티에서 공통으로 적용하는 정보를 위해 사용한다. 참고로 <code class="language-plaintext highlighter-rouge">@Entity</code>클래스는 엔티티거나 <code class="language-plaintext highlighter-rouge">@MappedSuperclass</code>로 지정한 클래스만 상속받을 수 있다.</p><h4 id="discriminatorcolumn과-discriminatorvaluexxx">@DiscriminatorColumn과 @DiscriminatorValue(“XXX”)</h4><p>상속관계 매핑을 할 때 사용할 수 있는 어노테이션이다. 조인 전략이나 단일 테이블 전략을 사용할 시, <code class="language-plaintext highlighter-rouge">@DiscriminatorColumn</code>을 사용하면 테이블에 <code class="language-plaintext highlighter-rouge">DTYPE</code> 속성이 추가되어 데이터가 어떤 <code class="language-plaintext highlighter-rouge">Entity</code>에 속하는지 알 수 있게 된다.</p><blockquote><p>단일 테이블 전략은 @DiscriminatorColumn을 지정하지 않아도 자동으로 dtype이 포함된다.</p></blockquote><p>기본적으로 <code class="language-plaintext highlighter-rouge">DTYPE</code>에는 엔티티의 이름으로 데이터가 추가되는데, <code class="language-plaintext highlighter-rouge">@DiscriminatorValue("XXX")</code>를 사용한다면 엔티티 이름 대신 사용자가 직접 설정할 수 있다.</p><h3 id="프록시와-연관관계-관리"><strong>프록시와 연관관계 관리</strong></h3><h4 id="프록시">프록시</h4><p><code class="language-plaintext highlighter-rouge">em.getReference()</code>는 데이터베이스 조회를 미루는 프록시를 조회한다. 가짜(프록시)엔티티를 가지고 있다가 이 값이 실제 사용되는 시점에 쿼리를 보내는 방식이다.</p><p>프록시는 실제 클래스를 상속받아서 만들어지기 때문에 실제 클래스와 겉모양이 같다. 따라서 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다.</p><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/18.png" width="400" /></p><p>프록시 객체는 실제 객체의 참조(target)를 보관하고 있다가, 프록시 객체가 호출되는 시점에 실제 객체의 메소드를 호출하는데, 이것을 <code class="language-plaintext highlighter-rouge">프록시 객체의 초기화</code>라고 한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"id1"</span><span class="o">);</span>
<span class="n">member</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="assets/img/../../../../assets/img/jpa-basic/19.png" width="500" /></p><p>프록시 객체는 처음 사용할 때 한 번만 초기화되는데, 이 때 프록시 객체를 통해서 실제 엔티티에 접근이 가능해지는 것이지 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">Book</span> <span class="n">reference</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Book</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">reference</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="gp">class domain.Book$</span>HibernateProxy<span class="nv">$si3rb9q3</span>
</pre></table></code></div></div><p>또한 프록시 객체는 내부적으로 원본 엔티티를 상속받아서 만들어지기 때문에 타입 체크 시 주의가 필요하다. 따라서 <code class="language-plaintext highlighter-rouge">==</code>가 아닌 <code class="language-plaintext highlighter-rouge">instanceof</code>를 사용해서 타입을 체크해야 한다.</p><p>만약 찾고자하는 엔티티가 이미 영속성 컨텍스트에 있다면, <code class="language-plaintext highlighter-rouge">em.getReference()</code>를 호출해도 실제 엔티티가 반환된다.</p><p>위 그림을 보면 알 수 있듯이 프록시 객체는 영속성 컨텍스트의 도움을 받는데, 만약 영속성 컨텍스트가 종료되었거나 프록시가 준영속 상태일 때 프록시를 초기화하려하면 예외가 발생한다.</p><blockquote><p>하이버네이트는 org.hibernate.LazyInitializationException 예외를 발생시킨다.</p></blockquote><p>만약 해당 프록시 인스턴스의 초기화 여부를 확인하고 싶다면 <code class="language-plaintext highlighter-rouge">PersistenceUnitUtil.isLoaded(Object entity)</code>를 사용한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">boolean</span> <span class="n">check</span> <span class="o">=</span> <span class="n">emf</span><span class="o">.</span><span class="na">getPersistenceUnitUtil</span><span class="o">().</span><span class="na">isLoaded</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
</pre></table></code></div></div><h4 id="즉시-로딩과-지연-로딩">즉시 로딩과 지연 로딩</h4><p>지연로딩 구현</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span><span class="o">{</span>
    <span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span><span class="o">=</span><span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">)</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"team_id"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Member</code> 객체 조회 시 <code class="language-plaintext highlighter-rouge">Team</code>은 실제 엔티티가 아닌 프록시 값이 들어간다.</p><p>즉시로딩 구현</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span><span class="o">{</span>
    <span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span><span class="o">=</span><span class="nc">FetchType</span><span class="o">.</span><span class="na">EAGER</span><span class="o">)</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"team_id"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Member</code> 조회 시 <code class="language-plaintext highlighter-rouge">Join</code>을 사용해서 항상 <code class="language-plaintext highlighter-rouge">Team</code>도 함께 조회한다.</p><p>즉시로딩은 편리해보이지만, 즉시 로딩을 사용하면 예상치못한 SQL이 발생하거나, JPQL에서 N+1 문제를 일으키기 때문에 실무에서는 <strong>가급적 지연로딩만 사용해야 한다.</strong> 지연 로딩을 사용하더라도 JPQL의 <code class="language-plaintext highlighter-rouge">fetch join</code>이나 엔티티 그래프 기능을 사용해서 필요할 때 엔티티를 조회할 수 있다.</p><p><code class="language-plaintext highlighter-rouge">@ManyToOne</code>이나 <code class="language-plaintext highlighter-rouge">@OneToOne</code>은 기본 설정이 즉시 로딩이기때문에 직접 지연 로딩으로 설정해주어야 한다.</p><blockquote><p>@OneToMany와 @ManyToMany는 기본 설정이 지연로딩이다.</p></blockquote><h4 id="영속성-전이--cascade">영속성 전이 : CASCADE</h4><p>특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때 사용하는 설정이다. 예를 들어, 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장되도록 할 수 있다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span><span class="o">{</span>
    <span class="o">...</span>
    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span><span class="o">=</span><span class="s">"parent"</span><span class="o">,</span> <span class="n">cascade</span><span class="o">=</span><span class="nc">CascadeType</span><span class="o">.</span><span class="na">PERSIST</span><span class="o">)</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Child</span><span class="o">&gt;</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</pre></table></code></div></div><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Child</span><span class="o">{</span>
    <span class="o">...</span>
    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"parent_id"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Parent</span> <span class="n">parent</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nc">Child</span> <span class="n">child1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Child</span><span class="o">();</span>
<span class="nc">Child</span> <span class="n">child2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Child</span><span class="o">();</span>

<span class="nc">Parent</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Parent</span><span class="o">();</span>
<span class="n">parent</span><span class="o">.</span><span class="na">addChild</span><span class="o">(</span><span class="n">child1</span><span class="o">);</span>
<span class="n">parent</span><span class="o">.</span><span class="na">addChild</span><span class="o">(</span><span class="n">child2</span><span class="o">);</span>

<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">parent</span><span class="o">)</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">CascadeType.PERSIST</code>를 설정하면 위 코드에서 <code class="language-plaintext highlighter-rouge">parent</code>만 <code class="language-plaintext highlighter-rouge">persist()</code>해도 <code class="language-plaintext highlighter-rouge">child1</code>과 <code class="language-plaintext highlighter-rouge">child2</code>까지 <code class="language-plaintext highlighter-rouge">Child</code> 테이블에 INSERT 쿼리가 나간다. 만약 <code class="language-plaintext highlighter-rouge">Child</code>가 다른 엔티티와도 연관성이 있다면 CASCADE를 사용하지 않는 것이 좋다. (단일소유자)</p><p>CASCADE의 종류는 다음과 같다.</p><ul><li>ALL : 모두 적용<li>PERSIST : 영속<li>REMOVE : 삭제<li>MERGE : 병합<li>REFERESH : REFERESH<li>DETACH : DETACH</ul><h4 id="고아-객체">고아 객체</h4><p>고아 객체는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 말하는데 <code class="language-plaintext highlighter-rouge">orphanRemoval</code> 설정은 <code class="language-plaintext highlighter-rouge">@OneToOne</code> 이나 <code class="language-plaintext highlighter-rouge">@OneToMany</code> 사용 시, 이러한 고아 엔티티를 자동으로 삭제하도록 한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span><span class="o">{</span>
    <span class="o">...</span>
    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span><span class="o">=</span><span class="s">"parent"</span><span class="o">,</span> <span class="n">orphanRemoval</span><span class="o">=</span><span class="kc">true</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Child</span><span class="o">&gt;</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</pre></table></code></div></div><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">Parent</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Parent</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">id</span><span class="o">);</span>
<span class="n">parent</span><span class="o">.</span><span class="na">getChildren</span><span class="o">().</span><span class="na">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
</pre></table></code></div></div><p>위 코드에서 0번째 자식 엔티티는 컬렉션에서 제거되고 <code class="language-plaintext highlighter-rouge">Child</code> 테이블에 해당 데이터에 대한 <code class="language-plaintext highlighter-rouge">DELETE</code> 쿼리가 나간다.</p><p>이 기능또한 참조하는 곳이 하나일 때만 사용해야 한다. 만약 <code class="language-plaintext highlighter-rouge">Child</code> 엔티티를 여러 엔티티에서 참조하고 있다면 의도하지 않은 다른 테이블의 데이터까지 삭제될 수 있다.</p><h4 id="영속성-전이--고아객체">영속성 전이 + 고아객체</h4><p><code class="language-plaintext highlighter-rouge">CascadeType.ALL + orphanRemoval=true</code>로 두 가지 설정을 모두 활성화하면, 부모 엔티티를 통해서 자식 엔티티의 생명 주기를 관리할 수 있게 된다. 이 것은 <code class="language-plaintext highlighter-rouge">도메인 주도 설계(DDD)</code>의 <code class="language-plaintext highlighter-rouge">Aggregate Root</code> 개념을 구현할 때 유용하다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/backend/'>Backend</a>, <a href='/categories/orm/'>ORM</a>, <a href='/categories/jpa/'>JPA</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >java</a> <a href="/tags/jpa/" class="post-tag no-text-decoration" >jpa</a> <a href="/tags/spring/" class="post-tag no-text-decoration" >spring</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[JPA] JPA 기초 정리 - 1 - yeoji21&url=https://yeoji21.github.io/posts/jpa-basic-1/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[JPA] JPA 기초 정리 - 1 - yeoji21&u=https://yeoji21.github.io/posts/jpa-basic-1/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[JPA] JPA 기초 정리 - 1 - yeoji21&url=https://yeoji21.github.io/posts/jpa-basic-1/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink('', 'Link copied successfully!')" data-toggle="tooltip" data-placement="top" title="Copy link"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/polymorphism-inheritance/">객체지향에서의 상속과 다형성</a><li><a href="/posts/graduation-project-review/">졸업 작품 프로젝트 회고</a><li><a href="/posts/reflection-1/">[JAVA] Java Refelction 마스터 강의 1장</a><li><a href="/posts/mst/">[알고리즘] MST - 크루스칼 vs 프림</a><li><a href="/posts/injection/">[Spring] 의존성 주입 시 생성자 주입을 사용해야 하는 이유 </a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94/">자바</a> <a class="post-tag" href="/tags/java-study/">java study</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%84%B0%EB%94%94/">자바 스터디</a> <a class="post-tag" href="/tags/oop/">oop</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/guides/">guides</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/jpa-basic-2/"><div class="card-body"> <span class="timeago small" >Sep 19, 2021<i class="unloaded">2021-09-19T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[JPA] JPA 기초 정리 - 2</h3><div class="text-muted small"><p> 들어가면서 인프런에 있는 김영한님의 자바 ORM 표준 JPA 프로그래밍 - 기본편 강의를 정리한 글입니다. 세부사항이나 설정 등은 포스팅하지 않으니, 자세한 내용은 강의를 통해 확인해주시길 바랍니다. 목차 값 타입 객체지향 쿼리 언어 (JPQL) 값 타입 JPA의 데이터 타입은 크게 두 가지로 분류할 수 있다. 엔티티 타입 ...</p></div></div></a></div><div class="card"> <a href="/posts/spring-data-jpa1/"><div class="card-body"> <span class="timeago small" >Oct 3, 2021<i class="unloaded">2021-10-03T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[JPA] Spring Data JPA</h3><div class="text-muted small"><p> 들어가면서 인프런에 있는 김영한님의 실전! 스프링 데이터 JPA 강의를 정리한 글입니다. 세부사항이나 설정 등은 포스팅하지 않으니, 자세한 내용은 강의를 통해 확인해주시길 바랍니다. 목차 공통 인터페이스 기능 쿼리 메소드 기능 페이징과 정렬 벌크성 수정 쿼리 @EntityGraph 확장 기능 새로운 엔티티를 구별하는 방법 ...</p></div></div></a></div><div class="card"> <a href="/posts/jpa-one-to-one/"><div class="card-body"> <span class="timeago small" >Jul 17<i class="unloaded">2022-07-17T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[JPA] @OneToOne 연관관계 매핑 시 주의사항</h3><div class="text-muted small"><p> 이번 포스트에서는 JPA의 @OneToOne 매핑을 사용하면서 마주한 문제에 대해 얘기해보겠습니다. 결론부터 말씀드리자면 JPA에서 OneToOne 관계로 엔티티를 연결할 경우, Lazy Loading이 보장되지 않을 수 있습니다. 어떤 경우에 이런 문제가 발생하고, 어떻게 해결하면 좋을까요? 문제 상황을 간단히 하면 다음과 같습니다. 하나의...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/stream/" class="btn btn-outline-primary" prompt="Older"><p>[JAVA] 스트림 (Stream)</p></a> <a href="/posts/jpa-basic-2/" class="btn btn-outline-primary" prompt="Newer"><p>[JPA] JPA 기초 정리 - 2</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">yeoji21</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94/">자바</a> <a class="post-tag" href="/tags/java-study/">java study</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%84%B0%EB%94%94/">자바 스터디</a> <a class="post-tag" href="/tags/oop/">oop</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/guides/">guides</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://yeoji21.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
