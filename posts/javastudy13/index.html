<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="자바 스터디 13 - I/O" /><meta name="author" content="yeoji21" /><meta property="og:locale" content="en" /><meta name="description" content="어서와" /><meta property="og:description" content="어서와" /><link rel="canonical" href="https://yeoji21.github.io/posts/javastudy13/" /><meta property="og:url" content="https://yeoji21.github.io/posts/javastudy13/" /><meta property="og:site_name" content="yeoji21" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-08-28T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="자바 스터디 13 - I/O" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@yeoji21" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"yeoji21"},"dateModified":"2021-11-18T12:45:38+09:00","datePublished":"2021-08-28T00:00:00+09:00","description":"어서와","headline":"자바 스터디 13 - I/O","mainEntityOfPage":{"@type":"WebPage","@id":"https://yeoji21.github.io/posts/javastudy13/"},"url":"https://yeoji21.github.io/posts/javastudy13/"}</script><title>자바 스터디 13 - I/O | yeoji21</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="yeoji21"><meta name="application-name" content="yeoji21"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR:wght@500&display=swap" rel="stylesheet"><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile/img1.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">yeoji21</a></div><div class="site-subtitle font-italic">Don't look back in anger</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/yeoji21" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['yeozone0508','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>자바 스터디 13 - I/O</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>자바 스터디 13 - I/O</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> yeoji21 </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Aug 28, 2021, 12:00 AM +0900" >Aug 28, 2021<i class="unloaded">2021-08-28T00:00:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Nov 18, 2021, 12:45 PM +0900" >Nov 18, 2021<i class="unloaded">2021-11-18T12:45:38+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="12831 words">71 min read</span></div></div><div class="post-content"><p><img data-proofer-ignore data-src="https://media.vlpt.us/images/inhalin/post/b48b4cd3-619b-4bf4-939c-d3546dd2ec01/whiteship.png" /></p><h2 id="들어가면서">들어가면서</h2><p>백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다.<br /> 강의 영상 링크 : <a href="https://youtu.be/LmWvwbjynhg">[자바 라이브 스터디] 2021/2/20, 13주차 I/O </a><br /> 강의 깃허브 링크 : <a href="https://github.com/whiteship/live-study/issues/13">13주차 과제: I/O</a></p><h2 id="목차">목차</h2><ul><li>스트림 (Stream) / 버퍼 (Buffer) / 채널 (Channel) 기반의 I/O<li>InputStream과 OutputStream<li>Byte와 Character 스트림<li>표준 스트림 (System.in, System.out, System.err)<li>파일 읽고 쓰기</ul><h3 id="io-입출력"><strong>I/O 입출력</strong></h3><p>입출력(I/O)란 Input과 Output의 약자로, 컴퓨터 내부 또는 외부의 장치와 프로그램간에 데이터를 주고 받는 것을 말한다.</p><p>이러한 Java의 입출력 API는 <code class="language-plaintext highlighter-rouge">IO</code>와 <code class="language-plaintext highlighter-rouge">NIO</code>로 나뉘어 있는데, NIO는 기존 IO의 속도가 느리다는 단점을 개선하기 위해 Java 4부터 새로운 입출력이라는 의미로 추가되어 <code class="language-plaintext highlighter-rouge">java.nio</code> 패키지에 포함된다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">구분<th style="text-align: right">IO<th style="text-align: right">NIO<tbody><tr><td style="text-align: right">입출력 방식<td style="text-align: right">스트림(Stream)방식<td style="text-align: right">채널(Channel)방식<tr><td style="text-align: right">버퍼 방식<td style="text-align: right">논 버퍼<td style="text-align: right">버퍼<tr><td style="text-align: right">비동기 방식<td style="text-align: right">지원안함<td style="text-align: right">지원함<tr><td style="text-align: right">블로킹/논블로킹<td style="text-align: right">블로킹만 지원<td style="text-align: right">블로킹/논블로킹 지원</table></div><ul><li><p>스트림 vs 채널<br /> 스트림은 입력 스트림과 출력 스트림으로 구분되어 있기 때문에 데이터를 읽기 위해서는 입력 스트림을, 데이터를 쓰기 위해서는 출력 스트림을 따로 생성해야 한다. <br /> 반면에 채널 기반은 스트림과 달리 양방향으로 입력과 출력이 가능하다.</p><li><p>다이렉트 버퍼 vs 논 다이렉트 버퍼</p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">구분<th style="text-align: right">Direct Buffer<th style="text-align: right">Non Direct Buffer<tbody><tr><td style="text-align: right">사용공간<td style="text-align: right">OS의 메모리<td style="text-align: right">JVM 힙 메모리<tr><td style="text-align: right">버퍼의 생성속도<td style="text-align: right">느리다<td style="text-align: right">빠르다<tr><td style="text-align: right">버퍼의 크기<td style="text-align: right">크다<td style="text-align: right">작다<tr><td style="text-align: right">I/O 성능<td style="text-align: right">높다<td style="text-align: right">낮다<tr><td style="text-align: right">Use<td style="text-align: right">한 번 생성한 뒤 재사용을 할 경우<td style="text-align: right">빈번하게 계속해서 사용해야 할 경우</table></div><p>IO에서는 출력 스트림이 <code class="language-plaintext highlighter-rouge">1byte</code>를 쓰면 입력 스트림이 <code class="language-plaintext highlighter-rouge">1byte</code>를 읽는다. 이런 방식은 매 번 <code class="language-plaintext highlighter-rouge">System call</code>을 호출하기때문에 매우 느리다. 따라서 <code class="language-plaintext highlighter-rouge">버퍼(buffer)</code>를 사용해서 복수의 <code class="language-plaintext highlighter-rouge">byte</code>를 한꺼번에 출력하는 것이 성능상 유리하다.</p><p>그래서 IO는 버퍼를 제공하는 보조스트림을 지원하긴 하지만 NIO는 기본적으로 버퍼를 사용해서 입출력하기 때문에 IO보다 높은 성능을 가진다.</p><li><p>블로킹 vs 논블로킹<br /> IO는 블로킹되는 특징이 있기 때문에 입출력 스트림의 <code class="language-plaintext highlighter-rouge">read()</code>나 <code class="language-plaintext highlighter-rouge">write()</code>를 호출하면 데이터가 입력되기 전까지 쓰레드가 블로킹 상태에 빠진다. IO 쓰레드가 블로킹되면 다른 일을 할 수 없고 빠져나올 수 있는 유일한 방법은 스트림을 닫는 것이다.</p><p>NIO는 블로킹과 논블로킹을 모두 지원하는데, 블로킹 되었을 때는 인터럽트를 할 수 있어 빠져나오는 것이 가능하고, 논블로킹은 작업 쓰레드가 입출력 준비가 완료(바로 읽고 쓸 수 있는 상태)된 채널만 선택해서 처리하기 때문에 블로킹이 발생하지 않는다.</p></ul><p>IO와 NIO의 차이에 대해 간단히 알아보았는데, 데이터를 입출력한다는 목적은 동일하지만 방식의 차이가 있으므로 상황에 따라서 적절한 API를 사용하는 것이 중요하다. NIO가 항상 효율적인 것은 아니다.</p><ul><li>IO를 사용해야 할 때<br /> 클라이언트 수가 적고 대용량 데이터를 처리해야하는 경우<br /> 순차적으로 진행해야 하는 경우 등<br /> 버퍼를 사용하지 않고 데이터를 받은 즉시 처리하므로 덜 복잡함<li>NIO를 사용해야 할 때<br /> 클라이언트 수가 많고 하나의 입출력 작업이 오래 걸리지 않는 경우<br /> 다수의 클라이언트를 비동기 또는 논블로킹으로 처리하기 때문에 과도한 쓰레드 생성을 예방하고 효과적으로 재사용이 가능하다.</ul><h3 id="스트림-stream--버퍼-buffer--채널-channel-기반의-io"><strong>스트림 (Stream) / 버퍼 (Buffer) / 채널 (Channel) 기반의 I/O</strong></h3><h4 id="스트림stream">스트림(stream)</h4><p>자바에서 입출력을 수행하려면, 즉 어느 한쪽에서 다른 쪽으로 데이터를 전달하려면 두 대상을 연결하고 데이터를 전송할 수 있는 무언가가 필요한데, 이 것을 <strong>스트림</strong>이라고 정의한다.</p><blockquote><p>Collections의 stream()과 이름이 같지만 다른 개념이다.</p></blockquote><p>스트림은 연속적인 데이터의 흐름을 물에 비유해서 붙여진 이름인데, 여러 가지로 유사한 점이 많다. 물이 한쪽 방향으로만 흐르는 것처럼 스트림은 단방향통신만 가능하기때문에 하나의 스트림으로 입력과 출력을 동시에 처리할 수 없다.</p><p>그래서 입력과 출력을 동시에 수행하려면 입력을 위한 입력 스트림과 출력을 위한 출력 스트림 두 가지가 필요하다.</p><p>스트림은 먼저 보낸 데이터를 먼저 받게 되어 있으며 중간에 건너뜀없이 연속적으로 데이터를 주고받는다. <code class="language-plaintext highlighter-rouge">queue</code>와 같은 <code class="language-plaintext highlighter-rouge">FIFO</code>구조라고 생각하면 된다.</p><p>스트림은 바이트기반 스트림과 문자기반 스트림으로 나뉜다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">바이트기반 스트림<th style="text-align: right">문자기반 스트림<tbody><tr><td style="text-align: right">그림, 멀티미디어, 문자 등 모든 종류의 <br /> 데이터 송수신 가능<td style="text-align: right">문자 데이터만 송수신 가능<tr><td style="text-align: right">byte 단위로 읽고 쓰는 스트림<td style="text-align: right">문자(char) 단위로 읽고 쓰는 스트림<tr><td style="text-align: right">네이밍은 XXXInputStream / XXXOutputStream<td style="text-align: right">네이밍은 XXXReader / XXXWriter</table></div><h4 id="보조-스트림">보조 스트림</h4><p>보조 스트림은 실제 데이터를 주고 받는 스트림이 아니기 때문에 데이터를 입출력할 수 있는 기능은 없지만 스트림의 기능을 향상시키거나 새로운 기능을 추가할 수 있다. 그래서 보조 스트림만으로는 입출력을 처리할 수 없고, 스트림을 먼저 생성한 다음에 이를 이용해서 보조스트림을 생성해야 한다.</p><p>예를 들어 test.txt라는 파일을 읽기 위해 <code class="language-plaintext highlighter-rouge">FileInputStream</code>을 사용할 때, 입력 성능을 향상 시키기 위해 버퍼를 사용하는 보조스트림인 <code class="language-plaintext highlighter-rouge">BufferedInputStream</code>을 사용하는 코드는 아래와 같다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"test.txt"</span><span class="o">);</span>
<span class="nc">BufferedInputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">);</span>
<span class="n">bis</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
</pre></table></code></div></div><p>코드 상으로 보면 <code class="language-plaintext highlighter-rouge">BufferedInputStream</code>이 입력 기능을 수행하는 것처럼 보이지만, 실제 입력기능은 연결된 <code class="language-plaintext highlighter-rouge">FileInputStream</code>이 수행하고, 보조 스트림 <code class="language-plaintext highlighter-rouge">BufferedInputStream</code>은 버퍼만 제공한다.</p><blockquote><p>버퍼를 사용한 입출력과 사용하지 않은 입출력 간의 성능차이는 상당하기 때문에 대부분의 경우에 버퍼를 이용한 보조스트림을 사용한다.</p></blockquote><h4 id="버퍼buffer">버퍼(buffer)</h4><p>버퍼란 데이터를 전송하는 상호 간의 장치에서 고속의 장치와 저속의 장치 간의 속도 차이로 인해 저속의 장치가 작업을 처리하는 동안, 고속의 장치가 기다려야하는 현상을 줄여주는 기술이며 데이터를 임시 저장하는 공간을 의미한다.</p><p>위에서 언급한 것처럼 입출력 시에 버퍼를 사용함으로써 <code class="language-plaintext highlighter-rouge">System call</code>횟수를 줄이고 입출력 속도를 개선할 수 있다.</p><h4 id="채널channel">채널(channel)</h4><p>데이터가 이동하는 양방향 통로를 말한다. 채널은 비동기적으로 닫히고 중단될 수 있기 때문에 한 스레드가 한 채널의 입출력 작업으로 블로킹되면, 다른 스레드가 블로킹된 스레드를 중단시킬 수 있다.(<code class="language-plaintext highlighter-rouge">interrupt</code>) 그래서 파일입출력에서 블로킹된 스레드를 언제나 중지시킬 수 있으며, 이를 통해서 네트워크에서 <code class="language-plaintext highlighter-rouge">non-blocking</code> 입출력이 가능해짐</p><p>읽기와 쓰기를 동시에 할 수 있는 것이 특징이며 채널은 기본적으로 입출력 시에 <code class="language-plaintext highlighter-rouge">ByteBuffer</code>를 사용하기 때문에 데이터 형에 맞는 전용 메모리 공간을 가지고 있다.</p><h3 id="inputstream과-outputstream"><strong>InputStream과 OutputStream</strong></h3><p>스트림은 <strong>byte 단위로 데이터를 전송</strong>하며 입출력 대상에 따라 다음과 같은 입출력 스트림이 있다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">입력 스트림<th style="text-align: right">출력스트림<th style="text-align: right">대상의 종류<tbody><tr><td style="text-align: right">FileInputStream<td style="text-align: right">FileOutputStream<td style="text-align: right">파일<tr><td style="text-align: right">ByteArrayInputStream<td style="text-align: right">ByteArrayOutputStream<td style="text-align: right">메모리(byte배열)<tr><td style="text-align: right">PipedInputStream<td style="text-align: right">PipedOutputStream<td style="text-align: right">프로세스(프로세스간 통신)<tr><td style="text-align: right">AudioInputStream<td style="text-align: right">AudioOutputStream<td style="text-align: right">오디오 장치</table></div><p>이 중에서 어떠한 대상에 대해서 작업을 할 것인지, 입력을 할 것인지 출력을 할 것인지에 따라 해당 스트림을 선택해서 사용하면 된다. 이들은 모두 <code class="language-plaintext highlighter-rouge">InputStream</code>과 <code class="language-plaintext highlighter-rouge">OutputStream</code>의 자손으로, 각각 읽고 쓰는데 필요한 추상 메소드를 자신에 맞게 구현해놓았다.</p><p>자바에서는 <code class="language-plaintext highlighter-rouge">java.io</code> 패키지를 통해서 많은 종류의 입출력관련 클래스들을 제공하고 있으며, 입출력을 처리할 수 있는 <strong>표준화된 방법</strong>을 제공함으로써 입출력의 대상이 달라져도 동일한 방법으로 입출력이 가능하기 때문에 프로그래밍을 하기에 편리하다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">InputStream<th style="text-align: right">OutputStream<tbody><tr><td style="text-align: right">abstract int read()<td style="text-align: right">abstract void write(int b)<tr><td style="text-align: right">int read(byte[] b)<td style="text-align: right">void write(byte[] b)<tr><td style="text-align: right">int read(byte[] b, int off, int len)<td style="text-align: right">void write(byte b[], int off, int len)</table></div><p>대표적으로 이 표에있는 메소드의 사용법만 알고 있어도 데이터를 읽고 쓰는 것은 입출력 대상의 종류에 관계없이 아주 간단해진다.</p><p><code class="language-plaintext highlighter-rouge">InputStream</code>의 <code class="language-plaintext highlighter-rouge">read()</code>와 <code class="language-plaintext highlighter-rouge">OutputStream</code>의 <code class="language-plaintext highlighter-rouge">write(int b)</code>는 입출력의 대상에 따라 읽고 쓰는 방법이 다르기때문에 각 상황에 맞게 구현하라는 의미에서 추상 메소드로 정의되어 있다.</p><p>나머지 메소드들은 추상 메소드가 아니기 때문에 바로 사용하면 된다고 생각할 수 있지만, <strong>내부적으로 read()와 write(int b)를 이용해서 구현</strong>하고 있으므로 read()와 write(int b)가 구현되어 있지 않으면 이들은 아무런 의미가 없다.</p><p>이 메소드들 이외에도 <code class="language-plaintext highlighter-rouge">InputStream</code>과 <code class="language-plaintext highlighter-rouge">OutputStream</code>에 선언된 메소드들을 더 자세히 살펴보자</p><h4 id="inputstream의-메소드">InputStream의 메소드</h4><div class="table-wrapper"><table><thead><tr><th style="text-align: right">메소드명<th style="text-align: right">설명<tbody><tr><td style="text-align: right">int available()<td style="text-align: right">스트림으로부터 읽어올 수 있는 데이터의 크기를 반환<tr><td style="text-align: right">void close()<td style="text-align: right">스트림을 닫음으로써 자원을 반환<tr><td style="text-align: right">void mark(int readlimit)<td style="text-align: right">현재위치를 표시해놓는다. 후에 reset()에 의해 표시해놓은 위치로<br /> 돌아갈 수 있고 readlimit은 되돌아갈 수 있는 byte의 수<tr><td style="text-align: right">boolean markSupported()<td style="text-align: right">mark()와 reset()을 지원하는지 알려줌<tr><td style="text-align: right">abstract int read()<td style="text-align: right">1byte를 읽어온다. 읽어올 데이터가 없으면 -1을 반환한다.<tr><td style="text-align: right">int read(byte[] b)<td style="text-align: right">배열 b의 크기만큼 읽어서 배열을 채우고 읽어 온 데이터의 수를 반환<tr><td style="text-align: right">int read(byte[] b,<br />int off, int len)<td style="text-align: right">최대 len개의 byte를 읽어서 지정된 위치(off)부터 저장한다.<tr><td style="text-align: right">void reset()<td style="text-align: right">스트림의 위치를 마지막으로 mark()가 호출된 위치로 되돌린다.<tr><td style="text-align: right">long skip(long n)<td style="text-align: right">스트림에서 주어진 길이(n)만큼을 건너뛴다.</table></div><h4 id="outputstream의-메소드">OutputStream의 메소드</h4><div class="table-wrapper"><table><thead><tr><th style="text-align: right">메소드명<th style="text-align: right">설명<tbody><tr><td style="text-align: right">void close()<td style="text-align: right">입력소스를 닫음으로써 자원을 반환<tr><td style="text-align: right">void flush()<td style="text-align: right">스트림의 버퍼에 있는 모든 내용을 출력소스에 write<tr><td style="text-align: right">abstract void write(int b)<td style="text-align: right">주어진 값을 출력소스에 write<tr><td style="text-align: right">void write(byte[] b)<td style="text-align: right">배열 b에 저장된 모든 내용을 출력소스에 write<tr><td style="text-align: right">void write(byte[] b,<br />int off,int len)<td style="text-align: right">배열 b에 저장된 내용 중에서 <br />off번째부터 len개만큼 읽어서 출력소스에 write</table></div><p>프로그램이 종료될 때, 사용하고 닫지 않은 스트림을 <code class="language-plaintext highlighter-rouge">JVM</code>이 자동적으로 닫아 주기는 하지만, 스트림을 사용해서 모든 작업을 마치고 난 후에는 <code class="language-plaintext highlighter-rouge">close()</code>를 호출해서 반드시 닫아주어야 한다.</p><blockquote><p>ByteArrayInputStream과 같이 메모리를 사용하는 스트림과 System.in, Sytem.out과 같은 표준 입출력 스트림은 닫아주지 않아도 된다.</p></blockquote><h4 id="bytearrayinputstream과-bytearrayoutputstream">ByteArrayInputStream과 ByteArrayOutputStream</h4><p><code class="language-plaintext highlighter-rouge">ByteArrayInputStream</code>과 <code class="language-plaintext highlighter-rouge">ByteArrayOutputStream</code>은 메모리, 즉 <strong>바이트배열에 데이터를 입출력하는데 사용되는 스트림</strong>이다. 주로 다른 곳에 입출력하기 전에 데이터를 임시로 바이트배열에 담아서 변환 등의 작업을 하는데 사용된다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">byte</span><span class="o">[]</span> <span class="n">inSource</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">outSource</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

<span class="nc">ByteArrayInputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="n">inSource</span><span class="o">);</span>
<span class="nc">ByteArrayOutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayOutputStream</span><span class="o">();</span>

<span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">while</span><span class="o">((</span><span class="n">data</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
    <span class="n">output</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">outSource</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input Source = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">inSource</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output Source = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">outSource</span><span class="o">));</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="go">Input Source = [0, 1, 2, 3, 4, 5]
Output Source = [0, 1, 2, 3, 4, 5]
</span></pre></table></code></div></div><p>바이트배열은 사용하는자원이 메모리 밖에 없으므로 가비지 컬렉터에 의해 자동적으로 자원을 반환하기 때문에 <code class="language-plaintext highlighter-rouge">close()</code>를 이용해서 스트림을 닫지 않아도 된다.</p><p>여기서는 <code class="language-plaintext highlighter-rouge">read()</code>와 <code class="language-plaintext highlighter-rouge">write(int b)</code>를 사용하기 때문에 한 번에 <code class="language-plaintext highlighter-rouge">1byte</code>만 읽고 쓰므로 작업 효율은 떨어진다. 이를 해결하기 위해 아래 예제는 배열을 사용해서 입출력이 보다 효율적으로 이루어지도록 했다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">byte</span><span class="o">[]</span> <span class="n">inSource</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">};</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">outSource</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">4</span><span class="o">];</span>

<span class="nc">ByteArrayInputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="n">inSource</span><span class="o">);</span>
<span class="nc">ByteArrayOutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayOutputStream</span><span class="o">();</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input Source = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">inSource</span><span class="o">));</span>

<span class="k">try</span><span class="o">{</span>
    <span class="k">while</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">available</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
        <span class="n">input</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>
        <span class="n">output</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>
        <span class="n">outSource</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"        temp = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">temp</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Output Source = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">outSource</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">){}</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="go">Input Source = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        temp = [0, 1, 2, 3]
Output Source = [0, 1, 2, 3]
        temp = [4, 5, 6, 7]
Output Source = [0, 1, 2, 3, 4, 5, 6, 7]
        temp = [8, 9, 6, 7]
Output Source = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 6, 7]
</span></pre></table></code></div></div><p>간단히 추가된 것을 설명하면, <code class="language-plaintext highlighter-rouge">read()</code>나 <code class="language-plaintext highlighter-rouge">write()</code>에서 <code class="language-plaintext highlighter-rouge">IOException</code>을 발생시킬 수 있기 때문에 <code class="language-plaintext highlighter-rouge">try-catch</code>문으로 감싸주었다. <code class="language-plaintext highlighter-rouge">available()</code>은 blocking없이 읽어올 수 있는 바이트의 수를 반환하는 메소드이다.</p><blockquote><p>blocking이란, 데이터를 읽어 올 때 데이터를 기다리기 위해 멈춰있는 것을 말한다. 예를 들어 사용자가 데이터를 입력하기 전까지 기다리고 있을 때 블로킹 상태에 있다고 한다.</p></blockquote><p>이렇게 배열을 이용해서 코드를 잘 짰다고 생각했지만 예상한 것과 다른 결과가 나왔다. <code class="language-plaintext highlighter-rouge">Input Source</code>와 동일하게 0~9까지 숫자가 <code class="language-plaintext highlighter-rouge">Output Source</code>에 복사되었을 것이라고 생각했는데 그 뒤에 <strong>6,7이 중복해서 나타난다.</strong></p><p>그 이유는 마지막에 읽은 배열의 9번째와 10번째 요소값인 8과 9만 출력해야하는데 <code class="language-plaintext highlighter-rouge">temp</code>에 남아있던 6,7까지 출력했기 때문이다.</p><p>보다 나은 성능을 위해서 <strong><code class="language-plaintext highlighter-rouge">temp</code>에 담긴 내용을 지우고 쓰는 것이 아니라 기존의 내용 위에 덮어쓴다.</strong> 그래서 temp의 [4,5,6,7] 위에 8,9를 읽으니 [8,9,6,7]이 된 것이다.</p><p>원하는 코드를 얻기 위해서는 아래의 코드와 같이 수정해야 한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">while</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">available</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>
    <span class="n">output</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">temp</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">len</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="go">Input Source = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        temp = [0, 1, 2, 3]
Output Source = [0, 1, 2, 3]
        temp = [4, 5, 6, 7]
Output Source = [0, 1, 2, 3, 4, 5, 6, 7]
        temp = [8, 9, 6, 7]
Output Source = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</span></pre></table></code></div></div><p>코드를 수정하여 배열의 내용 전체가 아닌, <strong>읽은 만큼만 출력하도록</strong> 하니 우리가 원하는 결과를 얻은 것을 확인할 수 있다.</p><h4 id="fileinputstream과-fileoutputstream">FileInputStream과 FileOutputStream</h4><p><code class="language-plaintext highlighter-rouge">FileInputStream</code>과 <code class="language-plaintext highlighter-rouge">FileOutputStream</code>은 <strong>파일에 입출력을 하기 위한 스트림</strong>이다. 실제로 가장 많이 사용되는 스트림 중에 하나이다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">생성자<th style="text-align: right">설명<tbody><tr><td style="text-align: right">FileInputStream(String name)<td style="text-align: right">지정된 파일이름을 가진 파일과 연결된 FileInputStream 생성<tr><td style="text-align: right">FileInputStream(File file)<td style="text-align: right">File 인스턴스로 파일과 연결된 FileInputStream 생성<tr><td style="text-align: right">FileInputStream(FileDescriptor fdObj)<td style="text-align: right">파일 디스크립터로 FileInputStream 생성<tr><td style="text-align: right">FileOutputStream(String name)<td style="text-align: right">지정된 파일이름을 가진 파일과 연결된 FileOutputStream 생성<tr><td style="text-align: right">FileOutputStream(String name, <br />boolean append)<td style="text-align: right">지정된 파일이름을 가진 파일과 연결된 FileOutputStream 생성하는데 <br /> append가 true이면 출력 시 기존의 파일 내용의 마지막에 덧붙이고<br /> false면 기존의 파일 내용을 덮어쓴다.<tr><td style="text-align: right">FileOutputStream(File file)<td style="text-align: right">File 인스턴스로 파일과 연결된 FileOutputStream 생성<tr><td style="text-align: right">FileOutputStream(File file,<br /> boolean append)<td style="text-align: right">파일명대신 File 인스턴스로 전달하는 점을 제외하고 <br />FileOutputStream(String name, boolean append)과 같다.<tr><td style="text-align: right">FileOutputStream(FileDescriptor fdObj)<td style="text-align: right">파일디스크립터로 FileOutputStream을 생성한다.</table></div><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IOTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
        <span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">((</span><span class="n">data</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span><span class="n">data</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="go">yeoji@yeoji-ui-MacBookAir week13 % java IOTest.java IOTest.java
</span><span class="gp">package com.example.javastudy.week13;</span><span class="w">
</span><span class="go">
</span><span class="gp">import java.io.*;</span><span class="w">
</span><span class="gp">import java.util.Arrays;</span><span class="w">
</span><span class="go">
public class IOTest {
    public static void main(String[] args) throws IOException {
</span><span class="gp">        FileInputStream fis = new FileInputStream(args[0]);</span><span class="w">
</span><span class="gp">        int data = 0;</span><span class="w">
</span><span class="go">
        while ((data = fis.read()) != -1) {
</span><span class="gp">            char c = (char)data;</span><span class="w">
</span><span class="gp">            System.out.print(c);</span><span class="w">
</span><span class="go">        }
    }
}
</span></pre></table></code></div></div><p>커맨드라인으로부터 입력받은 파일의 내용을 읽어서 그대로 화면에 출력하는 간단한 예제이다. <code class="language-plaintext highlighter-rouge">read()</code>의 반환값이 <code class="language-plaintext highlighter-rouge">int형(4byte)</code>이지만, -1을 제외하고는 <code class="language-plaintext highlighter-rouge">0~255(1byte)</code>의 정수값이기때문에 <code class="language-plaintext highlighter-rouge">char형(2byte)</code>으로 변환한다 해도 손실되는 값은 없다.</p><p><code class="language-plaintext highlighter-rouge">read()</code>가 한 번에 <code class="language-plaintext highlighter-rouge">1byte</code>씩 데이터를 읽긴 하지만, 데이터의 범위가 0~255사이의 정수값이고, -1값도 필요하기 때문에 다소 크긴 하지만 정수형 중에서는 연산이 가장 효율적이고 빠른 int형 값을 반환하도록 한 것이다.</p><p>하지만 이렇게 텍스트파일을 다루는 경우에는 <code class="language-plaintext highlighter-rouge">FileInputStream</code>/<code class="language-plaintext highlighter-rouge">FileOutputStream</code>보다 문자기반의 스트림인 <code class="language-plaintext highlighter-rouge">FileReader</code>/<code class="language-plaintext highlighter-rouge">FileWriter</code>를 사용하는 것이 좋다.</p><h4 id="바이트기반의-보조스트림">바이트기반의 보조스트림</h4><div class="table-wrapper"><table><thead><tr><th style="text-align: right">입력<th style="text-align: right">출력<th style="text-align: right">설명<tbody><tr><td style="text-align: right">FilterInputStream<td style="text-align: right">FilterOutputStream<td style="text-align: right">필터를 이용한 입출력 처리<tr><td style="text-align: right">BufferedInputStream<td style="text-align: right">BufferedOutputStream<td style="text-align: right">버퍼를 이용한 입출력 성능향상<tr><td style="text-align: right">DataInputStream<td style="text-align: right">DataOutputStream<td style="text-align: right">int, float와 같은 기본형 단위(primitive type)로<br /> 데이터를 처리하는 기능<tr><td style="text-align: right">SequenceInputStream<td style="text-align: right">없음<td style="text-align: right">두 개의 스트림을 하나로 연결<tr><td style="text-align: right">LineNumberInputStream<td style="text-align: right">없음<td style="text-align: right">읽어 온 데이터의 라인 번호를 카운트<br />JDK1.1부터 LineNumberReader로 대체<tr><td style="text-align: right">ObjectInputStream<td style="text-align: right">ObjectOutputStream<td style="text-align: right">데이터를 객체단위로 읽고 쓰는데 사용<br />주로 파일을 이용한 객체 직렬화와 관련됨<tr><td style="text-align: right">없음<td style="text-align: right">PrintStream<td style="text-align: right">버퍼를 이용해 추가적인 print관련 기능<br />(print,printf,println메소드)<tr><td style="text-align: right">PushbackInputStream<td style="text-align: right">없음<td style="text-align: right">버퍼를 이용해서 읽어 온 데이터를 다시 되돌리는 기능 <br /> (unread,push back to buffer)</table></div><h4 id="filterinputstream과-filteroutputstream">FilterInputStream과 FilterOutputStream</h4><p><strong><code class="language-plaintext highlighter-rouge">FilterInputStream</code>과 <code class="language-plaintext highlighter-rouge">FilterOutputStream</code>은 InputStream/OutputStream의 자손이면서 모든 보조스트림의 조상이다.</strong></p><p>보조스트림은 자체적으로 입출력을 할 수 없기때문에 기반스트림을 필요로한다. 다음은 <code class="language-plaintext highlighter-rouge">FilterInputStream</code>과 <code class="language-plaintext highlighter-rouge">FilterOutputStream</code>의 생성자이다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kd">protected</span> <span class="nf">FilterInputStream</span><span class="o">(</span><span class="nc">InputStream</span> <span class="n">in</span><span class="o">)</span>
<span class="kd">public</span> <span class="nf">FilterOutputStream</span><span class="o">(</span><span class="nc">OutputStream</span> <span class="n">out</span><span class="o">)</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">FilterInputStream</code>과 <code class="language-plaintext highlighter-rouge">FilterOutputStream</code>의 모든 메소드는 단순히 기반스트림의 메소드를 그대로 호출할 뿐, 이 자체로는 아무런 일도 하지 않는다.</p><p>또한 <code class="language-plaintext highlighter-rouge">FilterInputStream</code>의 생성자는 <code class="language-plaintext highlighter-rouge">protected</code>이므로 바로 인스턴스를 생성해서 사용할 수 없고 상속을 통해서 오버라이딩되어야 한다. <code class="language-plaintext highlighter-rouge">FilterInputStream</code>과 <code class="language-plaintext highlighter-rouge">FilterOutputStream</code>을 상속받아서 기반스트림에 보조 기능을 추가한 보조스트림 클래스는 다음과 같다.</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>FilterInputStream의 자손 - BufferedInputStream, DataInputStream, PushbackInputStream 등
FilterOutputStream의 자손 - BufferedOutputStream, DataOutputStream, PrintStream 등
</pre></table></code></div></div><h4 id="bufferedinputstream과-bufferedoutputstream">BufferedInputStream과 BufferedOutputStream</h4><p><code class="language-plaintext highlighter-rouge">BufferedInputStream</code>과 <code class="language-plaintext highlighter-rouge">BufferedOutputStream</code>은 스트림의 <strong>입출력 효율을 높이기 위해 버퍼를 사용하는 보조스트림</strong>이다. 한 바이트씩 입출력하는 것보다 <code class="language-plaintext highlighter-rouge">버퍼(byte 배열)</code>를 이용해서 한 번에 여러 바이트를 입출력하는 것이 빠르기때문에 대부분의 입출력작업에 사용된다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">생성자<th style="text-align: right">설명<tbody><tr><td style="text-align: right">BufferedInputStream(InputStream in, int size)<td style="text-align: right">주어진 InputStream인스턴스를 입력소스로 하며,<br /> 지정된 크기(byte 단위)의 버퍼를 갖는 인스턴스를 생성한다.<tr><td style="text-align: right">BufferedInputStream(InputStream in)<td style="text-align: right">주어진 InputStream인스턴스를 입력소스로 하며,<br /> 기본적으로 8192byte 크기의 버퍼를 갖는다.</table></div><p>프로그램에서 입력소스로부터 데이터를 읽기 위해 처음으로 <code class="language-plaintext highlighter-rouge">read()</code>를 호출하면, <code class="language-plaintext highlighter-rouge">BufferedInputStream</code>은 입력소스로부터 버퍼의 크기만큼 데이터를 읽어서 자신의 내부 버퍼에 저장한다. 그 후 프로그램에서는 <code class="language-plaintext highlighter-rouge">BufferedInputStream</code>의 버퍼에 저장된 데이터를 읽는다.</p><p>외부의 입력소스로부터 읽는 것보다 내부의 버퍼로부터 읽는 것이 훨씬 빠르기때문에 그만큼 작업의 효율이 높아진다. 프로그램에서 버퍼에 저장된 모든 데이터를 다 읽고 그 다음 데이터를 읽기위해 <code class="language-plaintext highlighter-rouge">read()</code>가 호출되면 <code class="language-plaintext highlighter-rouge">BufferedInputStream</code>은 입력소스로부터 다시 버퍼크기만큼의 데이터를 읽어다 버퍼에 저장해 놓는다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">메소드/생성자<th style="text-align: right">설명<tbody><tr><td style="text-align: right">BufferedOutputStream(OutputStream out,int size)<td style="text-align: right">주어진 OutputStream인스턴스를 출력소스로하고 <br />지정된 크기(byte 단위)의 버퍼를 갖는 인스턴스를 생성한다.<tr><td style="text-align: right">BufferedOutputStream(OutputStream out)<td style="text-align: right">주어진 OutputStream인스턴스를 출력소스로 하며, <br />기본적으로 8192byte 크기의 버퍼를 갖는다.<tr><td style="text-align: right">flush()<td style="text-align: right">버퍼의 모든 내용을 출력소스에 출력한 다음 버퍼를 비운다.<tr><td style="text-align: right">close()<td style="text-align: right">flush()를 호출해서 버퍼를 비운 뒤 <br />BufferedOutputStream가 사용하던 모든 자원을 반환한다.</table></div><p><code class="language-plaintext highlighter-rouge">BufferedOutputStream</code> 역시 버퍼를 이용해서 출력소스와 작업을 하는데, 입력 소스로부터 데이터를 읽을 떄와는 반대로 프로그램에서 <code class="language-plaintext highlighter-rouge">write()</code>를 이용한 출력이 <code class="language-plaintext highlighter-rouge">BufferedOutputStream</code>의 버퍼에 저장된다.</p><p>버퍼가 가득 차면, 그 때 버퍼의 모든 내용을 출력소스에 출력한 뒤, 버퍼를 비우고 다시 프로그램으로부터 출력을 저장할 준비를 한다.</p><p>버퍼가 가득 찼을 때만 출력소스에 출력하기때문에 마지막 출력부분이 출력소스에 쓰이지 못하고 <code class="language-plaintext highlighter-rouge">BufferedOutputStream</code>의 버퍼에 남아있는 채로 프로그램이 종료될 수 있다는 점을 주의해야한다.</p><p>따라서 모든 출력 작업을 마치면 <code class="language-plaintext highlighter-rouge">BufferedOutputStream</code>에 <code class="language-plaintext highlighter-rouge">flush()</code>나 <code class="language-plaintext highlighter-rouge">close()</code>를 호출해서 마지막에 버퍼에 남은 내용이 출력소스에 출력되도록 해야한다.</p><blockquote><p>BufferedOutputStream의 close()는 내부적으로 flush()를 호출한 뒤 BufferedOutputStream의 인스턴스의 참조변수에 null을 지정함으로써 사용하던 자원들이 반환되게 한다.</p></blockquote><p>그리고 보조스트림의 <code class="language-plaintext highlighter-rouge">close()</code>는 내부적으로 기반스트림의 <code class="language-plaintext highlighter-rouge">close()</code>를 호출하기때문에 두 번 호출할 필요 없이 보조스트림의 <code class="language-plaintext highlighter-rouge">close()</code>만 호출하면 된다.</p><h4 id="datainputstream과-dataoutputstream">DataInputStream과 DataOutputStream</h4><p><code class="language-plaintext highlighter-rouge">DataInputStream</code>과 <code class="language-plaintext highlighter-rouge">DataOutputStream</code>도 각각 FilterInputStream/FilterOutputStream의 자손이며 <code class="language-plaintext highlighter-rouge">DataInputStream</code>은 DataInput 인터페이스를, <code class="language-plaintext highlighter-rouge">DataOutputStream</code>은 DataOutput 인터페이스를 구현하기때문에 데이터를 읽고 쓰는데 있어서 <strong>byte 단위가 아닌 8가지 기본 자료형의 단위로 읽고 쓸 수 있다</strong>는 장점이 있다.</p><h4 id="sequenceinputstream">SequenceInputStream</h4><p><code class="language-plaintext highlighter-rouge">SequenceInputStream</code>은 <strong>여러 개의 입력스트림을 연속적으로 연결</strong>해서 하나의 스트림으로부터 데이터를 읽는 것과 같이 처리할 수 있도록 도와준다. <code class="language-plaintext highlighter-rouge">SequenceInputStream</code>의 생성자를 제외하고 나머지 작업은 다른 입력스트림과 다르지않다. 큰 파일을 여러 개의 작은 파일로 나눴다가 하나의 파일로 합치는 것과 같은 작업을 수행할 때 사용하면 좋을 것이다.</p><blockquote><p>SequenceInputStream은 다른 보조스트림들과 달리 FilterInputStream이 아닌 InputStream을 바로 상속받아서 구현하였다.</p></blockquote><div class="table-wrapper"><table><thead><tr><th style="text-align: right">생성자<th style="text-align: right">설명<tbody><tr><td style="text-align: right">SequenceInputStream(Enumeration e)<td style="text-align: right">e에 저장된 순서대로 입력 스트림을 하나의 스트림으로 연결한다.<tr><td style="text-align: right">SequenceInputStream(InputStream s1,<br />InputStream s2)<td style="text-align: right">두 개의 입력 스트림을 하나로 연결한다.</table></div><h4 id="printstream">PrintStream</h4><p><code class="language-plaintext highlighter-rouge">PrintStream</code>은 데이터를 기반스트림에 다양한 형태로 출력할 수 있는 <code class="language-plaintext highlighter-rouge">print</code>, <code class="language-plaintext highlighter-rouge">println</code>, <code class="language-plaintext highlighter-rouge">printf</code>와 같은 메소드를 오버로딩하여 제공한다.</p><p><code class="language-plaintext highlighter-rouge">PrintStream</code>은 데이터를 적절한 문자로 출력하는 것이기 때문에 <strong>문자기반 스트림의 역할을 수행</strong>한다. 그래서 <code class="language-plaintext highlighter-rouge">JDK 1.1</code>부터 PrintStream보다 향상된 기능의 문자기반 스트림인 <code class="language-plaintext highlighter-rouge">PrintWriter</code>가 추가되었으나 그 동안 빈번히 사용되던 <code class="language-plaintext highlighter-rouge">System.out</code>이 <code class="language-plaintext highlighter-rouge">PrintStream</code>이다보니 둘 다 사용할 수 밖에 없게 되었다.</p><p>따라서 <code class="language-plaintext highlighter-rouge">PrintStream</code>과 <code class="language-plaintext highlighter-rouge">PrintWriter</code>는 거의 같은 기능을 가지고 있지만 <code class="language-plaintext highlighter-rouge">PrintWriter</code>가 <code class="language-plaintext highlighter-rouge">PrintStream</code>에 비해 다양한 언어의 문자를 처리하는데 적합하기 때문에 가능하면 <code class="language-plaintext highlighter-rouge">PrintWriter</code>를 사용하는 것이 좋다.</p><blockquote><p>System.out, System.err이 PrintStream을 사용한다.</p></blockquote><p><code class="language-plaintext highlighter-rouge">print()</code>나 <code class="language-plaintext highlighter-rouge">println()</code>을 이용해서 출력하는 중에 <code class="language-plaintext highlighter-rouge">PrintStream</code>의 기반스트림에서 <code class="language-plaintext highlighter-rouge">IOException</code>이 발생하면 <code class="language-plaintext highlighter-rouge">checkError()</code>를 통해서 인지할 수 있다. println()이나 print()는 예외를 던지지 않고 내부에서 처리하도록 정의하였는데, 그 이유는 println()처럼 매우 자주 사용되는 메소드에 예외를 던지도록 정의하면 println()을 사용하는 모든 곳에 <code class="language-plaintext highlighter-rouge">try-catch</code>문을 사용해야 하기 때문이다.</p><p><code class="language-plaintext highlighter-rouge">printf()</code>는 <code class="language-plaintext highlighter-rouge">JDK1.5</code>부터 추가된 것으로, C언어와 같이 편리하고 형식화된 출력을 지원하게 되었다.</p><h3 id="byte와-character-스트림"><strong>Byte와 Character 스트림</strong></h3><h4 id="문자기반-스트림---reader-writer">문자기반 스트림 - Reader, Writer</h4><p>지금까지 알아본 스트림은 모두 바이트기반의 스트림이었다. 바이트 기반은 입출력의 단위가 <code class="language-plaintext highlighter-rouge">1byte</code>라는 의미이다. Java에서 <code class="language-plaintext highlighter-rouge">char형</code>의 크기는 <code class="language-plaintext highlighter-rouge">2byte</code>이기때문에 바이트기반의 스트림으로 문자를 처리하는 데는 어려움이 있다.</p><p>이 점을 보완하기 위해 문자기반의 스트림이 제공되는데 문자데이터를 입출력할 때는 바이트 기반 스트림 대신 문자기반 스트림을 사용하는 것을 권장한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">InputStream</span> <span class="o">-&gt;</span> <span class="nc">Reader</span>
<span class="nc">OutputStream</span> <span class="o">-&gt;</span> <span class="nc">Writer</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th style="text-align: right">바이트기반 스트림<th style="text-align: right">문자기반 스트림<tbody><tr><td style="text-align: right">FileInputStream<br />FileOutputStream<td style="text-align: right">FileReader<br />FileWriter<tr><td style="text-align: right">ByteArrayInputStream<br />ByteArrayOutputStream<td style="text-align: right">CharArrayReader<br />CharArrayWriter<tr><td style="text-align: right">PipedInputStream<br />PipedOutputStream<td style="text-align: right">PipedReader<br />PipedWriter<tr><td style="text-align: right">StringBufferInputStream<br />StringBufferOutputStream<td style="text-align: right">StringReader<br />StringWriter</table></div><p>문자기반 스트림의 이름은 바이트 기반 스트림의 이름에서 <code class="language-plaintext highlighter-rouge">InputStream</code>은 <code class="language-plaintext highlighter-rouge">Reader</code>로,<code class="language-plaintext highlighter-rouge"> OutputStream</code>은 <code class="language-plaintext highlighter-rouge">Writer</code>로 바꾸기만 하면 된다. 단, <code class="language-plaintext highlighter-rouge">ByteArrayInputStream</code>에 대응하는 문자기반 스트림은 char배열을 사용하는 <code class="language-plaintext highlighter-rouge">CharArrayReader</code>이다.</p><p>문자데이터를 다루는데 사용된다는 것을 제외하고는 바이트기반 스트림과 문자기반 스트림의 사용방법은 거의 같기 때문에 앞서 설명한 바이트기반 스트림에 대한 내용만으로도 쉽게 이해가 가능할 것이다.</p><h4 id="reader와-writer의-메소드">Reader와 Writer의 메소드</h4><p>문자기반 스트림의 조상은 <code class="language-plaintext highlighter-rouge">Reader</code>와 <code class="language-plaintext highlighter-rouge">Writer</code>이다. byte배열 대신 <code class="language-plaintext highlighter-rouge">char배열</code>을 사용한다는 것 외에는 <code class="language-plaintext highlighter-rouge">InputStream</code>/<code class="language-plaintext highlighter-rouge">OutputStream</code>의 메소드와 다르지않다.</p><p><strong>Reader의 메소드</strong></p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">메소드명<th style="text-align: right">설명<tbody><tr><td style="text-align: right">abstract void close()<td style="text-align: right">입력스트림을 닫음으로써 자원을 반환<tr><td style="text-align: right">void mark(int readlimit)<td style="text-align: right">현재위치를 표시해놓는다.<br /> 후에 reset()에 의해 표시해놓은 위치로<br /> 돌아갈 수 있고 readlimit은 되돌아갈 수 있는 byte의 수<tr><td style="text-align: right">boolean markSupported()<td style="text-align: right">mark()와 reset()을 지원하는지 알려줌<tr><td style="text-align: right">int read()<td style="text-align: right">입력소스로부터 하나의 문자를 읽어온다. char의 범위인 0~65536의 정수를 반환하며, <br />입력스트림의 마지막에 도달하면 -1을 반환한다.<tr><td style="text-align: right">int read(char[] c)<td style="text-align: right">배열 c의 크기만큼 읽어서 배열을 채우고 읽어 온 데이터의 수를 반환<tr><td style="text-align: right">int read(char[] c,<br />int off, int len)<td style="text-align: right">입력소스로부터 최대 len개의 문자를 읽어서 <br />배열 c의 지정된 위치(off)부터 읽은만큼 저장한다.<tr><td style="text-align: right">int read(CharBuffer target)<td style="text-align: right">입력소스로부터 읽어서 문자버퍼에 저장<tr><td style="text-align: right">boolean ready()<td style="text-align: right">입력소스로부터 데이터를 읽을 준비가 되어있는지 알려줌<tr><td style="text-align: right">void reset()<td style="text-align: right">입력소스에서 위치를 마지막으로 mark()가 호출된 위치로 되돌림<tr><td style="text-align: right">long skip(long n)<td style="text-align: right">현재 위치에서 주어진 길이(n)만큼을 건너뜀</table></div><p><br /></p><p><strong>Writer의 메소드</strong></p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">메소드명<th style="text-align: right">설명<tbody><tr><td style="text-align: right">Writer append(char c)<td style="text-align: right">지정된 문자를 출력소스에 출력<tr><td style="text-align: right">Writer append(CharSequence c)<td style="text-align: right">지정된 문자열을 출력소스에 출력<tr><td style="text-align: right">Writer append(CharSequence c, <br />int start, int end)<td style="text-align: right">지정된 문자열의 일부를 출력소스에 출력<br />(CharBuffer, String, StringBuffer가 구현)<tr><td style="text-align: right">void close()<td style="text-align: right">출력스트림을 닫음으로써 자원을 반환<tr><td style="text-align: right">void flush()<td style="text-align: right">스트림의 버퍼에 있는 모든 내용을 출력소스에 write<tr><td style="text-align: right">void write(int b)<td style="text-align: right">주어진 값을 출력소스에 write<tr><td style="text-align: right">void write(char[] c)<td style="text-align: right">배열 b에 저장된 모든 내용을 출력소스에 write<tr><td style="text-align: right">void write(char[] c,<br />int off,int len)<td style="text-align: right">배열 c에 저장된 내용 중에서 <br />off번째부터 len개만큼 읽어서 출력소스에 write<tr><td style="text-align: right">void write(String str)<td style="text-align: right">주어진 문자열을 출력소스에 write<tr><td style="text-align: right">void write(STring str, int off, int len)<td style="text-align: right">주어진 문자열의 off부터 len개만큼의 문자열을 write</table></div><p>문자기반 스트림이라는 것이 단순히 <code class="language-plaintext highlighter-rouge">2byte</code>로 스트림을 처리하는 것만을 의미하지는 않는다.</p><p>문자 데이터를 다루는데 필요한 또 하나의 정보는 <code class="language-plaintext highlighter-rouge">인코딩(encoding)</code>이다. 문자기반 스트림은 여러 종류의 인코딩과 자바에서 사용하는 <strong>유니코드(UTF-16)간의 변환을 자동적으로 처리해준다.</strong> <code class="language-plaintext highlighter-rouge">Reader</code>는 특정 인코딩을 읽어서 유니코드로 변환하고<code class="language-plaintext highlighter-rouge"> Writer</code>는 유니코드를 특정 인코딩으로 변환하여 저장한다.</p><h4 id="filereader와-filewriter">FileReader와 FileWriter</h4><p><code class="language-plaintext highlighter-rouge">FileReader</code>와 <code class="language-plaintext highlighter-rouge">FileWriter</code>는 파일로부터 텍스트 데이터를 읽고 파일에 쓰는데 사용된다. 사용하는 방법은 <code class="language-plaintext highlighter-rouge">FileInputStream</code>/<code class="language-plaintext highlighter-rouge">FileOutputStream</code>과 다르지않다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nc">FileReader</span> <span class="n">fr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"text.txt"</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">while</span> <span class="o">((</span><span class="n">data</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">data</span><span class="o">);</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
<span class="n">fr</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</pre></table></code></div></div><h4 id="pipedreader와-pipedwriter">PipedReader와 PipedWriter</h4><p><code class="language-plaintext highlighter-rouge">PipedReader</code>와 <code class="language-plaintext highlighter-rouge">PipedWriter</code>는 쓰레드 간에 데이터를 주고받을 때 사용된다. 다른 스트림과는 달리 입력과 출력스트림을 하나의 스트림으로 연결해서 데이터를 주고받는다는 특징이 있다.</p><p>스트림을 생성한 다음에 어느 한쪽 쓰레드에서 <code class="language-plaintext highlighter-rouge">connect()</code>를 호출해서 입력스트림과 출력스트림을 연결한다. 입출력을 마친 후에는 어느 한쪽 스트림만 닫아도 나머지 스트림은 자동으로 닫힌다. 이 점을 제외하고는 일반 입출력 방법과 다르지 않다.</p><h4 id="stringreader와-stringwriter">StringReader와 StringWriter</h4><p><code class="language-plaintext highlighter-rouge">StringReader</code>와 <code class="language-plaintext highlighter-rouge">StringWriter</code>는 CharArrayReader와 CharArrayWriter처럼 입출력의 대상이 메모리인 스트림이다. StringWriter에 출력되는 데이터는 내부의 <code class="language-plaintext highlighter-rouge">StringBuffer</code>에 저장된다.</p><h4 id="문자기반의-보조스트림"><strong>문자기반의 보조스트림</strong></h4><h4 id="bufferedreader와-bufferedwriter">BufferedReader와 BufferedWriter</h4><p><code class="language-plaintext highlighter-rouge">BufferedReader</code>와 <code class="language-plaintext highlighter-rouge">BufferedWriter</code>는 버퍼를 이용해 입출력 효율을 높인다. <code class="language-plaintext highlighter-rouge">BufferedReader</code>의 <code class="language-plaintext highlighter-rouge">readLine()</code>을 사용하면 데이터를 라인단위로 읽을 수 있고, <code class="language-plaintext highlighter-rouge">BufferedWriter</code>는 <code class="language-plaintext highlighter-rouge">newLine()</code>이라는 줄바꿈 메소드를 가지고 있다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nc">FileReader</span> <span class="n">fr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"IOTest.java"</span><span class="o">);</span>
<span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="n">fr</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">line</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="o">(</span><span class="n">line</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="s">";"</span><span class="o">)!=-</span><span class="mi">1</span><span class="o">)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="n">line</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">BufferedReader</code>의 <code class="language-plaintext highlighter-rouge">readLine()</code>을 이용해서 파일을 라인단위로 읽은 다음 <code class="language-plaintext highlighter-rouge">indexOf()</code>를 이용해서 <code class="language-plaintext highlighter-rouge">';'</code>를 포함하고 있는지 확인하여 출력하는 예제이다. 이렇게 파일에서 <strong>특정 문자 또는 문자열을 포함한 라인을 쉽게 찾을 수 있다</strong>는 것을 보여준다.</p><h4 id="inputstreamreader와-outputstreamwriter">InputStreamReader와 OutputStreamWriter</h4><p><code class="language-plaintext highlighter-rouge">InputStreamReader</code>와 <code class="language-plaintext highlighter-rouge">OutputStreamWriter</code>는 <strong>바이트기반 스트림을 문자기반 스트림으로 연결시켜주는 역할</strong>을 한다. 그리고 바이트기반 스트림의 데이터를 지정된 인코딩의 문자데이터로 변환하는 작업을 수행한다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">생성자<th style="text-align: right">설명<tbody><tr><td style="text-align: right">InputStreamReader(InputStream in)<td style="text-align: right">OS에서 사용하는 기본 인코딩의 문자로 변환하는<br /> InputStreamReader를 생성한다.<tr><td style="text-align: right">InputStreamReader(InputStream in, String encoding)<td style="text-align: right">지정된 인코딩을 사용하는<br /> InputStreamReader를 생성한다.<tr><td style="text-align: right">String getEncoding()<td style="text-align: right">InputStreamReader의 인코딩을 반환한다.</table></div><div class="table-wrapper"><table><thead><tr><th style="text-align: right">생성자<th style="text-align: right">설명<tbody><tr><td style="text-align: right">OutputStreamWriter(OutputStream out)<td style="text-align: right">OS에서 사용하는 기본 인코딩의 문자로 변환하는<br /> OutputStreamWriter를 생성한다.<tr><td style="text-align: right">OutputStreamWriter(OutputStream out, String encoding)<td style="text-align: right">지정된 인코딩을 사용하는<br /> OutputStreamWriter를 생성한다.<tr><td style="text-align: right">String getEncoding()<td style="text-align: right">OutputStreamWriter의 인코딩을 알려준다.</table></div><p>만약 인코딩을 지정해주지 않는다면 OS에서 사용하는 디폴트 인코딩을 사용해서 파일을 보여주기 때문에 원래 작성된 데로 볼 수 없는 경우가 있다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nc">InputStreamReader</span> <span class="n">isr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
<span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="n">isr</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">line</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"사용중인 OS의 인코딩 : "</span> <span class="o">+</span> <span class="n">isr</span><span class="o">.</span><span class="na">getEncoding</span><span class="o">());</span>
<span class="k">do</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"문장을 입력하세요. (마치려면 q)"</span><span class="o">);</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"입력한 문장 : "</span> <span class="o">+</span> <span class="n">line</span><span class="o">);</span>
<span class="o">}</span> <span class="k">while</span> <span class="o">(!</span><span class="n">line</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="s">"q"</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"시스템을 종료합니다."</span><span class="o">);</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">BufferedReader</code>의 <code class="language-plaintext highlighter-rouge">readLine()</code>을 이용해서 사용자의 입력을 라인단위로 받으면 편리하다. 그래서 <code class="language-plaintext highlighter-rouge">BufferedReader</code>와 <code class="language-plaintext highlighter-rouge">InputStream</code>인 <code class="language-plaintext highlighter-rouge">System.in</code>을 연결하기 위해 <code class="language-plaintext highlighter-rouge">InputStreamReder</code>를 사용하였다. JDK 1.5부터는 <code class="language-plaintext highlighter-rouge">Scanner</code>가 추가되어 이렇게 사용하지 않아도 간단하게 사용 가능하다.</p><h3 id="표준-스트림-systemin-systemout-systemerr"><strong>표준 스트림 (System.in, System.out, System.err)</strong></h3><p>표준입출력은 콘솔을 통한 데이터의 입력과 콘솔로의 데이터 출력을 의미한다.</p><p>자바에서는 표준 입출력(standard I/O)을 위해 세 가지 입출력 스트림을 제공하는데, 이들은 자바 애플리케이션의 실행과 동시에 사용할 수 있게 자동적으로 생성되기 때문에 개발자가 별도로 스트림을 생성하는 코드를 작성하지 않고도 사용이 가능하다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">System</span><span class="o">.</span><span class="na">in</span> <span class="c1">//콘솔로부터 데이터를 입력받는데 사용</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span> <span class="c1">//콘솔로 데이터를 출력하는데 사용</span>
<span class="nc">System</span><span class="o">.</span><span class="na">err</span> <span class="c1">//콘솔로 데이터를 출력하는데 사용</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">System.out</code>과 <code class="language-plaintext highlighter-rouge">System.err</code>은 둘 다 출력 스트림이다. 차이점으로는 <code class="language-plaintext highlighter-rouge">System.err</code>은 버퍼링을 지원하지 않는다는 점인데, 만약 버퍼링 중에 프로그램이 멈추면 버퍼링된 내용은 출력되지 않기때문에 <code class="language-plaintext highlighter-rouge">System.err</code>을 보다 정확하고 빠르게 출력되게 하기 위해서 이렇게 설계되었다.</p><p>여기서 in, out, err은 <code class="language-plaintext highlighter-rouge">System</code> 클래스에 선언된 클래스변수(static변수)이다. 아래는 실제 <code class="language-plaintext highlighter-rouge">System</code> 클래스의 일부분이다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">InputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">...</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">PrintStream</span> <span class="n">out</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">...</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">PrintStream</span> <span class="n">err</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</pre></table></code></div></div><p>선언부분만 보면 in, out, err은 <code class="language-plaintext highlighter-rouge">InputStream</code>, <code class="language-plaintext highlighter-rouge">PrintStream</code>이지만 실제로는 버퍼를 사용하는 <code class="language-plaintext highlighter-rouge">BufferedInputStream</code>과 <code class="language-plaintext highlighter-rouge">BufferedOutputStream</code>의 인스턴스를 사용한다. 그래서 콘솔 입력은 버퍼를 가지고있기 때문에 입력 중에 <code class="language-plaintext highlighter-rouge">backspace</code>를 통해서 내용을 지우거나 수정할 수 있는 것이다.</p><p>따라서 <code class="language-plaintext highlighter-rouge">Enter</code>키나 입력의 끝을 알리는 <code class="language-plaintext highlighter-rouge">^z</code>를 누르기 전까지는 아직 데이터가 입력중인 것으로 간주되어 커서가 입력을 계속 기다리는 상태(blocking)에 머무르게 된다. 콘솔에 데이터를 입력하고 <code class="language-plaintext highlighter-rouge">Enter</code>키를 누르면 입력대기상태에서 벗어나 입력된 데이터를 읽기 시작한다.</p><p>이 것으로 알 수 있듯이 <code class="language-plaintext highlighter-rouge">Enter</code>키를 누르는 것은 두 개의 특수문자 <code class="language-plaintext highlighter-rouge">\r</code>과 <code class="language-plaintext highlighter-rouge">\n</code>이 입력된 것으로 간주된다. <code class="language-plaintext highlighter-rouge">\r</code>은 캐리지리턴(carriage return), 즉 커서를 현재 라인의 첫 번째 column으로 이동시키고, <code class="language-plaintext highlighter-rouge">\n</code>은 커서를 다음 줄로 이동시키는 줄바꿈(new line)을 한다.</p><p>그래서 <code class="language-plaintext highlighter-rouge">Enter</code>키를 누르면, 캐리지리턴과 줄바꿈이 수행되어 다음 줄의 첫 번째 column으로 커서가 이동하는 것이다. 여기서 한 가지 문제는 <code class="language-plaintext highlighter-rouge">Enter</code>키도 사용자 입력으로 간주되어 매 입력마다 <code class="language-plaintext highlighter-rouge">\r</code>과 <code class="language-plaintext highlighter-rouge">\n</code>이 붙기 때문에 이 것을 제거해주어야 하는 불편함이 있다는 것인데,</p><p>이러한 불편함을 제거하려면 이전에 살펴본 것과 같이 <code class="language-plaintext highlighter-rouge">System.in</code>에 <code class="language-plaintext highlighter-rouge">BufferedReader</code>를 이용해서 <code class="language-plaintext highlighter-rouge">readLine()</code>을 통해 라인단위로 데이터를 입력받으면 된다. Java에서는 콘솔을 통한 입력에 대한 지원이 미약했지만 이후에 <code class="language-plaintext highlighter-rouge">Scanner</code>와 <code class="language-plaintext highlighter-rouge">Console</code>같은 클래스가 추가되면서 많이 보완되었다.</p><h4 id="표준입출력의-대상-변경---setout-seterr-setin">표준입출력의 대상 변경 - setOut(), setErr(), setIn()</h4><p>초기에는 표준입출력의 대상이 콘솔 화면이지만 <code class="language-plaintext highlighter-rouge">setOut()</code>, <code class="language-plaintext highlighter-rouge">setErr()</code>, <code class="language-plaintext highlighter-rouge">setIn()</code>를 사용하면 입출력을 콘솔 이외의 다른 대상으로 변경할 수 있다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"test.txt"</span><span class="o">);</span>
<span class="nc">PrintStream</span> <span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="n">fos</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">setOut</span><span class="o">(</span><span class="n">ps</span><span class="o">);</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello by System.out"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello by System.err"</span><span class="o">);</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="go">Hello by System.err
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">System.out</code>의 출력소스를 <code class="language-plaintext highlighter-rouge">test.txt</code> 파일로 변경하였기 때문에 <code class="language-plaintext highlighter-rouge">System.out</code>을 이용한 출력은 모두 <code class="language-plaintext highlighter-rouge">test.txt</code>파일에 저장된다. 이 방법 외에도 커맨드라인에서 표준입출력의 대상을 간단히 바꿀 수 있는 방법이 있다.</p><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="go">yeojiwon@yeojiwon-ui-MacBookAir week13 % java IOTest
out : Hello World!
err : Hello World!
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">IOTest</code>의 <code class="language-plaintext highlighter-rouge">System.out</code> 출력을 콘솔이 아닌 <code class="language-plaintext highlighter-rouge">output.txt</code>로 지정하려면 아래와 같이 한다. 만약 기존에 <code class="language-plaintext highlighter-rouge">output.txt</code> 파일이 있었다면 기존의 내용은 삭제된다.</p><pre><code class="language-consoleㄴ">yeojiwon@yeojiwon-ui-MacBookAir week13 % java IOTest &gt; output.txt
err : Hello World!
yeojiwon@yeojiwon-ui-MacBookAir week13 % type output.txt
out : Hello World!
</code></pre><p>만약 기존의 내용을 지우지 않고 기존 내용의 마지막에 새로운 내용을 추가하고 싶다면 <code class="language-plaintext highlighter-rouge">&gt;&gt;</code>를 사용한다.</p><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="gp">yeojiwon@yeojiwon-ui-MacBookAir week13 % java IOTest &gt;</span><span class="o">&gt;</span> output.txt
<span class="go">err : Hello World!
yeojiwon@yeojiwon-ui-MacBookAir week13 % type output.txt
out : Hello World!
out : Hello World!
</span></pre></table></code></div></div><h4 id="-직렬화-serialization"><strong>+) 직렬화 (Serialization)</strong></h4><h4 id="직렬화란">직렬화란?</h4><p><strong>직렬화란 객체를 데이터 스트림으로 만드는 것</strong>을 뜻한다. 다시 얘기하면 객체에 저장된 데이터를 스트림에 쓰기(write)위해 <code class="language-plaintext highlighter-rouge">연속적인(serial)</code> 데이터로 변환하는 것을 말한다. 반대로 스트림으로부터 데이터를 읽어서 객체를 만드는 것은 <code class="language-plaintext highlighter-rouge">역직렬화(deserialization)</code>라고 한다.</p><p>직렬화라는 용어때문에 어렵게 느껴질 수 있으나 사실 객체를 저장하거나 전송하려면 이렇게 할 수 밖에 없다. 여기서 객체란 무엇이며, 객체를 저장한다는 것은 무엇을 의미하는가에 대해서 다시 한 번 정리해보자.</p><p><strong>객체</strong>는 클래스에 정의된 <code class="language-plaintext highlighter-rouge">인스턴스 변수의 집합</code>이다. 객체에는 클래스 변수나 메소드가 포함되지 않고 오직 인스턴스 변수들로만 구성되어 있다.</p><p>인스턴스 변수는 인스턴스마다 다른 값을 가질 수 있어야하기 때문에 별도의 메모리공간이 필요하지만 메소드는 인스턴스마다 변하는 것이 아니라서 메모리를 낭비해가면서 인스턴스마다 같은 내용을 포함시킬 필요가 없기 때문이다.</p><p>클래스에 정의된 인스턴스 변수가 단순히 기본형일 때는 인스턴스 변수의 값을 저장하는 일이 간단하지만, 인스턴스 변수의 타입이 참조형일 때는 그리 간단하지 않다. 하지만 우리에게는 객체를 직렬화/역직렬화할 수 있는 <code class="language-plaintext highlighter-rouge">ObjectInputStream</code>과 <code class="language-plaintext highlighter-rouge">ObjectOutputStream</code>이 있기때문에 걱정할 필요가 없다</p><h4 id="objectinputstream과-objectoutputstream">ObjectInputStream과 ObjectOutputStream</h4><p>직렬화에는 <code class="language-plaintext highlighter-rouge">ObjectInputStream</code>을 사용 하고 역직렬화에는 <code class="language-plaintext highlighter-rouge">ObjectOutputStream</code>을 사용한다. <code class="language-plaintext highlighter-rouge">ObjectInputStream</code>과 <code class="language-plaintext highlighter-rouge">ObjectOutputStream</code>은 각각 <code class="language-plaintext highlighter-rouge">InputStream</code>과 <code class="language-plaintext highlighter-rouge">OutputStream</code>을 직접 상속받긴하지만 보조스트림이기 때문에 객체를 생성할 때 입출력할 스트림을 지정해주어야 한다.</p><p>만일 파일에 객체를 저장하고 싶다면 다음과 같이 하면 된다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"objectfile.txt"</span><span class="o">);</span>
<span class="nc">ObjectOutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">fos</span><span class="o">);</span>
<span class="n">out</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="k">new</span> <span class="nc">UserInfo</span><span class="o">());</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">ObjectOutputStream</code>의 <code class="language-plaintext highlighter-rouge">writeObject(Object obj)</code>를 사용해서 객체를 출력하면, 객체가 파일에 직렬화되어 저장된다.</p><p>역직렬화 역시 간단한데, 입력스트림을 사용하고 <code class="language-plaintext highlighter-rouge">readObject()</code>를 통해 저장된 데이터를 읽기만 하면 객체로 역직렬화된다. 다만 <code class="language-plaintext highlighter-rouge">readObject()</code>의 반환타입이 <code class="language-plaintext highlighter-rouge">Object</code>이기때문에 객체의 원래타입으로 형변환을 해주어야 한다.</p><h4 id="직렬화가-가능한-클래스-만들기---serializable-transient">직렬화가 가능한 클래스 만들기 - Serializable, transient</h4><p>직렬화가 가능한 클래스로 만들기 위해서는 <code class="language-plaintext highlighter-rouge">java.io.Serializable</code> 인터페이스를 구현하도록 하면 된다. <code class="language-plaintext highlighter-rouge">Serializable</code>은 빈 인터페이스이지만 직렬화를 고려하여 작성한 클래스인지를 판단하는 기준이 된다.</p><p>또한, <code class="language-plaintext highlighter-rouge">Serializable</code>를 구현한 클래스를 상속하는 자식 클래스는 <code class="language-plaintext highlighter-rouge">Serializable</code>을 구현하지 않아도 직렬화가 가능하다. 그러나 다음과 같이 부모 클래스가 <code class="language-plaintext highlighter-rouge">Serializable</code>을 구현하지 않았다면 자식 클래스를 직렬화할 때 부모 클래스에 정의된 인스턴스 변수 <code class="language-plaintext highlighter-rouge">name</code>과 <code class="language-plaintext highlighter-rouge">strength</code>는 직렬화 대상에서 제외된다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Monster</span><span class="o">{</span>
    <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">strength</span><span class="o">;</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Digimon</span> <span class="kd">extends</span> <span class="nc">Monster</span> <span class="kd">implements</span> <span class="nc">Serializable</span><span class="o">{</span>
    <span class="nc">String</span> <span class="n">skill</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>이런 경우 조상 클래스에 정의된 인스턴스 변수까지 직렬화 대상에 포함시키기 위해서는 부모 클래스가 <code class="language-plaintext highlighter-rouge">Serializable</code>를 구현하도록 하던가 <code class="language-plaintext highlighter-rouge">Digimon</code> 클래스에서 부모 클래스의 인스턴스 변수들이 직렬화되도록 처리하는 코드를 직접 추가해야 한다.</p><p>그리고 만약 <code class="language-plaintext highlighter-rouge">Serializable</code>를 구현한 클래스에서 인스턴스 변수로 직렬화할 수 없는 클래스의 객체를 참조하고 있으면 <code class="language-plaintext highlighter-rouge">java.io.NotSerializableException</code>이 발생한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Digimon</span> <span class="kd">extends</span> <span class="nc">Monster</span> <span class="kd">implements</span> <span class="nc">Serializable</span><span class="o">{</span>
    <span class="nc">String</span> <span class="n">skill</span><span class="o">;</span>
    <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>하지만 아래의 경우에는 직렬화가 가능하다.</p><p>인스턴스 변수 obj의 타입이 직렬화가 되지않는 <code class="language-plaintext highlighter-rouge">Object</code>이긴 하지만 실제로 저장된 객체는 직렬화가 가능한 <code class="language-plaintext highlighter-rouge">String</code> 인스턴스이기 때문에 직렬화가 가능한 것이다. 인스턴스 변수의 타입이 아닌 실제로 연결된 객체의 종류에 의해서 결정된다는 것을 기억하자.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Digimon</span> <span class="kd">extends</span> <span class="nc">Monster</span> <span class="kd">implements</span> <span class="nc">Serializable</span><span class="o">{</span>
    <span class="nc">String</span> <span class="n">skill</span><span class="o">;</span>
    <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"abc"</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>직렬화하고자 하는 객체의 클래스에 직렬화가 되지 않는 객체에 대한 참조를 포함하고 있다면 제어자 <code class="language-plaintext highlighter-rouge">transient</code>를 붙여서 직렬화 대상에서 제외되도록 할 수 있다.</p><p>또는 보안상 직렬화되면 안되는 인스턴스 변수에 대해서도 <code class="language-plaintext highlighter-rouge">transient</code>를 사용할 수 있는데, 실제로 <code class="language-plaintext highlighter-rouge">transient</code>가 붙은 인스턴스 변수의 값은 그 타입의 기본값으로 직렬화된다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Digimon</span> <span class="kd">extends</span> <span class="nc">Monster</span> <span class="kd">implements</span> <span class="nc">Serializable</span><span class="o">{</span>
    <span class="nc">String</span> <span class="n">skill</span><span class="o">;</span>
    <span class="kd">transient</span> <span class="nc">String</span> <span class="n">password</span><span class="o">;</span>
    <span class="kd">transient</span> <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="직렬화-가능한-클래스의-버전관리">직렬화 가능한 클래스의 버전관리</h4><p>직렬화된 객체를 역직렬화할 때는 직렬화했을 때와 같은 클래스를 사용해야한다. 만약 클래스의 이름이 같더라도 클래스의 내용이 변경된 경우 또한 역직렬화에 실패하고 예외가 발생한다.</p><blockquote><p>static 변수나 상수 또는 transient가 붙은 인스턴스 변수가 추가되는 경우에는 직렬화에 영향을 끼치지 않는다.</p></blockquote><p>예외가 발생하는 이유는 직렬화할 때와 역직렬화할 때의 클래스의 버전이 다르기때문이다.</p><p>객체가 직렬화될 때 클래스에 정의된 멤버들의 정보를 이용해서 <code class="language-plaintext highlighter-rouge">serialVersionUID</code>라는 클래스의 버전을 자동생성해서 직렬화 내용에 포함된다.</p><p>따라서 역직렬화 시에 클래스의 <code class="language-plaintext highlighter-rouge">serialVersionUID</code>값을 비교함으로써 직렬화 시에 클래스와 일치하는지 확인하는 것이다.</p><p>이러한 점이 편리할 때도 있으나, 클래스가 조금만 변경되어도 해당 클래스를 재배포하는 것은 프로그램을 관리하기 어렵게 만들기도 한다.</p><p>이럴 때는 클래스의 버전을 수동으로 관리해줄 필요가 있다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Digimon</span> <span class="kd">extends</span> <span class="nc">Monster</span> <span class="kd">implements</span> <span class="nc">Serializable</span><span class="o">{</span>
    <span class="nc">String</span> <span class="n">skill</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">471097136812091</span><span class="o">;</span>    
<span class="o">}</span>
</pre></table></code></div></div><p>이렇게 클래스 내에 <code class="language-plaintext highlighter-rouge">serialVersionUID</code>를 정의해주면, 클래스의 내용이 바뀌어도 클래스의 버전이 자동 생성된 값으로 변경되지 않는다.</p><h3 id="파일-읽고-쓰기"><strong>파일 읽고 쓰기</strong></h3><h4 id="file-클래스">File 클래스</h4><p>파일은 기본적이면서도 가장 많이 사용되는 입출력 대상이기 때문에 중요하다. 자바에서는 <code class="language-plaintext highlighter-rouge">File</code> 클래스를 통해서 파일과 디렉토리를 다룰 수 있다. 그래서 <code class="language-plaintext highlighter-rouge">File</code> 인스턴스는 파일일 수도 있고, 디렉토리일 수도 있다.</p><blockquote><p>File 클래스에서 파일의 데이터를 읽고 쓰는 기능을 지원하는 것은 아니다. 파일의 입출력은 스트림을 사용해야 한다.</p></blockquote><p>특정 위치에 있는 파일을 <code class="language-plaintext highlighter-rouge">File</code> 객체로 만들기 위해서는 다음과 같이 선언한다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:/Temp/file.txt"</span><span class="o">);</span>
<span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\Temp\\file.txt"</span><span class="o">);</span>
</pre></table></code></div></div><blockquote><p>디렉토리를 구분하는하는 구분자는 OS마다 다르다. 윈도우에서는 “\" 또는 “/” 을 사용할 수 있고, 유닉스와 리눅스에서는 “/”를 사용한다.</p><p>”\" 을 사용한다면 이스케이프 문자(\) 로 기술해야 한다.</p></blockquote><p>파일을 읽고 쓰는 방법은 <code class="language-plaintext highlighter-rouge">FileWriter</code>, <code class="language-plaintext highlighter-rouge">BufferedWriter</code>, <code class="language-plaintext highlighter-rouge">FileReader</code>, <code class="language-plaintext highlighter-rouge">BufferedReader</code>를 사용하는데, 텍스트 파일인 경우 문자 스트림 클래스들을 사용하면 되고, 바이너리 파일인 경우 바이트 스트림을 기본적으로 사용한다.</p><ul><li>텍스트 파일인 경우<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>  <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"a.txt"</span><span class="o">));</span>
  <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"b.txt"</span><span class="o">));</span>
  <span class="nc">String</span> <span class="n">s</span><span class="o">;</span>
  <span class="k">while</span> <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
  <span class="o">}</span>
</pre></table></code></div></div><li>바이너리 파일인 경우<div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>  <span class="nc">BufferedInputStream</span> <span class="n">is</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"a.jpg"</span><span class="o">));</span>
  <span class="nc">BufferedOutputStream</span> <span class="n">os</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"b.jpg"</span><span class="o">));</span>
  <span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">16384</span><span class="o">];</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">is</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">os</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
  <span class="o">}</span>
</pre></table></code></div></div></ul><h3 id="-scanner-클래스">+) Scanner 클래스</h3><p><code class="language-plaintext highlighter-rouge">Scenner</code>는 키보드로 입력받거나, 파일로 입력받거나 문자열로 입력을 받는데 도움을 주는 아주 유용한 클래스로 <code class="language-plaintext highlighter-rouge">JDK1.5</code> 버전부터 추가된 클래스이다.</p><p><code class="language-plaintext highlighter-rouge">java.util.Scanner</code> 패키지 내에 있으며, byte를 읽어 문자, 정수, 실수, boolean, 문자열 등 다양한 타입으로 변환하여 리턴해주기 때문에 개발자가 원하는 타입 값으로 데이터를 쉽게 읽을 수 있게 한다.</p><p><code class="language-plaintext highlighter-rouge">Scanner</code>는 입력되는 값을 공백으로 구분되는 토큰 단위로 읽는다.</p><ul><li>공백 문자 : <code class="language-plaintext highlighter-rouge">\t</code>, <code class="language-plaintext highlighter-rouge">\f</code>, <code class="language-plaintext highlighter-rouge">\r</code>, <code class="language-plaintext highlighter-rouge">''</code>,<code class="language-plaintext highlighter-rouge">\n</code></ul><p>Scanner 기본 사용법</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>
<span class="o">...</span>
<span class="nc">Scanner</span> <span class="n">scan</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
</pre></table></code></div></div><p>Scanner의 주요 메소드</p><div class="table-wrapper"><table><thead><tr><th style="text-align: right">메소드<th style="text-align: right">설명<tbody><tr><td style="text-align: right">String next()<td style="text-align: right">다음 토큰을 문자열로 리턴<tr><td style="text-align: right">byte nextByte()<td style="text-align: right">다음 토큰을 byte 타입으로 리턴<tr><td style="text-align: right">short nextShort()<td style="text-align: right">다음 토큰을 short 타입으로 리턴<tr><td style="text-align: right">int nextInt()<td style="text-align: right">다음 토큰을 int 타입으로 리턴<tr><td style="text-align: right">long nextLong()<td style="text-align: right">다음 토큰을 long 타입으로 리턴<tr><td style="text-align: right">float nextFloat()<td style="text-align: right">다음 토큰을 float 타입으로 리턴<tr><td style="text-align: right">double nextDouble()<td style="text-align: right">다음 토큰을 double 타입으로 리턴<tr><td style="text-align: right">String nextLine()<td style="text-align: right">\n을 포함하는 한 라인을 읽고 \n을 버린 나머지만 리턴<tr><td style="text-align: right">void close()<td style="text-align: right">Scanner의 사용 종료<tr><td style="text-align: right">boolean hasNext()<td style="text-align: right">다음 토큰이 남아있으면 true 아니면 false</table></div><p>사용법도 간단하기 때문에 별다른 설명이 필요하지 않을 것이다. 데이터의 변수타입에 맞게만 가져오면 된다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nc">Scanner</span> <span class="n">scan</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">address</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="kt">double</span> <span class="n">weight</span><span class="o">;</span>

<span class="n">name</span> <span class="o">=</span> <span class="n">scan</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
<span class="n">address</span> <span class="o">=</span> <span class="n">scan</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
<span class="n">age</span> <span class="o">=</span> <span class="n">scan</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
<span class="n">weight</span> <span class="o">=</span> <span class="n">scan</span><span class="o">.</span><span class="na">nextDouble</span><span class="o">();</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="n">address</span> <span class="o">+</span> <span class="n">age</span> <span class="o">+</span> <span class="n">weight</span><span class="o">);</span>

<span class="n">scan</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</pre></table></code></div></div><p>그러나 <code class="language-plaintext highlighter-rouge">nextLine()</code>과 섞어서 사용할 때는 주의가 필요할 수 있다.</p><div lang="java" class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nc">Scanner</span> <span class="n">scan</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"나이를 입력하세요"</span><span class="o">);</span>
<span class="n">age</span> <span class="o">=</span> <span class="n">scan</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"이름을 입력하세요"</span><span class="o">);</span>
<span class="n">name</span> <span class="o">=</span> <span class="n">scan</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"나이는 %d, 이름은 %s입니다."</span><span class="o">,</span> <span class="n">age</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>

<span class="n">scan</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</pre></table></code></div></div><div lang="console" class="language-console highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="go">나이를 입력하세요
24
이름을 입력하세요
나이는 24, 이름은 입니다.
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">nextInt()</code>와 같이 타입을 지정해서 받는 메소드는 <code class="language-plaintext highlighter-rouge">Enter</code> 값을 무시하고 해당 타입만 받아와서 타입 변환 후 반환한다.</p><p>이 때 입력 소스에는 아직 <code class="language-plaintext highlighter-rouge">Enter</code>의 값이 남아있기 때문에 <code class="language-plaintext highlighter-rouge">nextLine()</code>이 <code class="language-plaintext highlighter-rouge">Enter</code>값을 받아들이고 그대로 입력으로 인식해 메소드가 종료된다.</p><h2 id="참조">참조</h2><p><a href="https://www.notion.so/I-O-af9b3036338c43a8bf9fa6a521cda242">https://www.notion.so/I-O-af9b3036338c43a8bf9fa6a521cda242</a><br /> <a href="https://bingbingpa.github.io/java/whiteship-live-study-week13/">https://bingbingpa.github.io/java/whiteship-live-study-week13/</a><br /> <a href="https://github.com/mongzza/java-study/blob/main/study/13%EC%A3%BC%EC%B0%A8.md">https://github.com/mongzza/java-study/blob/main/study/13%EC%A3%BC%EC%B0%A8.md</a><br /> <a href="https://watrv41.gitbook.io/devbook/java/java-live-study/13_week">https://watrv41.gitbook.io/devbook/java/java-live-study/13_week</a><br /> <a href="https://github.com/kyu9/WS_study/blob/master/week13.md">https://github.com/kyu9/WS_study/blob/master/week13.md</a><br /> <a href="https://mine-it-record.tistory.com/103">https://mine-it-record.tistory.com/103</a><br /> <a href="http://www.yes24.com/Product/Goods/24259565">자바의 정석</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/backend/'>Backend</a>, <a href='/categories/java/'>Java</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >java</a> <a href="/tags/java-study/" class="post-tag no-text-decoration" >java study</a> <a href="/tags/%EC%9E%90%EB%B0%94/" class="post-tag no-text-decoration" >자바</a> <a href="/tags/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%84%B0%EB%94%94/" class="post-tag no-text-decoration" >자바 스터디</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=자바 스터디 13 - I/O - yeoji21&url=https://yeoji21.github.io/posts/javastudy13/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=자바 스터디 13 - I/O - yeoji21&u=https://yeoji21.github.io/posts/javastudy13/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=자바 스터디 13 - I/O - yeoji21&url=https://yeoji21.github.io/posts/javastudy13/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink('', 'Link copied successfully!')" data-toggle="tooltip" data-placement="top" title="Copy link"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/polymorphism-inheritance/">객체지향에서의 상속과 다형성</a><li><a href="/posts/graduation-project-review/">졸업 작품 프로젝트 회고</a><li><a href="/posts/reflection-1/">[JAVA] Java Refelction 마스터 강의 1장</a><li><a href="/posts/mst/">[알고리즘] MST - 크루스칼 vs 프림</a><li><a href="/posts/injection/">[Spring] 의존성 주입 시 생성자 주입을 사용해야 하는 이유 </a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94/">자바</a> <a class="post-tag" href="/tags/java-study/">java study</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%84%B0%EB%94%94/">자바 스터디</a> <a class="post-tag" href="/tags/oop/">oop</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/guides/">guides</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/javastudy01/"><div class="card-body"> <span class="timeago small" >Aug 8, 2021<i class="unloaded">2021-08-08T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>자바 스터디 01 - JVM이란</h3><div class="text-muted small"><p> 들어가면서 백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다. 강의 링크 : [자바 뉴스 라이브] 2020/11/14, 자바 스터디 1주차 깃허브 링크 : 1주차 과제: JVM은 무엇이며 자바 코드는 어떻게 실행하는 것인가. 목차 JVM이란 무엇인가 컴파일 하는 방법 실행하는 방법 바...</p></div></div></a></div><div class="card"> <a href="/posts/javastudy02/"><div class="card-body"> <span class="timeago small" >Aug 10, 2021<i class="unloaded">2021-08-10T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>자바 스터디 02 - 자바 데이터 타입, 변수 그리고 배열</h3><div class="text-muted small"><p> 들어가면서 백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다. 강의 링크 : [자바 뉴스 라이브] 2020/11/21, 자바 스터디 2주차 깃허브 링크 : 2주차 과제: 자바 데이터 타입, 변수 그리고 배열 목차 프리미티브 타입 종류와 값의 범위 그리고 기본 값 프리미티브 타입과 레퍼런스 타...</p></div></div></a></div><div class="card"> <a href="/posts/javastudy03/"><div class="card-body"> <span class="timeago small" >Aug 11, 2021<i class="unloaded">2021-08-11T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>자바 스터디 03 - 연산자</h3><div class="text-muted small"><p> 들어가면서 백기선님이 진행하신 자바 스터디 강의와 스터디에 참여하신 분들의 자료를 참고하여 작성한 글입니다. 강의 영상 링크 : [자바 라이브 스터디] 2020/11/28, 자바 스터디 3주차 연산자를 알아보자. 강의 깃허브 링크 : 3주차 과제: 연산자 목차 산술 연산자 비트 연산자 관계 연산자 논리 연산자 instance...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/reflection/" class="btn btn-outline-primary" prompt="Older"><p>[JAVA] 리플렉션 (Reflection)</p></a> <a href="/posts/javastudy14/" class="btn btn-outline-primary" prompt="Newer"><p>자바 스터디 14 - 제네릭</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">yeoji21</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94/">자바</a> <a class="post-tag" href="/tags/java-study/">java study</a> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%84%B0%EB%94%94/">자바 스터디</a> <a class="post-tag" href="/tags/oop/">oop</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/guides/">guides</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://yeoji21.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
